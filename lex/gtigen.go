// Code generated by "goki generate"; DO NOT EDIT.

package lex

import (
	"goki.dev/gti"
	"goki.dev/ki/v2"
	"goki.dev/ordmap"
)

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.Actions",
	Doc:        "Actions are lexing actions to perform",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.Error",
	Doc:        "In an ErrorList, an error is represented by an *Error.\nThe position Pos, if valid, points to the beginning of\nthe offending token, and the error condition is described\nby Msg.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Pos", &gti.Field{Name: "Pos", Type: "Pos", Doc: "position where the error occurred in the source", Directives: gti.Directives{}}},
		{"Filename", &gti.Field{Name: "Filename", Type: "string", Doc: "full filename with path", Directives: gti.Directives{}}},
		{"Msg", &gti.Field{Name: "Msg", Type: "string", Doc: "brief error message", Directives: gti.Directives{}}},
		{"Src", &gti.Field{Name: "Src", Type: "string", Doc: "line of source where error was", Directives: gti.Directives{}}},
		{"Rule", &gti.Field{Name: "Rule", Type: "ki.Ki", Doc: "lexer or parser rule that emitted the error", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.ErrorList",
	Doc:        "ErrorList is a list of *Errors.\nThe zero value for an ErrorList is an empty ErrorList ready to use.",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.File",
	Doc:        "File contains the contents of the file being parsed -- all kept in\nmemory, and represented by Line as runes, so that positions in\nthe file are directly convertible to indexes in Lines structure",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Filename", &gti.Field{Name: "Filename", Type: "string", Doc: "the current file being lex'd", Directives: gti.Directives{}}},
		{"Sup", &gti.Field{Name: "Sup", Type: "filecat.Supported", Doc: "the supported file type, if supported (typically only supported files are processed)", Directives: gti.Directives{}}},
		{"BasePath", &gti.Field{Name: "BasePath", Type: "string", Doc: "base path for reporting file names -- this must be set externally e.g., by gide for the project root path", Directives: gti.Directives{}}},
		{"Lexs", &gti.Field{Name: "Lexs", Type: "[]Line", Doc: "lex'd version of the lines -- allocated to size of Lines", Directives: gti.Directives{}}},
		{"Comments", &gti.Field{Name: "Comments", Type: "[]Line", Doc: "comment tokens are stored separately here, so parser doesn't need to worry about them, but they are available for highlighting and other uses", Directives: gti.Directives{}}},
		{"LastStacks", &gti.Field{Name: "LastStacks", Type: "[]Stack", Doc: "stack present at the end of each line -- needed for contextualizing line-at-time lexing while editing", Directives: gti.Directives{}}},
		{"EosPos", &gti.Field{Name: "EosPos", Type: "[]EosPos", Doc: "token positions per line for the EOS (end of statement) tokens -- very important for scoping top-down parsing", Directives: gti.Directives{}}},
		{"Lines", &gti.Field{Name: "Lines", Type: "[][]rune", Doc: "contents of the file as lines of runes", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.Lex",
	Doc:        "Lex represents a single lexical element, with a token, and start and end rune positions\nwithin a line of a file.  Critically it also contains the nesting depth computed from\nall the parens, brackets, braces.  Todo: also support XML < > </ > tag depth.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Tok", &gti.Field{Name: "Tok", Type: "token.KeyToken", Doc: "token, includes cache of keyword for keyword types, and also has nesting depth: starting at 0 at start of file and going up for every increment in bracket / paren / start tag and down for every decrement. Is computed once and used extensively in parsing.", Directives: gti.Directives{}}},
		{"St", &gti.Field{Name: "St", Type: "int", Doc: "start rune index within original source line for this token", Directives: gti.Directives{}}},
		{"Ed", &gti.Field{Name: "Ed", Type: "int", Doc: "end rune index within original source line for this token (exclusive -- ends one before this)", Directives: gti.Directives{}}},
		{"Time", &gti.Field{Name: "Time", Type: "nptime.Time", Doc: "time when region was set -- used for updating locations in the text based on time stamp (using efficient non-pointer time)", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.Line",
	Doc:        "Line is one line of Lex'd text",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.Matches",
	Doc:        "Matches are what kind of lexing matches to make",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.MatchPos",
	Doc:        "MatchPos are special positions for a match to occur",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.PassTwo",
	Doc:        "PassTwo performs second pass(s) through the lexicalized version of the source,\ncomputing nesting depth for every token once and for all -- this is essential for\nproperly matching tokens and also for colorization in syntax highlighting.\nOptionally, a subsequent pass finds end-of-statement (EOS) tokens, which are essential\nfor parsing to first break the source down into statement-sized chunks.  A separate\nlist of EOS token positions is maintained for very fast access.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"DoEos", &gti.Field{Name: "DoEos", Type: "bool", Doc: "should we perform EOS detection on this type of file?", Directives: gti.Directives{}}},
		{"Eol", &gti.Field{Name: "Eol", Type: "bool", Doc: "use end-of-line as a default EOS, if nesting depth is same as start of line (python) -- see also EolToks", Directives: gti.Directives{}}},
		{"Semi", &gti.Field{Name: "Semi", Type: "bool", Doc: "replace all semicolons with EOS to keep it consistent (C, Go..)", Directives: gti.Directives{}}},
		{"Backslash", &gti.Field{Name: "Backslash", Type: "bool", Doc: "use backslash as a line continuer (python)", Directives: gti.Directives{}}},
		{"RBraceEos", &gti.Field{Name: "RBraceEos", Type: "bool", Doc: "if a right-brace } is detected anywhere in the line, insert an EOS *before* RBrace AND after it (needed for Go) -- do not include RBrace in EolToks in this case", Directives: gti.Directives{}}},
		{"EolToks", &gti.Field{Name: "EolToks", Type: "token.KeyTokenList", Doc: "specific tokens to recognize at the end of a line that trigger an EOS (Go)", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.TwoState",
	Doc:        "TwoState is the state maintained for the PassTwo process",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Pos", &gti.Field{Name: "Pos", Type: "Pos", Doc: "position in lex tokens we're on", Directives: gti.Directives{}}},
		{"Src", &gti.Field{Name: "Src", Type: "*File", Doc: "file that we're operating on", Directives: gti.Directives{}}},
		{"NestStack", &gti.Field{Name: "NestStack", Type: "[]token.Tokens", Doc: "stack of nesting tokens", Directives: gti.Directives{}}},
		{"Errs", &gti.Field{Name: "Errs", Type: "ErrorList", Doc: "any error messages accumulated during lexing specifically", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.Pos",
	Doc:        "Pos is a position within the source file -- it is recorded always in 0, 0\noffset positions, but is converted into 1,1 offset for public consumption\nCh positions are always in runes, not bytes.  Also used for lex token indexes.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Ln", &gti.Field{Name: "Ln", Type: "int", Doc: "", Directives: gti.Directives{}}},
		{"Ch", &gti.Field{Name: "Ch", Type: "int", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.Reg",
	Doc:        "Reg is a contiguous region within the source file",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"St", &gti.Field{Name: "St", Type: "Pos", Doc: "starting position of region", Directives: gti.Directives{}}},
		{"Ed", &gti.Field{Name: "Ed", Type: "Pos", Doc: "ending position of region", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.EosPos",
	Doc:        "EosPos is a line of EOS token positions, always sorted low-to-high",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.TokenMap",
	Doc:        "TokenMap is a token map, for optimizing token exclusion",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.Lexer",
	Doc:        "Lexer is the interface type for lexers -- likely not necessary except is essential\nfor defining the BaseIface for gui in making new nodes",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// RuleType is the [gti.Type] for [Rule]
var RuleType = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.Rule",
	Doc:        "lex.Rule operates on the text input to produce the lexical tokens.\n\nLexing is done line-by-line -- you must push and pop states to\ncoordinate across multiple lines, e.g., for multi-line comments.\n\nThere is full access to entire line and you can decide based on future\n(offset) characters.\n\nIn general it is best to keep lexing as simple as possible and\nleave the more complex things for the parsing step.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Off", &gti.Field{Name: "Off", Type: "bool", Doc: "disable this rule -- useful for testing and exploration", Directives: gti.Directives{}}},
		{"Desc", &gti.Field{Name: "Desc", Type: "string", Doc: "description / comments about this rule", Directives: gti.Directives{}}},
		{"Token", &gti.Field{Name: "Token", Type: "token.Tokens", Doc: "the token value that this rule generates -- use None for non-terminals", Directives: gti.Directives{}}},
		{"Match", &gti.Field{Name: "Match", Type: "Matches", Doc: "the lexical match that we look for to engage this rule", Directives: gti.Directives{}}},
		{"Pos", &gti.Field{Name: "Pos", Type: "MatchPos", Doc: "position where match can occur", Directives: gti.Directives{}}},
		{"String", &gti.Field{Name: "String", Type: "string", Doc: "if action is LexMatch, this is the string we match", Directives: gti.Directives{}}},
		{"Offset", &gti.Field{Name: "Offset", Type: "int", Doc: "offset into the input to look for a match: 0 = current char, 1 = next one, etc", Directives: gti.Directives{}}},
		{"SizeAdj", &gti.Field{Name: "SizeAdj", Type: "int", Doc: "adjusts the size of the region (plus or minus) that is processed for the Next action -- allows broader and narrower matching relative to tagging", Directives: gti.Directives{}}},
		{"Acts", &gti.Field{Name: "Acts", Type: "[]Actions", Doc: "the action(s) to perform, in order, if there is a match -- these are performed prior to iterating over child nodes", Directives: gti.Directives{}}},
		{"Until", &gti.Field{Name: "Until", Type: "string", Doc: "string(s) for ReadUntil action -- will read until any of these strings are found -- separate different options with | -- if you need to read until a literal | just put two || in a row and that will show up as a blank, which is interpreted as a literal |", Directives: gti.Directives{}}},
		{"PushState", &gti.Field{Name: "PushState", Type: "string", Doc: "the state to push if our action is PushState -- note that State matching is on String, not this value", Directives: gti.Directives{}}},
		{"NameMap", &gti.Field{Name: "NameMap", Type: "bool", Doc: "create an optimization map for this rule, which must be a parent with children that all match against a Name string -- this reads the Name and directly activates the associated rule with that String, without having to iterate through them -- use this for keywords etc -- produces a SIGNIFICANT speedup for long lists of keywords.", Directives: gti.Directives{}}},
		{"MatchLen", &gti.Field{Name: "MatchLen", Type: "int", Doc: "[view: -] length of source that matched -- if Next is called, this is what will be skipped to", Directives: gti.Directives{}}},
		{"NmMap", &gti.Field{Name: "NmMap", Type: "map[string]*Rule", Doc: "NameMap lookup map -- created during Compile", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Rule{},
})

// NewRule adds a new [Rule] with
// the given name to the given parent.
func NewRule(par ki.Ki, name string) *Rule {
	return par.NewChild(RuleType, name).(*Rule)
}

// Type returns the [*gti.Type] of [Rule]
func (t *Rule) Type() *gti.Type {
	return RuleType
}

// New returns a new [*Rule] value
func (t *Rule) New() ki.Ki {
	return &Rule{}
}

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.Stack",
	Doc:        "Stack is the stack for states",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.LangLexer",
	Doc:        "LangLexer looks up lexer for given language -- impl in parent pi package\nso we need the interface",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/v2/lex.State",
	Doc:        "lex.State is the state maintained for lexing",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Filename", &gti.Field{Name: "Filename", Type: "string", Doc: "the current file being lex'd", Directives: gti.Directives{}}},
		{"KeepWS", &gti.Field{Name: "KeepWS", Type: "bool", Doc: "if true, record whitespace tokens -- else ignore", Directives: gti.Directives{}}},
		{"Src", &gti.Field{Name: "Src", Type: "[]rune", Doc: "the current line of source being processed", Directives: gti.Directives{}}},
		{"Lex", &gti.Field{Name: "Lex", Type: "Line", Doc: "the lex output for this line", Directives: gti.Directives{}}},
		{"Comments", &gti.Field{Name: "Comments", Type: "Line", Doc: "the comments output for this line -- kept separately", Directives: gti.Directives{}}},
		{"Pos", &gti.Field{Name: "Pos", Type: "int", Doc: "the current rune char position within the line", Directives: gti.Directives{}}},
		{"Ln", &gti.Field{Name: "Ln", Type: "int", Doc: "the line within overall source that we're operating on (0 indexed)", Directives: gti.Directives{}}},
		{"Ch", &gti.Field{Name: "Ch", Type: "rune", Doc: "the current rune read by NextRune", Directives: gti.Directives{}}},
		{"Stack", &gti.Field{Name: "Stack", Type: "Stack", Doc: "state stack", Directives: gti.Directives{}}},
		{"LastName", &gti.Field{Name: "LastName", Type: "string", Doc: "the last name that was read", Directives: gti.Directives{}}},
		{"GuestLex", &gti.Field{Name: "GuestLex", Type: "*Rule", Doc: "a guest lexer that can be installed for managing a different language type, e.g., quoted text in markdown files", Directives: gti.Directives{}}},
		{"SaveStack", &gti.Field{Name: "SaveStack", Type: "Stack", Doc: "copy of stack at point when guest lexer was installed -- restore when popped", Directives: gti.Directives{}}},
		{"Time", &gti.Field{Name: "Time", Type: "nptime.Time", Doc: "time stamp for lexing -- set at start of new lex process", Directives: gti.Directives{}}},
		{"Errs", &gti.Field{Name: "Errs", Type: "ErrorList", Doc: "any error messages accumulated during lexing specifically", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})
