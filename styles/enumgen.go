// Code generated by "core generate"; DO NOT EDIT.

package styles

import (
	"cogentcore.org/core/enums"
)

var _BorderStylesValues = []BorderStyles{0, 1, 2, 3, 4, 5, 6, 7, 8}

// BorderStylesN is the highest valid value for type BorderStyles, plus one.
const BorderStylesN BorderStyles = 9

var _BorderStylesValueMap = map[string]BorderStyles{`solid`: 0, `dotted`: 1, `dashed`: 2, `double`: 3, `groove`: 4, `ridge`: 5, `inset`: 6, `outset`: 7, `none`: 8}

var _BorderStylesDescMap = map[BorderStyles]string{0: `BorderSolid indicates to render a solid border.`, 1: `BorderDotted indicates to render a dotted border.`, 2: `BorderDashed indicates to render a dashed border.`, 3: `BorderDouble is not currently supported.`, 4: `BorderGroove is not currently supported.`, 5: `BorderRidge is not currently supported.`, 6: `BorderInset is not currently supported.`, 7: `BorderOutset is not currently supported.`, 8: `BorderNone indicates to render no border.`}

var _BorderStylesMap = map[BorderStyles]string{0: `solid`, 1: `dotted`, 2: `dashed`, 3: `double`, 4: `groove`, 5: `ridge`, 6: `inset`, 7: `outset`, 8: `none`}

// String returns the string representation of this BorderStyles value.
func (i BorderStyles) String() string { return enums.String(i, _BorderStylesMap) }

// SetString sets the BorderStyles value from its string representation,
// and returns an error if the string is invalid.
func (i *BorderStyles) SetString(s string) error {
	return enums.SetString(i, s, _BorderStylesValueMap, "BorderStyles")
}

// Int64 returns the BorderStyles value as an int64.
func (i BorderStyles) Int64() int64 { return int64(i) }

// SetInt64 sets the BorderStyles value from an int64.
func (i *BorderStyles) SetInt64(in int64) { *i = BorderStyles(in) }

// Desc returns the description of the BorderStyles value.
func (i BorderStyles) Desc() string { return enums.Desc(i, _BorderStylesDescMap) }

// BorderStylesValues returns all possible values for the type BorderStyles.
func BorderStylesValues() []BorderStyles { return _BorderStylesValues }

// Values returns all possible values for the type BorderStyles.
func (i BorderStyles) Values() []enums.Enum { return enums.Values(_BorderStylesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BorderStyles) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BorderStyles) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "BorderStyles")
}

var _FontStylesValues = []FontStyles{0, 1, 2}

// FontStylesN is the highest valid value for type FontStyles, plus one.
const FontStylesN FontStyles = 3

var _FontStylesValueMap = map[string]FontStyles{`normal`: 0, `italic`: 1, `oblique`: 2}

var _FontStylesDescMap = map[FontStyles]string{0: ``, 1: `Italic indicates to make font italic`, 2: `Oblique indicates to make font slanted`}

var _FontStylesMap = map[FontStyles]string{0: `normal`, 1: `italic`, 2: `oblique`}

// String returns the string representation of this FontStyles value.
func (i FontStyles) String() string { return enums.String(i, _FontStylesMap) }

// SetString sets the FontStyles value from its string representation,
// and returns an error if the string is invalid.
func (i *FontStyles) SetString(s string) error {
	return enums.SetString(i, s, _FontStylesValueMap, "FontStyles")
}

// Int64 returns the FontStyles value as an int64.
func (i FontStyles) Int64() int64 { return int64(i) }

// SetInt64 sets the FontStyles value from an int64.
func (i *FontStyles) SetInt64(in int64) { *i = FontStyles(in) }

// Desc returns the description of the FontStyles value.
func (i FontStyles) Desc() string { return enums.Desc(i, _FontStylesDescMap) }

// FontStylesValues returns all possible values for the type FontStyles.
func FontStylesValues() []FontStyles { return _FontStylesValues }

// Values returns all possible values for the type FontStyles.
func (i FontStyles) Values() []enums.Enum { return enums.Values(_FontStylesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FontStyles) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FontStyles) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "FontStyles")
}

var _FontWeightsValues = []FontWeights{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}

// FontWeightsN is the highest valid value for type FontWeights, plus one.
const FontWeightsN FontWeights = 20

var _FontWeightsValueMap = map[string]FontWeights{`normal`: 0, `100`: 1, `thin`: 2, `200`: 3, `extra-light`: 4, `300`: 5, `light`: 6, `400`: 7, `500`: 8, `medium`: 9, `600`: 10, `semi-bold`: 11, `700`: 12, `bold`: 13, `800`: 14, `extra-bold`: 15, `900`: 16, `black`: 17, `bolder`: 18, `lighter`: 19}

var _FontWeightsDescMap = map[FontWeights]string{0: ``, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: ``, 7: ``, 8: ``, 9: ``, 10: ``, 11: ``, 12: ``, 13: ``, 14: ``, 15: ``, 16: ``, 17: ``, 18: ``, 19: ``}

var _FontWeightsMap = map[FontWeights]string{0: `normal`, 1: `100`, 2: `thin`, 3: `200`, 4: `extra-light`, 5: `300`, 6: `light`, 7: `400`, 8: `500`, 9: `medium`, 10: `600`, 11: `semi-bold`, 12: `700`, 13: `bold`, 14: `800`, 15: `extra-bold`, 16: `900`, 17: `black`, 18: `bolder`, 19: `lighter`}

// String returns the string representation of this FontWeights value.
func (i FontWeights) String() string { return enums.String(i, _FontWeightsMap) }

// SetString sets the FontWeights value from its string representation,
// and returns an error if the string is invalid.
func (i *FontWeights) SetString(s string) error {
	return enums.SetString(i, s, _FontWeightsValueMap, "FontWeights")
}

// Int64 returns the FontWeights value as an int64.
func (i FontWeights) Int64() int64 { return int64(i) }

// SetInt64 sets the FontWeights value from an int64.
func (i *FontWeights) SetInt64(in int64) { *i = FontWeights(in) }

// Desc returns the description of the FontWeights value.
func (i FontWeights) Desc() string { return enums.Desc(i, _FontWeightsDescMap) }

// FontWeightsValues returns all possible values for the type FontWeights.
func FontWeightsValues() []FontWeights { return _FontWeightsValues }

// Values returns all possible values for the type FontWeights.
func (i FontWeights) Values() []enums.Enum { return enums.Values(_FontWeightsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FontWeights) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FontWeights) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "FontWeights")
}

var _FontStretchValues = []FontStretch{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

// FontStretchN is the highest valid value for type FontStretch, plus one.
const FontStretchN FontStretch = 11

var _FontStretchValueMap = map[string]FontStretch{`Normal`: 0, `UltraCondensed`: 1, `ExtraCondensed`: 2, `SemiCondensed`: 3, `SemiExpanded`: 4, `ExtraExpanded`: 5, `UltraExpanded`: 6, `Condensed`: 7, `Expanded`: 8, `Narrower`: 9, `Wider`: 10}

var _FontStretchDescMap = map[FontStretch]string{0: ``, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: ``, 7: ``, 8: ``, 9: ``, 10: ``}

var _FontStretchMap = map[FontStretch]string{0: `Normal`, 1: `UltraCondensed`, 2: `ExtraCondensed`, 3: `SemiCondensed`, 4: `SemiExpanded`, 5: `ExtraExpanded`, 6: `UltraExpanded`, 7: `Condensed`, 8: `Expanded`, 9: `Narrower`, 10: `Wider`}

// String returns the string representation of this FontStretch value.
func (i FontStretch) String() string { return enums.String(i, _FontStretchMap) }

// SetString sets the FontStretch value from its string representation,
// and returns an error if the string is invalid.
func (i *FontStretch) SetString(s string) error {
	return enums.SetString(i, s, _FontStretchValueMap, "FontStretch")
}

// Int64 returns the FontStretch value as an int64.
func (i FontStretch) Int64() int64 { return int64(i) }

// SetInt64 sets the FontStretch value from an int64.
func (i *FontStretch) SetInt64(in int64) { *i = FontStretch(in) }

// Desc returns the description of the FontStretch value.
func (i FontStretch) Desc() string { return enums.Desc(i, _FontStretchDescMap) }

// FontStretchValues returns all possible values for the type FontStretch.
func FontStretchValues() []FontStretch { return _FontStretchValues }

// Values returns all possible values for the type FontStretch.
func (i FontStretch) Values() []enums.Enum { return enums.Values(_FontStretchValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FontStretch) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FontStretch) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "FontStretch")
}

var _TextDecorationsValues = []TextDecorations{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

// TextDecorationsN is the highest valid value for type TextDecorations, plus one.
const TextDecorationsN TextDecorations = 10

var _TextDecorationsValueMap = map[string]TextDecorations{`none`: 0, `underline`: 1, `overline`: 2, `line-through`: 3, `blink`: 4, `dotted-underline`: 5, `para-start`: 6, `super`: 7, `sub`: 8, `background-color`: 9}

var _TextDecorationsDescMap = map[TextDecorations]string{0: ``, 1: `Underline indicates to place a line below text`, 2: `Overline indicates to place a line above text`, 3: `LineThrough indicates to place a line through text`, 4: `Blink is not currently supported (and probably a bad idea generally ;)`, 5: `DottedUnderline is used for abbr tag -- otherwise not a standard text-decoration option afaik`, 6: `DecoParaStart at start of a SpanRender indicates that it should be styled as the start of a new paragraph and not just the start of a new line`, 7: `DecoSuper indicates super-scripted text`, 8: `DecoSub indicates sub-scripted text`, 9: `DecoBackgroundColor indicates that a bg color has been set -- for use in optimizing rendering`}

var _TextDecorationsMap = map[TextDecorations]string{0: `none`, 1: `underline`, 2: `overline`, 3: `line-through`, 4: `blink`, 5: `dotted-underline`, 6: `para-start`, 7: `super`, 8: `sub`, 9: `background-color`}

// String returns the string representation of this TextDecorations value.
func (i TextDecorations) String() string { return enums.BitFlagString(i, _TextDecorationsValues) }

// BitIndexString returns the string representation of this TextDecorations value
// if it is a bit index value (typically an enum constant), and
// not an actual bit flag value.
func (i TextDecorations) BitIndexString() string { return enums.String(i, _TextDecorationsMap) }

// SetString sets the TextDecorations value from its string representation,
// and returns an error if the string is invalid.
func (i *TextDecorations) SetString(s string) error { *i = 0; return i.SetStringOr(s) }

// SetStringOr sets the TextDecorations value from its string representation
// while preserving any bit flags already set, and returns an
// error if the string is invalid.
func (i *TextDecorations) SetStringOr(s string) error {
	return enums.SetStringOr(i, s, _TextDecorationsValueMap, "TextDecorations")
}

// Int64 returns the TextDecorations value as an int64.
func (i TextDecorations) Int64() int64 { return int64(i) }

// SetInt64 sets the TextDecorations value from an int64.
func (i *TextDecorations) SetInt64(in int64) { *i = TextDecorations(in) }

// Desc returns the description of the TextDecorations value.
func (i TextDecorations) Desc() string { return enums.Desc(i, _TextDecorationsDescMap) }

// TextDecorationsValues returns all possible values for the type TextDecorations.
func TextDecorationsValues() []TextDecorations { return _TextDecorationsValues }

// Values returns all possible values for the type TextDecorations.
func (i TextDecorations) Values() []enums.Enum { return enums.Values(_TextDecorationsValues) }

// HasFlag returns whether these bit flags have the given bit flag set.
func (i *TextDecorations) HasFlag(f enums.BitFlag) bool { return enums.HasFlag((*int64)(i), f) }

// SetFlag sets the value of the given flags in these flags to the given value.
func (i *TextDecorations) SetFlag(on bool, f ...enums.BitFlag) { enums.SetFlag((*int64)(i), on, f...) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextDecorations) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextDecorations) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "TextDecorations")
}

var _BaselineShiftsValues = []BaselineShifts{0, 1, 2}

// BaselineShiftsN is the highest valid value for type BaselineShifts, plus one.
const BaselineShiftsN BaselineShifts = 3

var _BaselineShiftsValueMap = map[string]BaselineShifts{`baseline`: 0, `super`: 1, `sub`: 2}

var _BaselineShiftsDescMap = map[BaselineShifts]string{0: ``, 1: ``, 2: ``}

var _BaselineShiftsMap = map[BaselineShifts]string{0: `baseline`, 1: `super`, 2: `sub`}

// String returns the string representation of this BaselineShifts value.
func (i BaselineShifts) String() string { return enums.String(i, _BaselineShiftsMap) }

// SetString sets the BaselineShifts value from its string representation,
// and returns an error if the string is invalid.
func (i *BaselineShifts) SetString(s string) error {
	return enums.SetString(i, s, _BaselineShiftsValueMap, "BaselineShifts")
}

// Int64 returns the BaselineShifts value as an int64.
func (i BaselineShifts) Int64() int64 { return int64(i) }

// SetInt64 sets the BaselineShifts value from an int64.
func (i *BaselineShifts) SetInt64(in int64) { *i = BaselineShifts(in) }

// Desc returns the description of the BaselineShifts value.
func (i BaselineShifts) Desc() string { return enums.Desc(i, _BaselineShiftsDescMap) }

// BaselineShiftsValues returns all possible values for the type BaselineShifts.
func BaselineShiftsValues() []BaselineShifts { return _BaselineShiftsValues }

// Values returns all possible values for the type BaselineShifts.
func (i BaselineShifts) Values() []enums.Enum { return enums.Values(_BaselineShiftsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BaselineShifts) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BaselineShifts) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "BaselineShifts")
}

var _FontVariantsValues = []FontVariants{0, 1}

// FontVariantsN is the highest valid value for type FontVariants, plus one.
const FontVariantsN FontVariants = 2

var _FontVariantsValueMap = map[string]FontVariants{`normal`: 0, `small-caps`: 1}

var _FontVariantsDescMap = map[FontVariants]string{0: ``, 1: ``}

var _FontVariantsMap = map[FontVariants]string{0: `normal`, 1: `small-caps`}

// String returns the string representation of this FontVariants value.
func (i FontVariants) String() string { return enums.String(i, _FontVariantsMap) }

// SetString sets the FontVariants value from its string representation,
// and returns an error if the string is invalid.
func (i *FontVariants) SetString(s string) error {
	return enums.SetString(i, s, _FontVariantsValueMap, "FontVariants")
}

// Int64 returns the FontVariants value as an int64.
func (i FontVariants) Int64() int64 { return int64(i) }

// SetInt64 sets the FontVariants value from an int64.
func (i *FontVariants) SetInt64(in int64) { *i = FontVariants(in) }

// Desc returns the description of the FontVariants value.
func (i FontVariants) Desc() string { return enums.Desc(i, _FontVariantsDescMap) }

// FontVariantsValues returns all possible values for the type FontVariants.
func FontVariantsValues() []FontVariants { return _FontVariantsValues }

// Values returns all possible values for the type FontVariants.
func (i FontVariants) Values() []enums.Enum { return enums.Values(_FontVariantsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FontVariants) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FontVariants) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "FontVariants")
}

var _DirectionsValues = []Directions{0, 1}

// DirectionsN is the highest valid value for type Directions, plus one.
const DirectionsN Directions = 2

var _DirectionsValueMap = map[string]Directions{`row`: 0, `column`: 1}

var _DirectionsDescMap = map[Directions]string{0: `Row indicates that elements are laid out in a row or that an element is longer / travels in the x dimension.`, 1: `Column indicates that elements are laid out in a column or that an element is longer / travels in the y dimension.`}

var _DirectionsMap = map[Directions]string{0: `row`, 1: `column`}

// String returns the string representation of this Directions value.
func (i Directions) String() string { return enums.String(i, _DirectionsMap) }

// SetString sets the Directions value from its string representation,
// and returns an error if the string is invalid.
func (i *Directions) SetString(s string) error {
	return enums.SetString(i, s, _DirectionsValueMap, "Directions")
}

// Int64 returns the Directions value as an int64.
func (i Directions) Int64() int64 { return int64(i) }

// SetInt64 sets the Directions value from an int64.
func (i *Directions) SetInt64(in int64) { *i = Directions(in) }

// Desc returns the description of the Directions value.
func (i Directions) Desc() string { return enums.Desc(i, _DirectionsDescMap) }

// DirectionsValues returns all possible values for the type Directions.
func DirectionsValues() []Directions { return _DirectionsValues }

// Values returns all possible values for the type Directions.
func (i Directions) Values() []enums.Enum { return enums.Values(_DirectionsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Directions) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Directions) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "Directions")
}

var _DisplaysValues = []Displays{0, 1, 2, 3, 4, 5, 6}

// DisplaysN is the highest valid value for type Displays, plus one.
const DisplaysN Displays = 7

var _DisplaysValueMap = map[string]Displays{`flex`: 0, `stacked`: 1, `grid`: 2, `no-layout`: 3, `block`: 4, `inline`: 5, `none`: 6}

var _DisplaysDescMap = map[Displays]string{0: `Flex is the default layout model, based on a simplified version of the CSS flex layout: uses MainAxis to specify the direction, Wrap for wrapping of elements, and Min, Max, and Grow values on elements to determine sizing.`, 1: `Stacked is a stack of elements, with one on top that is visible`, 2: `Grid is the X, Y grid layout, with Columns specifying the number of elements in the X axis.`, 3: `NoLayout means that no automatic layout will be applied to elements, which can then be managed via custom code.`, 4: `Block implements the HTML / CSS Block (vs. Inline) layout logic. It is not recommended for GUI applications but is needed for HTML rendering in htmlcore. A Block container establishes the outer context in which block vs. inline formatting takes place.`, 5: `Inline implements the HTML / CSS Inline layout logic, within a surrounding Block element (does not work in other layout types). It is not recommended for GUI applications but is needed for HTML rendering in htmlcore. A Block container establishes the outer context in which block vs. inline formatting takes place.`, 6: `None means the item is not displayed: sets the Invisible state`}

var _DisplaysMap = map[Displays]string{0: `flex`, 1: `stacked`, 2: `grid`, 3: `no-layout`, 4: `block`, 5: `inline`, 6: `none`}

// String returns the string representation of this Displays value.
func (i Displays) String() string { return enums.String(i, _DisplaysMap) }

// SetString sets the Displays value from its string representation,
// and returns an error if the string is invalid.
func (i *Displays) SetString(s string) error {
	return enums.SetString(i, s, _DisplaysValueMap, "Displays")
}

// Int64 returns the Displays value as an int64.
func (i Displays) Int64() int64 { return int64(i) }

// SetInt64 sets the Displays value from an int64.
func (i *Displays) SetInt64(in int64) { *i = Displays(in) }

// Desc returns the description of the Displays value.
func (i Displays) Desc() string { return enums.Desc(i, _DisplaysDescMap) }

// DisplaysValues returns all possible values for the type Displays.
func DisplaysValues() []Displays { return _DisplaysValues }

// Values returns all possible values for the type Displays.
func (i Displays) Values() []enums.Enum { return enums.Values(_DisplaysValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Displays) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Displays) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Displays") }

var _AlignsValues = []Aligns{0, 1, 2, 3, 4, 5, 6, 7}

// AlignsN is the highest valid value for type Aligns, plus one.
const AlignsN Aligns = 8

var _AlignsValueMap = map[string]Aligns{`auto`: 0, `start`: 1, `end`: 2, `center`: 3, `baseline`: 4, `space-between`: 5, `space-around`: 6, `space-evenly`: 7}

var _AlignsDescMap = map[Aligns]string{0: `Auto means the item uses the container&#39;s AlignItems value`, 1: `Align items to the start (top, left) of layout`, 2: `Align items to the end (bottom, right) of layout`, 3: `Align items centered`, 4: `Align to text baselines`, 5: `First and last are flush, equal space between remaining items`, 6: `First and last have 1/2 space at edges, full space between remaining items`, 7: `Equal space at start, end, and between all items`}

var _AlignsMap = map[Aligns]string{0: `auto`, 1: `start`, 2: `end`, 3: `center`, 4: `baseline`, 5: `space-between`, 6: `space-around`, 7: `space-evenly`}

// String returns the string representation of this Aligns value.
func (i Aligns) String() string { return enums.String(i, _AlignsMap) }

// SetString sets the Aligns value from its string representation,
// and returns an error if the string is invalid.
func (i *Aligns) SetString(s string) error { return enums.SetString(i, s, _AlignsValueMap, "Aligns") }

// Int64 returns the Aligns value as an int64.
func (i Aligns) Int64() int64 { return int64(i) }

// SetInt64 sets the Aligns value from an int64.
func (i *Aligns) SetInt64(in int64) { *i = Aligns(in) }

// Desc returns the description of the Aligns value.
func (i Aligns) Desc() string { return enums.Desc(i, _AlignsDescMap) }

// AlignsValues returns all possible values for the type Aligns.
func AlignsValues() []Aligns { return _AlignsValues }

// Values returns all possible values for the type Aligns.
func (i Aligns) Values() []enums.Enum { return enums.Values(_AlignsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Aligns) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Aligns) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Aligns") }

var _OverflowsValues = []Overflows{0, 1, 2, 3}

// OverflowsN is the highest valid value for type Overflows, plus one.
const OverflowsN Overflows = 4

var _OverflowsValueMap = map[string]Overflows{`visible`: 0, `hidden`: 1, `auto`: 2, `scroll`: 3}

var _OverflowsDescMap = map[Overflows]string{0: `OverflowVisible makes the overflow visible, meaning that the size of the container is always at least the Min size of its contents. No scrollbars are shown.`, 1: `OverflowHidden hides the overflow and doesn&#39;t present scrollbars.`, 2: `OverflowAuto automatically determines if scrollbars should be added to show the overflow. Scrollbars are added only if the actual content size is greater than the currently available size.`, 3: `OverflowScroll means that scrollbars are always visible, and is otherwise identical to Auto. However, only during Viewport PrefSize call, the actual content size is used -- otherwise it behaves just like Auto.`}

var _OverflowsMap = map[Overflows]string{0: `visible`, 1: `hidden`, 2: `auto`, 3: `scroll`}

// String returns the string representation of this Overflows value.
func (i Overflows) String() string { return enums.String(i, _OverflowsMap) }

// SetString sets the Overflows value from its string representation,
// and returns an error if the string is invalid.
func (i *Overflows) SetString(s string) error {
	return enums.SetString(i, s, _OverflowsValueMap, "Overflows")
}

// Int64 returns the Overflows value as an int64.
func (i Overflows) Int64() int64 { return int64(i) }

// SetInt64 sets the Overflows value from an int64.
func (i *Overflows) SetInt64(in int64) { *i = Overflows(in) }

// Desc returns the description of the Overflows value.
func (i Overflows) Desc() string { return enums.Desc(i, _OverflowsDescMap) }

// OverflowsValues returns all possible values for the type Overflows.
func OverflowsValues() []Overflows { return _OverflowsValues }

// Values returns all possible values for the type Overflows.
func (i Overflows) Values() []enums.Enum { return enums.Values(_OverflowsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Overflows) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Overflows) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "Overflows")
}

var _ObjectFitsValues = []ObjectFits{0, 1, 2, 3, 4}

// ObjectFitsN is the highest valid value for type ObjectFits, plus one.
const ObjectFitsN ObjectFits = 5

var _ObjectFitsValueMap = map[string]ObjectFits{`fill`: 0, `contain`: 1, `cover`: 2, `none`: 3, `scale-down`: 4}

var _ObjectFitsDescMap = map[ObjectFits]string{0: `FitFill indicates that the replaced object will fill the element&#39;s entire content box, stretching if necessary.`, 1: `FitContain indicates that the replaced object will resize as large as possible while fully fitting within the element&#39;s content box and maintaining its aspect ratio. Therefore, it may not fill the entire element.`, 2: `FitCover indicates that the replaced object will fill the element&#39;s entire content box, clipping if necessary.`, 3: `FitNone indicates that the replaced object will not resize.`, 4: `FitScaleDown indicates that the replaced object will size as if [FitNone] or [FitContain] was specified, using whichever will result in a smaller final size.`}

var _ObjectFitsMap = map[ObjectFits]string{0: `fill`, 1: `contain`, 2: `cover`, 3: `none`, 4: `scale-down`}

// String returns the string representation of this ObjectFits value.
func (i ObjectFits) String() string { return enums.String(i, _ObjectFitsMap) }

// SetString sets the ObjectFits value from its string representation,
// and returns an error if the string is invalid.
func (i *ObjectFits) SetString(s string) error {
	return enums.SetString(i, s, _ObjectFitsValueMap, "ObjectFits")
}

// Int64 returns the ObjectFits value as an int64.
func (i ObjectFits) Int64() int64 { return int64(i) }

// SetInt64 sets the ObjectFits value from an int64.
func (i *ObjectFits) SetInt64(in int64) { *i = ObjectFits(in) }

// Desc returns the description of the ObjectFits value.
func (i ObjectFits) Desc() string { return enums.Desc(i, _ObjectFitsDescMap) }

// ObjectFitsValues returns all possible values for the type ObjectFits.
func ObjectFitsValues() []ObjectFits { return _ObjectFitsValues }

// Values returns all possible values for the type ObjectFits.
func (i ObjectFits) Values() []enums.Enum { return enums.Values(_ObjectFitsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ObjectFits) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ObjectFits) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "ObjectFits")
}

var _FillRulesValues = []FillRules{0, 1}

// FillRulesN is the highest valid value for type FillRules, plus one.
const FillRulesN FillRules = 2

var _FillRulesValueMap = map[string]FillRules{`non-zero`: 0, `even-odd`: 1}

var _FillRulesDescMap = map[FillRules]string{0: ``, 1: ``}

var _FillRulesMap = map[FillRules]string{0: `non-zero`, 1: `even-odd`}

// String returns the string representation of this FillRules value.
func (i FillRules) String() string { return enums.String(i, _FillRulesMap) }

// SetString sets the FillRules value from its string representation,
// and returns an error if the string is invalid.
func (i *FillRules) SetString(s string) error {
	return enums.SetString(i, s, _FillRulesValueMap, "FillRules")
}

// Int64 returns the FillRules value as an int64.
func (i FillRules) Int64() int64 { return int64(i) }

// SetInt64 sets the FillRules value from an int64.
func (i *FillRules) SetInt64(in int64) { *i = FillRules(in) }

// Desc returns the description of the FillRules value.
func (i FillRules) Desc() string { return enums.Desc(i, _FillRulesDescMap) }

// FillRulesValues returns all possible values for the type FillRules.
func FillRulesValues() []FillRules { return _FillRulesValues }

// Values returns all possible values for the type FillRules.
func (i FillRules) Values() []enums.Enum { return enums.Values(_FillRulesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FillRules) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FillRules) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "FillRules")
}

var _VectorEffectsValues = []VectorEffects{0, 1}

// VectorEffectsN is the highest valid value for type VectorEffects, plus one.
const VectorEffectsN VectorEffects = 2

var _VectorEffectsValueMap = map[string]VectorEffects{`none`: 0, `non-scaling-stroke`: 1}

var _VectorEffectsDescMap = map[VectorEffects]string{0: ``, 1: `VectorEffectNonScalingStroke means that the stroke width is not affected by transform properties`}

var _VectorEffectsMap = map[VectorEffects]string{0: `none`, 1: `non-scaling-stroke`}

// String returns the string representation of this VectorEffects value.
func (i VectorEffects) String() string { return enums.String(i, _VectorEffectsMap) }

// SetString sets the VectorEffects value from its string representation,
// and returns an error if the string is invalid.
func (i *VectorEffects) SetString(s string) error {
	return enums.SetString(i, s, _VectorEffectsValueMap, "VectorEffects")
}

// Int64 returns the VectorEffects value as an int64.
func (i VectorEffects) Int64() int64 { return int64(i) }

// SetInt64 sets the VectorEffects value from an int64.
func (i *VectorEffects) SetInt64(in int64) { *i = VectorEffects(in) }

// Desc returns the description of the VectorEffects value.
func (i VectorEffects) Desc() string { return enums.Desc(i, _VectorEffectsDescMap) }

// VectorEffectsValues returns all possible values for the type VectorEffects.
func VectorEffectsValues() []VectorEffects { return _VectorEffectsValues }

// Values returns all possible values for the type VectorEffects.
func (i VectorEffects) Values() []enums.Enum { return enums.Values(_VectorEffectsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i VectorEffects) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *VectorEffects) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "VectorEffects")
}

var _LineCapsValues = []LineCaps{0, 1, 2, 3, 4}

// LineCapsN is the highest valid value for type LineCaps, plus one.
const LineCapsN LineCaps = 5

var _LineCapsValueMap = map[string]LineCaps{`butt`: 0, `round`: 1, `square`: 2, `cubic`: 3, `quadratic`: 4}

var _LineCapsDescMap = map[LineCaps]string{0: `LineCapButt indicates to draw no line caps; it draws a line with the length of the specified length.`, 1: `LineCapRound indicates to draw a semicircle on each line end with a diameter of the stroke width.`, 2: `LineCapSquare indicates to draw a rectangle on each line end with a height of the stroke width and a width of half of the stroke width.`, 3: `LineCapCubic is a rasterx extension`, 4: `LineCapQuadratic is a rasterx extension`}

var _LineCapsMap = map[LineCaps]string{0: `butt`, 1: `round`, 2: `square`, 3: `cubic`, 4: `quadratic`}

// String returns the string representation of this LineCaps value.
func (i LineCaps) String() string { return enums.String(i, _LineCapsMap) }

// SetString sets the LineCaps value from its string representation,
// and returns an error if the string is invalid.
func (i *LineCaps) SetString(s string) error {
	return enums.SetString(i, s, _LineCapsValueMap, "LineCaps")
}

// Int64 returns the LineCaps value as an int64.
func (i LineCaps) Int64() int64 { return int64(i) }

// SetInt64 sets the LineCaps value from an int64.
func (i *LineCaps) SetInt64(in int64) { *i = LineCaps(in) }

// Desc returns the description of the LineCaps value.
func (i LineCaps) Desc() string { return enums.Desc(i, _LineCapsDescMap) }

// LineCapsValues returns all possible values for the type LineCaps.
func LineCapsValues() []LineCaps { return _LineCapsValues }

// Values returns all possible values for the type LineCaps.
func (i LineCaps) Values() []enums.Enum { return enums.Values(_LineCapsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i LineCaps) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *LineCaps) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "LineCaps") }

var _LineJoinsValues = []LineJoins{0, 1, 2, 3, 4, 5}

// LineJoinsN is the highest valid value for type LineJoins, plus one.
const LineJoinsN LineJoins = 6

var _LineJoinsValueMap = map[string]LineJoins{`miter`: 0, `miter-clip`: 1, `round`: 2, `bevel`: 3, `arcs`: 4, `arcs-clip`: 5}

var _LineJoinsDescMap = map[LineJoins]string{0: ``, 1: ``, 2: ``, 3: ``, 4: ``, 5: `rasterx extension`}

var _LineJoinsMap = map[LineJoins]string{0: `miter`, 1: `miter-clip`, 2: `round`, 3: `bevel`, 4: `arcs`, 5: `arcs-clip`}

// String returns the string representation of this LineJoins value.
func (i LineJoins) String() string { return enums.String(i, _LineJoinsMap) }

// SetString sets the LineJoins value from its string representation,
// and returns an error if the string is invalid.
func (i *LineJoins) SetString(s string) error {
	return enums.SetString(i, s, _LineJoinsValueMap, "LineJoins")
}

// Int64 returns the LineJoins value as an int64.
func (i LineJoins) Int64() int64 { return int64(i) }

// SetInt64 sets the LineJoins value from an int64.
func (i *LineJoins) SetInt64(in int64) { *i = LineJoins(in) }

// Desc returns the description of the LineJoins value.
func (i LineJoins) Desc() string { return enums.Desc(i, _LineJoinsDescMap) }

// LineJoinsValues returns all possible values for the type LineJoins.
func LineJoinsValues() []LineJoins { return _LineJoinsValues }

// Values returns all possible values for the type LineJoins.
func (i LineJoins) Values() []enums.Enum { return enums.Values(_LineJoinsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i LineJoins) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *LineJoins) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "LineJoins")
}

var _SideIndexesValues = []SideIndexes{0, 1, 2, 3}

// SideIndexesN is the highest valid value for type SideIndexes, plus one.
const SideIndexesN SideIndexes = 4

var _SideIndexesValueMap = map[string]SideIndexes{`Top`: 0, `Right`: 1, `Bottom`: 2, `Left`: 3}

var _SideIndexesDescMap = map[SideIndexes]string{0: ``, 1: ``, 2: ``, 3: ``}

var _SideIndexesMap = map[SideIndexes]string{0: `Top`, 1: `Right`, 2: `Bottom`, 3: `Left`}

// String returns the string representation of this SideIndexes value.
func (i SideIndexes) String() string { return enums.String(i, _SideIndexesMap) }

// SetString sets the SideIndexes value from its string representation,
// and returns an error if the string is invalid.
func (i *SideIndexes) SetString(s string) error {
	return enums.SetString(i, s, _SideIndexesValueMap, "SideIndexes")
}

// Int64 returns the SideIndexes value as an int64.
func (i SideIndexes) Int64() int64 { return int64(i) }

// SetInt64 sets the SideIndexes value from an int64.
func (i *SideIndexes) SetInt64(in int64) { *i = SideIndexes(in) }

// Desc returns the description of the SideIndexes value.
func (i SideIndexes) Desc() string { return enums.Desc(i, _SideIndexesDescMap) }

// SideIndexesValues returns all possible values for the type SideIndexes.
func SideIndexesValues() []SideIndexes { return _SideIndexesValues }

// Values returns all possible values for the type SideIndexes.
func (i SideIndexes) Values() []enums.Enum { return enums.Values(_SideIndexesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i SideIndexes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *SideIndexes) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "SideIndexes")
}

var _VirtualKeyboardsValues = []VirtualKeyboards{0, 1, 2, 3, 4, 5, 6, 7}

// VirtualKeyboardsN is the highest valid value for type VirtualKeyboards, plus one.
const VirtualKeyboardsN VirtualKeyboards = 8

var _VirtualKeyboardsValueMap = map[string]VirtualKeyboards{`none`: 0, `single-line`: 1, `multi-line`: 2, `number`: 3, `password`: 4, `email`: 5, `phone`: 6, `url`: 7}

var _VirtualKeyboardsDescMap = map[VirtualKeyboards]string{0: `KeyboardNone indicates to display no virtual keyboard.`, 1: `KeyboardSingleLine indicates to display a virtual keyboard with a default input style and a &#34;Done&#34; return key.`, 2: `KeyboardMultiLine indicates to display a virtual keyboard with a default input style and a &#34;Return&#34; return key.`, 3: `KeyboardNumber indicates to display a virtual keyboard for inputting a number.`, 4: `KeyboardPassword indicates to display a virtual keyboard for inputting a password.`, 5: `KeyboardEmail indicates to display a virtual keyboard for inputting an email address.`, 6: `KeyboardPhone indicates to display a virtual keyboard for inputting a phone number.`, 7: `KeyboardURL indicates to display a virtual keyboard for inputting a URL / URI / web address.`}

var _VirtualKeyboardsMap = map[VirtualKeyboards]string{0: `none`, 1: `single-line`, 2: `multi-line`, 3: `number`, 4: `password`, 5: `email`, 6: `phone`, 7: `url`}

// String returns the string representation of this VirtualKeyboards value.
func (i VirtualKeyboards) String() string { return enums.String(i, _VirtualKeyboardsMap) }

// SetString sets the VirtualKeyboards value from its string representation,
// and returns an error if the string is invalid.
func (i *VirtualKeyboards) SetString(s string) error {
	return enums.SetString(i, s, _VirtualKeyboardsValueMap, "VirtualKeyboards")
}

// Int64 returns the VirtualKeyboards value as an int64.
func (i VirtualKeyboards) Int64() int64 { return int64(i) }

// SetInt64 sets the VirtualKeyboards value from an int64.
func (i *VirtualKeyboards) SetInt64(in int64) { *i = VirtualKeyboards(in) }

// Desc returns the description of the VirtualKeyboards value.
func (i VirtualKeyboards) Desc() string { return enums.Desc(i, _VirtualKeyboardsDescMap) }

// VirtualKeyboardsValues returns all possible values for the type VirtualKeyboards.
func VirtualKeyboardsValues() []VirtualKeyboards { return _VirtualKeyboardsValues }

// Values returns all possible values for the type VirtualKeyboards.
func (i VirtualKeyboards) Values() []enums.Enum { return enums.Values(_VirtualKeyboardsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i VirtualKeyboards) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *VirtualKeyboards) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "VirtualKeyboards")
}

var _UnicodeBidiValues = []UnicodeBidi{0, 1, 2}

// UnicodeBidiN is the highest valid value for type UnicodeBidi, plus one.
const UnicodeBidiN UnicodeBidi = 3

var _UnicodeBidiValueMap = map[string]UnicodeBidi{`normal`: 0, `embed`: 1, `bidi-override`: 2}

var _UnicodeBidiDescMap = map[UnicodeBidi]string{0: ``, 1: ``, 2: ``}

var _UnicodeBidiMap = map[UnicodeBidi]string{0: `normal`, 1: `embed`, 2: `bidi-override`}

// String returns the string representation of this UnicodeBidi value.
func (i UnicodeBidi) String() string { return enums.String(i, _UnicodeBidiMap) }

// SetString sets the UnicodeBidi value from its string representation,
// and returns an error if the string is invalid.
func (i *UnicodeBidi) SetString(s string) error {
	return enums.SetString(i, s, _UnicodeBidiValueMap, "UnicodeBidi")
}

// Int64 returns the UnicodeBidi value as an int64.
func (i UnicodeBidi) Int64() int64 { return int64(i) }

// SetInt64 sets the UnicodeBidi value from an int64.
func (i *UnicodeBidi) SetInt64(in int64) { *i = UnicodeBidi(in) }

// Desc returns the description of the UnicodeBidi value.
func (i UnicodeBidi) Desc() string { return enums.Desc(i, _UnicodeBidiDescMap) }

// UnicodeBidiValues returns all possible values for the type UnicodeBidi.
func UnicodeBidiValues() []UnicodeBidi { return _UnicodeBidiValues }

// Values returns all possible values for the type UnicodeBidi.
func (i UnicodeBidi) Values() []enums.Enum { return enums.Values(_UnicodeBidiValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i UnicodeBidi) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *UnicodeBidi) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "UnicodeBidi")
}

var _TextDirectionsValues = []TextDirections{0, 1, 2, 3, 4, 5, 6, 7}

// TextDirectionsN is the highest valid value for type TextDirections, plus one.
const TextDirectionsN TextDirections = 8

var _TextDirectionsValueMap = map[string]TextDirections{`lrtb`: 0, `rltb`: 1, `tbrl`: 2, `lr`: 3, `rl`: 4, `tb`: 5, `ltr`: 6, `rtl`: 7}

var _TextDirectionsDescMap = map[TextDirections]string{0: ``, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: ``, 7: ``}

var _TextDirectionsMap = map[TextDirections]string{0: `lrtb`, 1: `rltb`, 2: `tbrl`, 3: `lr`, 4: `rl`, 5: `tb`, 6: `ltr`, 7: `rtl`}

// String returns the string representation of this TextDirections value.
func (i TextDirections) String() string { return enums.String(i, _TextDirectionsMap) }

// SetString sets the TextDirections value from its string representation,
// and returns an error if the string is invalid.
func (i *TextDirections) SetString(s string) error {
	return enums.SetString(i, s, _TextDirectionsValueMap, "TextDirections")
}

// Int64 returns the TextDirections value as an int64.
func (i TextDirections) Int64() int64 { return int64(i) }

// SetInt64 sets the TextDirections value from an int64.
func (i *TextDirections) SetInt64(in int64) { *i = TextDirections(in) }

// Desc returns the description of the TextDirections value.
func (i TextDirections) Desc() string { return enums.Desc(i, _TextDirectionsDescMap) }

// TextDirectionsValues returns all possible values for the type TextDirections.
func TextDirectionsValues() []TextDirections { return _TextDirectionsValues }

// Values returns all possible values for the type TextDirections.
func (i TextDirections) Values() []enums.Enum { return enums.Values(_TextDirectionsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextDirections) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextDirections) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "TextDirections")
}

var _TextAnchorsValues = []TextAnchors{0, 1, 2}

// TextAnchorsN is the highest valid value for type TextAnchors, plus one.
const TextAnchorsN TextAnchors = 3

var _TextAnchorsValueMap = map[string]TextAnchors{`start`: 0, `middle`: 1, `end`: 2}

var _TextAnchorsDescMap = map[TextAnchors]string{0: ``, 1: ``, 2: ``}

var _TextAnchorsMap = map[TextAnchors]string{0: `start`, 1: `middle`, 2: `end`}

// String returns the string representation of this TextAnchors value.
func (i TextAnchors) String() string { return enums.String(i, _TextAnchorsMap) }

// SetString sets the TextAnchors value from its string representation,
// and returns an error if the string is invalid.
func (i *TextAnchors) SetString(s string) error {
	return enums.SetString(i, s, _TextAnchorsValueMap, "TextAnchors")
}

// Int64 returns the TextAnchors value as an int64.
func (i TextAnchors) Int64() int64 { return int64(i) }

// SetInt64 sets the TextAnchors value from an int64.
func (i *TextAnchors) SetInt64(in int64) { *i = TextAnchors(in) }

// Desc returns the description of the TextAnchors value.
func (i TextAnchors) Desc() string { return enums.Desc(i, _TextAnchorsDescMap) }

// TextAnchorsValues returns all possible values for the type TextAnchors.
func TextAnchorsValues() []TextAnchors { return _TextAnchorsValues }

// Values returns all possible values for the type TextAnchors.
func (i TextAnchors) Values() []enums.Enum { return enums.Values(_TextAnchorsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextAnchors) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextAnchors) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "TextAnchors")
}

var _WhiteSpacesValues = []WhiteSpaces{0, 1, 2, 3, 4}

// WhiteSpacesN is the highest valid value for type WhiteSpaces, plus one.
const WhiteSpacesN WhiteSpaces = 5

var _WhiteSpacesValueMap = map[string]WhiteSpaces{`Normal`: 0, `Nowrap`: 1, `Pre`: 2, `PreLine`: 3, `PreWrap`: 4}

var _WhiteSpacesDescMap = map[WhiteSpaces]string{0: `WhiteSpaceNormal means that all white space is collapsed to a single space, and text wraps when necessary. To get full word wrapping to expand to all available space, you also need to set GrowWrap = 1. Use the SetTextWrap convenience method to set both.`, 1: `WhiteSpaceNowrap means that sequences of whitespace will collapse into a single whitespace. Text will never wrap to the next line except if there is an explicit line break via a &lt;br&gt; tag. In general you also don&#39;t want simple non-wrapping text labels to Grow (GrowWrap = 0). Use the SetTextWrap method to set both.`, 2: `WhiteSpacePre means that whitespace is preserved. Text will only wrap on line breaks. Acts like the &lt;pre&gt; tag in HTML. This invokes a different hand-written parser because the default Go parser automatically throws away whitespace.`, 3: `WhiteSpacePreLine means that sequences of whitespace will collapse into a single whitespace. Text will wrap when necessary, and on line breaks`, 4: `WhiteSpacePreWrap means that whitespace is preserved. Text will wrap when necessary, and on line breaks`}

var _WhiteSpacesMap = map[WhiteSpaces]string{0: `Normal`, 1: `Nowrap`, 2: `Pre`, 3: `PreLine`, 4: `PreWrap`}

// String returns the string representation of this WhiteSpaces value.
func (i WhiteSpaces) String() string { return enums.String(i, _WhiteSpacesMap) }

// SetString sets the WhiteSpaces value from its string representation,
// and returns an error if the string is invalid.
func (i *WhiteSpaces) SetString(s string) error {
	return enums.SetString(i, s, _WhiteSpacesValueMap, "WhiteSpaces")
}

// Int64 returns the WhiteSpaces value as an int64.
func (i WhiteSpaces) Int64() int64 { return int64(i) }

// SetInt64 sets the WhiteSpaces value from an int64.
func (i *WhiteSpaces) SetInt64(in int64) { *i = WhiteSpaces(in) }

// Desc returns the description of the WhiteSpaces value.
func (i WhiteSpaces) Desc() string { return enums.Desc(i, _WhiteSpacesDescMap) }

// WhiteSpacesValues returns all possible values for the type WhiteSpaces.
func WhiteSpacesValues() []WhiteSpaces { return _WhiteSpacesValues }

// Values returns all possible values for the type WhiteSpaces.
func (i WhiteSpaces) Values() []enums.Enum { return enums.Values(_WhiteSpacesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i WhiteSpaces) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *WhiteSpaces) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "WhiteSpaces")
}
