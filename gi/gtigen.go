// Code generated by "goki generate"; DO NOT EDIT.

package gi

import (
	"image/color"

	"github.com/aymerick/douceur/css"
	"goki.dev/colors"
	"goki.dev/girl/units"
	"goki.dev/goosi/events/key"
	"goki.dev/gti"
	"goki.dev/icons"
	"goki.dev/ki/v2"
	"goki.dev/mat32/v2"
	"goki.dev/ordmap"
	"goki.dev/pi/v2/complete"
)

// ButtonType is the [gti.Type] for [Button]
var ButtonType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Button",
	ShortName: "gi.Button",
	IDName:    "button",
	Doc:       "Button is a pressable button with text, an icon, an indicator, a shortcut,\nand/or a menu. The standard behavior is to register a click event with OnClick(...).",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Type", &gti.Field{Name: "Type", Type: "goki.dev/gi/v2/gi.ButtonTypes", LocalType: "ButtonTypes", Doc: "the type of button", Directives: gti.Directives{}, Tag: ""}},
		{"Text", &gti.Field{Name: "Text", Type: "string", LocalType: "string", Doc: "label for the button -- if blank then no label is presented", Directives: gti.Directives{}, Tag: "xml:\"text\""}},
		{"Icon", &gti.Field{Name: "Icon", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "optional icon for the button -- different buttons can configure this in different ways relative to the text if both are present", Directives: gti.Directives{}, Tag: "xml:\"icon\" view:\"show-name\""}},
		{"Indicator", &gti.Field{Name: "Indicator", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "name of the menu indicator icon to present, or blank or 'nil' or 'none' -- shown automatically when there are Menu elements present unless 'none' is set", Directives: gti.Directives{}, Tag: "xml:\"indicator\" view:\"show-name\""}},
		{"Shortcut", &gti.Field{Name: "Shortcut", Type: "goki.dev/goosi/events/key.Chord", LocalType: "key.Chord", Doc: "optional shortcut keyboard chord to trigger this button -- always window-wide in scope, and should generally not conflict other shortcuts (a log message will be emitted if so).  Shortcuts are processed after all other processing of keyboard input.  Use Command for Control / Meta (Mac Command key) per platform.  These are only set automatically for Menu items, NOT for items in Toolbar or buttons somewhere, but the tooltip for buttons will show the shortcut if set.", Directives: gti.Directives{}, Tag: "xml:\"shortcut\""}},
		{"Menu", &gti.Field{Name: "Menu", Type: "func(m *goki.dev/gi/v2/gi.Scene)", LocalType: "func(m *Scene)", Doc: "If non-nil, a menu constructor function used to build and display a menu whenever the button is clicked.\nThe constructor function should add buttons to the scene that it is passed.", Directives: gti.Directives{}, Tag: ""}},
		{"Data", &gti.Field{Name: "Data", Type: "any", LocalType: "any", Doc: "optional data that is sent with events to identify the button", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" view:\"-\""}},
		{"UpdateFunc", &gti.Field{Name: "UpdateFunc", Type: "func()", LocalType: "func()", Doc: "optional function that is called to update state of button (typically updating [states.Disabled]); called automatically for menus prior to showing", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Button{},
})

// NewButton adds a new [Button] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewButton(par ki.Ki, name ...string) *Button {
	return par.NewChild(ButtonType, name...).(*Button)
}

// KiType returns the [*gti.Type] of [Button]
func (t *Button) KiType() *gti.Type {
	return ButtonType
}

// New returns a new [*Button] value
func (t *Button) New() ki.Ki {
	return &Button{}
}

// ButtonEmbedder is an interface that all types that embed Button satisfy
type ButtonEmbedder interface {
	AsButton() *Button
}

// AsButton returns the given value as a value of type Button if the type
// of the given value embeds Button, or nil otherwise
func AsButton(k ki.Ki) *Button {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(ButtonEmbedder); ok {
		return t.AsButton()
	}
	return nil
}

// AsButton satisfies the [ButtonEmbedder] interface
func (t *Button) AsButton() *Button {
	return t
}

// SetType sets the [Button.Type]:
// the type of button
func (t *Button) SetType(v ButtonTypes) *Button {
	t.Type = v
	return t
}

// SetText sets the [Button.Text]:
// label for the button -- if blank then no label is presented
func (t *Button) SetText(v string) *Button {
	t.Text = v
	return t
}

// SetIcon sets the [Button.Icon]:
// optional icon for the button -- different buttons can configure this in different ways relative to the text if both are present
func (t *Button) SetIcon(v icons.Icon) *Button {
	t.Icon = v
	return t
}

// SetIndicator sets the [Button.Indicator]:
// name of the menu indicator icon to present, or blank or 'nil' or 'none' -- shown automatically when there are Menu elements present unless 'none' is set
func (t *Button) SetIndicator(v icons.Icon) *Button {
	t.Indicator = v
	return t
}

// SetShortcut sets the [Button.Shortcut]:
// optional shortcut keyboard chord to trigger this button -- always window-wide in scope, and should generally not conflict other shortcuts (a log message will be emitted if so).  Shortcuts are processed after all other processing of keyboard input.  Use Command for Control / Meta (Mac Command key) per platform.  These are only set automatically for Menu items, NOT for items in Toolbar or buttons somewhere, but the tooltip for buttons will show the shortcut if set.
func (t *Button) SetShortcut(v key.Chord) *Button {
	t.Shortcut = v
	return t
}

// SetMenu sets the [Button.Menu]:
// If non-nil, a menu constructor function used to build and display a menu whenever the button is clicked.
// The constructor function should add buttons to the scene that it is passed.
func (t *Button) SetMenu(v func(m *Scene)) *Button {
	t.Menu = v
	return t
}

// SetData sets the [Button.Data]:
// optional data that is sent with events to identify the button
func (t *Button) SetData(v any) *Button {
	t.Data = v
	return t
}

// SetUpdateFunc sets the [Button.UpdateFunc]:
// optional function that is called to update state of button (typically updating [states.Disabled]); called automatically for menus prior to showing
func (t *Button) SetUpdateFunc(v func()) *Button {
	t.UpdateFunc = v
	return t
}

// SetTooltip sets the [Button.Tooltip]
func (t *Button) SetTooltip(v string) *Button {
	t.Tooltip = v
	return t
}

// SetClass sets the [Button.Class]
func (t *Button) SetClass(v string) *Button {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Button.CustomContextMenu]
func (t *Button) SetCustomContextMenu(v func(m *Scene)) *Button {
	t.CustomContextMenu = v
	return t
}

// ChooserType is the [gti.Type] for [Chooser]
var ChooserType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Chooser",
	ShortName:  "gi.Chooser",
	IDName:     "chooser",
	Doc:        "Chooser is for selecting items from a dropdown list, with an optional\nedit TextField for typing directly.\nThe items can be of any type, including enum values -- they are converted\nto strings for the display.  If the items are of type [icons.Icon], then they\nare displayed using icons instead.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Type", &gti.Field{Name: "Type", Type: "goki.dev/gi/v2/gi.ChooserTypes", LocalType: "ChooserTypes", Doc: "the type of combo box", Directives: gti.Directives{}, Tag: ""}},
		{"Icon", &gti.Field{Name: "Icon", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "optional icon", Directives: gti.Directives{}, Tag: "view:\"show-name\""}},
		{"Indicator", &gti.Field{Name: "Indicator", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "name of the indicator icon to present.", Directives: gti.Directives{}, Tag: "view:\"show-name\""}},
		{"Editable", &gti.Field{Name: "Editable", Type: "bool", LocalType: "bool", Doc: "provide a text field for editing the value, or just a button for selecting items?  Set the editable property", Directives: gti.Directives{}, Tag: ""}},
		{"AllowNew", &gti.Field{Name: "AllowNew", Type: "bool", LocalType: "bool", Doc: "whether to allow the user to add new items to the combo box through the editable textfield (if Editable is set to true) and a button at the end of the combo box menu", Directives: gti.Directives{}, Tag: ""}},
		{"CurLabel", &gti.Field{Name: "CurLabel", Type: "string", LocalType: "string", Doc: "CurLabel is the string label for the current value", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"CurVal", &gti.Field{Name: "CurVal", Type: "any", LocalType: "any", Doc: "current selected value", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" set:\"-\""}},
		{"CurIndex", &gti.Field{Name: "CurIndex", Type: "int", LocalType: "int", Doc: "current index in list of possible items", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" set:\"-\""}},
		{"Items", &gti.Field{Name: "Items", Type: "[]any", LocalType: "[]any", Doc: "items available for selection", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"Tooltips", &gti.Field{Name: "Tooltips", Type: "[]string", LocalType: "[]string", Doc: "an optional list of tooltips displayed on hover for Chooser items; the indices for tooltips correspond to those for items", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"Placeholder", &gti.Field{Name: "Placeholder", Type: "string", LocalType: "string", Doc: "if Editable is set to true, text that is displayed in the text field when it is empty, in a lower-contrast manner", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"MaxLength", &gti.Field{Name: "MaxLength", Type: "int", LocalType: "int", Doc: "maximum label length (in runes)", Directives: gti.Directives{}, Tag: ""}},
		{"ItemsFunc", &gti.Field{Name: "ItemsFunc", Type: "func()", LocalType: "func()", Doc: "ItemsFunc, if non-nil, is a function to call before showing the items\nof the chooser, which is typically used to configure them (eg: if they\nare based on dynamic data)", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Chooser{},
})

// NewChooser adds a new [Chooser] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewChooser(par ki.Ki, name ...string) *Chooser {
	return par.NewChild(ChooserType, name...).(*Chooser)
}

// KiType returns the [*gti.Type] of [Chooser]
func (t *Chooser) KiType() *gti.Type {
	return ChooserType
}

// New returns a new [*Chooser] value
func (t *Chooser) New() ki.Ki {
	return &Chooser{}
}

// SetType sets the [Chooser.Type]:
// the type of combo box
func (t *Chooser) SetType(v ChooserTypes) *Chooser {
	t.Type = v
	return t
}

// SetIcon sets the [Chooser.Icon]:
// optional icon
func (t *Chooser) SetIcon(v icons.Icon) *Chooser {
	t.Icon = v
	return t
}

// SetIndicator sets the [Chooser.Indicator]:
// name of the indicator icon to present.
func (t *Chooser) SetIndicator(v icons.Icon) *Chooser {
	t.Indicator = v
	return t
}

// SetEditable sets the [Chooser.Editable]:
// provide a text field for editing the value, or just a button for selecting items?  Set the editable property
func (t *Chooser) SetEditable(v bool) *Chooser {
	t.Editable = v
	return t
}

// SetAllowNew sets the [Chooser.AllowNew]:
// whether to allow the user to add new items to the combo box through the editable textfield (if Editable is set to true) and a button at the end of the combo box menu
func (t *Chooser) SetAllowNew(v bool) *Chooser {
	t.AllowNew = v
	return t
}

// SetItems sets the [Chooser.Items]:
// items available for selection
func (t *Chooser) SetItems(v []any) *Chooser {
	t.Items = v
	return t
}

// SetTooltips sets the [Chooser.Tooltips]:
// an optional list of tooltips displayed on hover for Chooser items; the indices for tooltips correspond to those for items
func (t *Chooser) SetTooltips(v []string) *Chooser {
	t.Tooltips = v
	return t
}

// SetMaxLength sets the [Chooser.MaxLength]:
// maximum label length (in runes)
func (t *Chooser) SetMaxLength(v int) *Chooser {
	t.MaxLength = v
	return t
}

// SetItemsFunc sets the [Chooser.ItemsFunc]:
// ItemsFunc, if non-nil, is a function to call before showing the items
// of the chooser, which is typically used to configure them (eg: if they
// are based on dynamic data)
func (t *Chooser) SetItemsFunc(v func()) *Chooser {
	t.ItemsFunc = v
	return t
}

// SetTooltip sets the [Chooser.Tooltip]
func (t *Chooser) SetTooltip(v string) *Chooser {
	t.Tooltip = v
	return t
}

// SetClass sets the [Chooser.Class]
func (t *Chooser) SetClass(v string) *Chooser {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Chooser.CustomContextMenu]
func (t *Chooser) SetCustomContextMenu(v func(m *Scene)) *Chooser {
	t.CustomContextMenu = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Complete",
	ShortName: "gi.Complete",
	IDName:    "complete",
	Doc:       "Complete holds the current completion data and functions to call for building\nthe list of possible completions and for editing text after a completion is selected.\nIt also holds the [PopupStage] associated with it.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Stage", &gti.Field{Name: "Stage", Type: "*goki.dev/gi/v2/gi.PopupStage", LocalType: "*PopupStage", Doc: "Stage is the [PopupStage] associated with the [Complete]", Directives: gti.Directives{}, Tag: ""}},
		{"MatchFunc", &gti.Field{Name: "MatchFunc", Type: "goki.dev/pi/v2/complete.MatchFunc", LocalType: "complete.MatchFunc", Doc: "function to get the list of possible completions", Directives: gti.Directives{}, Tag: ""}},
		{"LookupFunc", &gti.Field{Name: "LookupFunc", Type: "goki.dev/pi/v2/complete.LookupFunc", LocalType: "complete.LookupFunc", Doc: "function to get the text to show for lookup", Directives: gti.Directives{}, Tag: ""}},
		{"EditFunc", &gti.Field{Name: "EditFunc", Type: "goki.dev/pi/v2/complete.EditFunc", LocalType: "complete.EditFunc", Doc: "function to edit text using the selected completion", Directives: gti.Directives{}, Tag: ""}},
		{"Context", &gti.Field{Name: "Context", Type: "any", LocalType: "any", Doc: "the object that implements complete.Func", Directives: gti.Directives{}, Tag: ""}},
		{"SrcLn", &gti.Field{Name: "SrcLn", Type: "int", LocalType: "int", Doc: "line number in source that completion is operating on, if relevant", Directives: gti.Directives{}, Tag: ""}},
		{"SrcCh", &gti.Field{Name: "SrcCh", Type: "int", LocalType: "int", Doc: "character position in source that completion is operating on", Directives: gti.Directives{}, Tag: ""}},
		{"Completions", &gti.Field{Name: "Completions", Type: "goki.dev/pi/v2/complete.Completions", LocalType: "complete.Completions", Doc: "the list of potential completions", Directives: gti.Directives{}, Tag: ""}},
		{"Seed", &gti.Field{Name: "Seed", Type: "string", LocalType: "string", Doc: "current completion seed", Directives: gti.Directives{}, Tag: ""}},
		{"Completion", &gti.Field{Name: "Completion", Type: "string", LocalType: "string", Doc: "the user's completion selection", Directives: gti.Directives{}, Tag: ""}},
		{"Listeners", &gti.Field{Name: "Listeners", Type: "goki.dev/goosi/events.Listeners", LocalType: "events.Listeners", Doc: "the event listeners for the completer (it sends Select events)", Directives: gti.Directives{}, Tag: "set:\"-\" view:\"-\""}},
		{"DelayTimer", &gti.Field{Name: "DelayTimer", Type: "*time.Timer", LocalType: "*time.Timer", Doc: "", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"DelayMu", &gti.Field{Name: "DelayMu", Type: "sync.Mutex", LocalType: "sync.Mutex", Doc: "", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"ShowMu", &gti.Field{Name: "ShowMu", Type: "sync.Mutex", LocalType: "sync.Mutex", Doc: "", Directives: gti.Directives{}, Tag: "set:\"-\""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetStage sets the [Complete.Stage]:
// Stage is the [PopupStage] associated with the [Complete]
func (t *Complete) SetStage(v *PopupStage) *Complete {
	t.Stage = v
	return t
}

// SetMatchFunc sets the [Complete.MatchFunc]:
// function to get the list of possible completions
func (t *Complete) SetMatchFunc(v complete.MatchFunc) *Complete {
	t.MatchFunc = v
	return t
}

// SetLookupFunc sets the [Complete.LookupFunc]:
// function to get the text to show for lookup
func (t *Complete) SetLookupFunc(v complete.LookupFunc) *Complete {
	t.LookupFunc = v
	return t
}

// SetEditFunc sets the [Complete.EditFunc]:
// function to edit text using the selected completion
func (t *Complete) SetEditFunc(v complete.EditFunc) *Complete {
	t.EditFunc = v
	return t
}

// SetContext sets the [Complete.Context]:
// the object that implements complete.Func
func (t *Complete) SetContext(v any) *Complete {
	t.Context = v
	return t
}

// SetSrcLn sets the [Complete.SrcLn]:
// line number in source that completion is operating on, if relevant
func (t *Complete) SetSrcLn(v int) *Complete {
	t.SrcLn = v
	return t
}

// SetSrcCh sets the [Complete.SrcCh]:
// character position in source that completion is operating on
func (t *Complete) SetSrcCh(v int) *Complete {
	t.SrcCh = v
	return t
}

// SetCompletions sets the [Complete.Completions]:
// the list of potential completions
func (t *Complete) SetCompletions(v complete.Completions) *Complete {
	t.Completions = v
	return t
}

// SetSeed sets the [Complete.Seed]:
// current completion seed
func (t *Complete) SetSeed(v string) *Complete {
	t.Seed = v
	return t
}

// SetCompletion sets the [Complete.Completion]:
// the user's completion selection
func (t *Complete) SetCompletion(v string) *Complete {
	t.Completion = v
	return t
}

// StyleSheetType is the [gti.Type] for [StyleSheet]
var StyleSheetType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.StyleSheet",
	ShortName:  "gi.StyleSheet",
	IDName:     "style-sheet",
	Doc:        "StyleSheet is a Widget node that contains a stylesheet -- property values\ncontained in this sheet can be transformed into ki.Props and set in CSS\nfield of appropriate node",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Sheet", &gti.Field{Name: "Sheet", Type: "*github.com/aymerick/douceur/css.Stylesheet", LocalType: "*css.Stylesheet", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &StyleSheet{},
})

// NewStyleSheet adds a new [StyleSheet] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewStyleSheet(par ki.Ki, name ...string) *StyleSheet {
	return par.NewChild(StyleSheetType, name...).(*StyleSheet)
}

// KiType returns the [*gti.Type] of [StyleSheet]
func (t *StyleSheet) KiType() *gti.Type {
	return StyleSheetType
}

// New returns a new [*StyleSheet] value
func (t *StyleSheet) New() ki.Ki {
	return &StyleSheet{}
}

// SetSheet sets the [StyleSheet.Sheet]
func (t *StyleSheet) SetSheet(v *css.Stylesheet) *StyleSheet {
	t.Sheet = v
	return t
}

// SetTooltip sets the [StyleSheet.Tooltip]
func (t *StyleSheet) SetTooltip(v string) *StyleSheet {
	t.Tooltip = v
	return t
}

// SetClass sets the [StyleSheet.Class]
func (t *StyleSheet) SetClass(v string) *StyleSheet {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [StyleSheet.CustomContextMenu]
func (t *StyleSheet) SetCustomContextMenu(v func(m *Scene)) *StyleSheet {
	t.CustomContextMenu = v
	return t
}

// DialogType is the [gti.Type] for [Dialog]
var DialogType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Dialog",
	ShortName: "gi.Dialog",
	IDName:    "dialog",
	Doc:       "Dialog is a scene with methods for configuring a dialog",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "no-new", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Stage", &gti.Field{Name: "Stage", Type: "*goki.dev/gi/v2/gi.MainStage", LocalType: "*MainStage", Doc: "Stage is the main stage associated with the dialog", Directives: gti.Directives{}, Tag: ""}},
		{"Accepted", &gti.Field{Name: "Accepted", Type: "bool", LocalType: "bool", Doc: "Accepted means that the dialog was accepted -- else canceled", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Btns", &gti.Field{Name: "Btns", Type: "*goki.dev/gi/v2/gi.Layout", LocalType: "*Layout", Doc: "Buttons go here when added", Directives: gti.Directives{}, Tag: "set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Scene", &gti.Field{Name: "Scene", Type: "goki.dev/gi/v2/gi.Scene", LocalType: "Scene", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Dialog{},
})

// KiType returns the [*gti.Type] of [Dialog]
func (t *Dialog) KiType() *gti.Type {
	return DialogType
}

// New returns a new [*Dialog] value
func (t *Dialog) New() ki.Ki {
	return &Dialog{}
}

// SetStage sets the [Dialog.Stage]:
// Stage is the main stage associated with the dialog
func (t *Dialog) SetStage(v *MainStage) *Dialog {
	t.Stage = v
	return t
}

// SetTooltip sets the [Dialog.Tooltip]
func (t *Dialog) SetTooltip(v string) *Dialog {
	t.Tooltip = v
	return t
}

// SetClass sets the [Dialog.Class]
func (t *Dialog) SetClass(v string) *Dialog {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Dialog.CustomContextMenu]
func (t *Dialog) SetCustomContextMenu(v func(m *Scene)) *Dialog {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [Dialog.Lay]
func (t *Dialog) SetLayout(v Layouts) *Dialog {
	t.Lay = v
	return t
}

// SetStackTop sets the [Dialog.StackTop]
func (t *Dialog) SetStackTop(v int) *Dialog {
	t.StackTop = v
	return t
}

// SetStripes sets the [Dialog.Stripes]
func (t *Dialog) SetStripes(v Stripes) *Dialog {
	t.Stripes = v
	return t
}

// SetData sets the [Dialog.Data]
func (t *Dialog) SetData(v any) *Dialog {
	t.Data = v
	return t
}

// SetTopAppBar sets the [Dialog.TopAppBar]
func (t *Dialog) SetTopAppBar(v func(tb *Toolbar)) *Dialog {
	t.TopAppBar = v
	return t
}

// SetBgColor sets the [Dialog.BgColor]
func (t *Dialog) SetBgColor(v colors.Full) *Dialog {
	t.BgColor = v
	return t
}

// FrameType is the [gti.Type] for [Frame]
var FrameType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Frame",
	ShortName:  "gi.Frame",
	IDName:     "frame",
	Doc:        "Frame is a Layout that renders a background according to the\nbackground-color style setting, and optional striping for grid layouts",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Stripes", &gti.Field{Name: "Stripes", Type: "goki.dev/gi/v2/gi.Stripes", LocalType: "Stripes", Doc: "options for striped backgrounds -- rendered as darker bands relative to background color", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "goki.dev/gi/v2/gi.Layout", LocalType: "Layout", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Frame{},
})

// NewFrame adds a new [Frame] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewFrame(par ki.Ki, name ...string) *Frame {
	return par.NewChild(FrameType, name...).(*Frame)
}

// KiType returns the [*gti.Type] of [Frame]
func (t *Frame) KiType() *gti.Type {
	return FrameType
}

// New returns a new [*Frame] value
func (t *Frame) New() ki.Ki {
	return &Frame{}
}

// SetStripes sets the [Frame.Stripes]:
// options for striped backgrounds -- rendered as darker bands relative to background color
func (t *Frame) SetStripes(v Stripes) *Frame {
	t.Stripes = v
	return t
}

// SetTooltip sets the [Frame.Tooltip]
func (t *Frame) SetTooltip(v string) *Frame {
	t.Tooltip = v
	return t
}

// SetClass sets the [Frame.Class]
func (t *Frame) SetClass(v string) *Frame {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Frame.CustomContextMenu]
func (t *Frame) SetCustomContextMenu(v func(m *Scene)) *Frame {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [Frame.Lay]
func (t *Frame) SetLayout(v Layouts) *Frame {
	t.Lay = v
	return t
}

// SetStackTop sets the [Frame.StackTop]
func (t *Frame) SetStackTop(v int) *Frame {
	t.StackTop = v
	return t
}

// HandleType is the [gti.Type] for [Handle]
var HandleType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Handle",
	ShortName:  "gi.Handle",
	IDName:     "handle",
	Doc:        "Handle represents a draggable handle that can be\nused to control the size of an element.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Dim", &gti.Field{Name: "Dim", Type: "goki.dev/mat32/v2.Dims", LocalType: "mat32.Dims", Doc: "dimension along which the handle slides (opposite of the dimension it is longest on)", Directives: gti.Directives{}, Tag: ""}},
		{"Min", &gti.Field{Name: "Min", Type: "float32", LocalType: "float32", Doc: "Min is the minimum value that the handle can go to\n(typically the lower bound of the dialog/splits)", Directives: gti.Directives{}, Tag: ""}},
		{"Max", &gti.Field{Name: "Max", Type: "float32", LocalType: "float32", Doc: "Max is the maximum value that the handle can go to\n(typically the upper bound of the dialog/splits)", Directives: gti.Directives{}, Tag: ""}},
		{"Pos", &gti.Field{Name: "Pos", Type: "float32", LocalType: "float32", Doc: "Pos is the current position of the handle on the\nscale of [Handle.Min] to [Handle.Max]", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "goki.dev/gi/v2/gi.Frame", LocalType: "Frame", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Handle{},
})

// NewHandle adds a new [Handle] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewHandle(par ki.Ki, name ...string) *Handle {
	return par.NewChild(HandleType, name...).(*Handle)
}

// KiType returns the [*gti.Type] of [Handle]
func (t *Handle) KiType() *gti.Type {
	return HandleType
}

// New returns a new [*Handle] value
func (t *Handle) New() ki.Ki {
	return &Handle{}
}

// SetDim sets the [Handle.Dim]:
// dimension along which the handle slides (opposite of the dimension it is longest on)
func (t *Handle) SetDim(v mat32.Dims) *Handle {
	t.Dim = v
	return t
}

// SetMin sets the [Handle.Min]:
// Min is the minimum value that the handle can go to
// (typically the lower bound of the dialog/splits)
func (t *Handle) SetMin(v float32) *Handle {
	t.Min = v
	return t
}

// SetMax sets the [Handle.Max]:
// Max is the maximum value that the handle can go to
// (typically the upper bound of the dialog/splits)
func (t *Handle) SetMax(v float32) *Handle {
	t.Max = v
	return t
}

// SetPos sets the [Handle.Pos]:
// Pos is the current position of the handle on the
// scale of [Handle.Min] to [Handle.Max]
func (t *Handle) SetPos(v float32) *Handle {
	t.Pos = v
	return t
}

// SetTooltip sets the [Handle.Tooltip]
func (t *Handle) SetTooltip(v string) *Handle {
	t.Tooltip = v
	return t
}

// SetClass sets the [Handle.Class]
func (t *Handle) SetClass(v string) *Handle {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Handle.CustomContextMenu]
func (t *Handle) SetCustomContextMenu(v func(m *Scene)) *Handle {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [Handle.Lay]
func (t *Handle) SetLayout(v Layouts) *Handle {
	t.Lay = v
	return t
}

// SetStackTop sets the [Handle.StackTop]
func (t *Handle) SetStackTop(v int) *Handle {
	t.StackTop = v
	return t
}

// SetStripes sets the [Handle.Stripes]
func (t *Handle) SetStripes(v Stripes) *Handle {
	t.Stripes = v
	return t
}

// IconType is the [gti.Type] for [Icon]
var IconType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Icon",
	ShortName:  "gi.Icon",
	IDName:     "icon",
	Doc:        "Icon contains a svg.SVG element.\nThe rendered version is cached for a given size.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"IconName", &gti.Field{Name: "IconName", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "icon name that has been set.", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Filename", &gti.Field{Name: "Filename", Type: "string", LocalType: "string", Doc: "file name for the loaded icon, if loaded", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"SVG", &gti.Field{Name: "SVG", Type: "goki.dev/svg.SVG", LocalType: "svg.SVG", Doc: "SVG drawing", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"RendSize", &gti.Field{Name: "RendSize", Type: "image.Point", LocalType: "image.Point", Doc: "RendSize is the last rendered size of the Icon SVG.\nif the SVG.Name == IconName and this size is the same\nthen the current SVG image is used.", Directives: gti.Directives{}, Tag: "set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Icon{},
})

// NewIcon adds a new [Icon] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewIcon(par ki.Ki, name ...string) *Icon {
	return par.NewChild(IconType, name...).(*Icon)
}

// KiType returns the [*gti.Type] of [Icon]
func (t *Icon) KiType() *gti.Type {
	return IconType
}

// New returns a new [*Icon] value
func (t *Icon) New() ki.Ki {
	return &Icon{}
}

// SetTooltip sets the [Icon.Tooltip]
func (t *Icon) SetTooltip(v string) *Icon {
	t.Tooltip = v
	return t
}

// SetClass sets the [Icon.Class]
func (t *Icon) SetClass(v string) *Icon {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Icon.CustomContextMenu]
func (t *Icon) SetCustomContextMenu(v func(m *Scene)) *Icon {
	t.CustomContextMenu = v
	return t
}

// ImageType is the [gti.Type] for [Image]
var ImageType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Image",
	ShortName:  "gi.Image",
	IDName:     "image",
	Doc:        "Image is a Widget that is optimized to render a static bitmap image --\nit expects to be a terminal node and does NOT call rendering etc on its\nchildren.  It is particularly useful for overlays in drag-n-drop uses --\ncan grab the image of another vp and show that",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Filename", &gti.Field{Name: "Filename", Type: "goki.dev/gi/v2/gi.FileName", LocalType: "FileName", Doc: "file name of image loaded -- set by OpenImage", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Size", &gti.Field{Name: "Size", Type: "image.Point", LocalType: "image.Point", Doc: "size of the image", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Pixels", &gti.Field{Name: "Pixels", Type: "*image.RGBA", LocalType: "*image.RGBA", Doc: "the bitmap image", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" xml:\"-\" json:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Image{},
})

// NewImage adds a new [Image] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewImage(par ki.Ki, name ...string) *Image {
	return par.NewChild(ImageType, name...).(*Image)
}

// KiType returns the [*gti.Type] of [Image]
func (t *Image) KiType() *gti.Type {
	return ImageType
}

// New returns a new [*Image] value
func (t *Image) New() ki.Ki {
	return &Image{}
}

// SetTooltip sets the [Image.Tooltip]
func (t *Image) SetTooltip(v string) *Image {
	t.Tooltip = v
	return t
}

// SetClass sets the [Image.Class]
func (t *Image) SetClass(v string) *Image {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Image.CustomContextMenu]
func (t *Image) SetCustomContextMenu(v func(m *Scene)) *Image {
	t.CustomContextMenu = v
	return t
}

// LabelType is the [gti.Type] for [Label]
var LabelType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Label",
	ShortName: "gi.Label",
	IDName:    "label",
	Doc:       "Label is a widget for rendering text labels -- supports full widget model\nincluding box rendering, and full HTML styling, including links -- LinkSig\nemits link with data of URL -- opens default browser if nobody receiving\nsignal.  The default white-space option is 'pre' -- set to 'normal' or\nother options to get word-wrapping etc.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Text", &gti.Field{Name: "Text", Type: "string", LocalType: "string", Doc: "label to display", Directives: gti.Directives{}, Tag: "xml:\"text\""}},
		{"Type", &gti.Field{Name: "Type", Type: "goki.dev/gi/v2/gi.LabelTypes", LocalType: "LabelTypes", Doc: "the type of label", Directives: gti.Directives{}, Tag: ""}},
		{"TextRender", &gti.Field{Name: "TextRender", Type: "goki.dev/girl/paint.Text", LocalType: "paint.Text", Doc: "render data for text label", Directives: gti.Directives{}, Tag: "copy:\"-\" xml:\"-\" json:\"-\" set:\"-\""}},
		{"RenderPos", &gti.Field{Name: "RenderPos", Type: "goki.dev/mat32/v2.Vec2", LocalType: "mat32.Vec2", Doc: "position offset of start of text rendering, from last render -- AllocPos plus alignment factors for center, right etc.", Directives: gti.Directives{}, Tag: "copy:\"-\" xml:\"-\" json:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Label{},
})

// NewLabel adds a new [Label] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewLabel(par ki.Ki, name ...string) *Label {
	return par.NewChild(LabelType, name...).(*Label)
}

// KiType returns the [*gti.Type] of [Label]
func (t *Label) KiType() *gti.Type {
	return LabelType
}

// New returns a new [*Label] value
func (t *Label) New() ki.Ki {
	return &Label{}
}

// LabelEmbedder is an interface that all types that embed Label satisfy
type LabelEmbedder interface {
	AsLabel() *Label
}

// AsLabel returns the given value as a value of type Label if the type
// of the given value embeds Label, or nil otherwise
func AsLabel(k ki.Ki) *Label {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(LabelEmbedder); ok {
		return t.AsLabel()
	}
	return nil
}

// AsLabel satisfies the [LabelEmbedder] interface
func (t *Label) AsLabel() *Label {
	return t
}

// SetText sets the [Label.Text]:
// label to display
func (t *Label) SetText(v string) *Label {
	t.Text = v
	return t
}

// SetType sets the [Label.Type]:
// the type of label
func (t *Label) SetType(v LabelTypes) *Label {
	t.Type = v
	return t
}

// SetTooltip sets the [Label.Tooltip]
func (t *Label) SetTooltip(v string) *Label {
	t.Tooltip = v
	return t
}

// SetClass sets the [Label.Class]
func (t *Label) SetClass(v string) *Label {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Label.CustomContextMenu]
func (t *Label) SetCustomContextMenu(v func(m *Scene)) *Label {
	t.CustomContextMenu = v
	return t
}

// LayoutType is the [gti.Type] for [Layout]
var LayoutType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Layout",
	ShortName:  "gi.Layout",
	IDName:     "layout",
	Doc:        "Layout is the primary node type responsible for organizing the sizes\nand positions of child widgets. It does not render, only organize,\nso properties like background color will have no effect.\nAll arbitrary collections of widgets should generally be contained\nwithin a layout -- otherwise the parent widget must take over\nresponsibility for positioning.\nThe alignment is NOT inherited by default so must be specified per\nchild, except that the parent alignment is used within the relevant\ndimension (e.g., horizontal-align for a LayoutHoriz layout,\nto determine left, right, center, justified).\nLayouts can automatically add scrollbars depending on the Overflow\nlayout style.\nFor a Grid layout, the 'columns' property should generally be set\nto the desired number of columns, from which the number of rows\nis computed -- otherwise it uses the square root of number of\nelements.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Lay", &gti.Field{Name: "Lay", Type: "goki.dev/gi/v2/gi.Layouts", LocalType: "Layouts", Doc: "type of layout to use", Directives: gti.Directives{}, Tag: "xml:\"lay\" set:\"Layout\""}},
		{"StackTop", &gti.Field{Name: "StackTop", Type: "int", LocalType: "int", Doc: "for Stacked layout, index of node to use as the top of the stack -- only node at this index is rendered -- if not a valid index, nothing is rendered", Directives: gti.Directives{}, Tag: ""}},
		{"ChildSize", &gti.Field{Name: "ChildSize", Type: "goki.dev/mat32/v2.Vec2", LocalType: "mat32.Vec2", Doc: "total max size of children as laid out", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"ExtraSize", &gti.Field{Name: "ExtraSize", Type: "goki.dev/mat32/v2.Vec2", LocalType: "mat32.Vec2", Doc: "extra size in each dim due to scrollbars we add", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"HasScroll", &gti.Field{Name: "HasScroll", Type: "[2]bool", LocalType: "[2]bool", Doc: "whether scrollbar is used for given dim", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"Scrolls", &gti.Field{Name: "Scrolls", Type: "[2]*goki.dev/gi/v2/gi.Slider", LocalType: "[2]*Slider", Doc: "scroll bars -- we fully manage them as needed", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"GridSize", &gti.Field{Name: "GridSize", Type: "image.Point", LocalType: "image.Point", Doc: "computed size of a grid layout based on all the constraints -- computed during GetSize pass", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"GridData", &gti.Field{Name: "GridData", Type: "[2][]goki.dev/gi/v2/gi.GridData", LocalType: "[RowColN][]GridData", Doc: "grid data for rows in and cols in", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"FlowBreaks", &gti.Field{Name: "FlowBreaks", Type: "[]int", LocalType: "[]int", Doc: "line breaks for flow layout", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"FocusName", &gti.Field{Name: "FocusName", Type: "string", LocalType: "string", Doc: "accumulated name to search for when keys are typed", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"FocusNameTime", &gti.Field{Name: "FocusNameTime", Type: "time.Time", LocalType: "time.Time", Doc: "time of last focus name event -- for timeout", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"FocusNameLast", &gti.Field{Name: "FocusNameLast", Type: "goki.dev/ki/v2.Ki", LocalType: "ki.Ki", Doc: "last element focused on -- used as a starting point if name is the same", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Layout{},
})

// NewLayout adds a new [Layout] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewLayout(par ki.Ki, name ...string) *Layout {
	return par.NewChild(LayoutType, name...).(*Layout)
}

// KiType returns the [*gti.Type] of [Layout]
func (t *Layout) KiType() *gti.Type {
	return LayoutType
}

// New returns a new [*Layout] value
func (t *Layout) New() ki.Ki {
	return &Layout{}
}

// SetLayout sets the [Layout.Lay]:
// type of layout to use
func (t *Layout) SetLayout(v Layouts) *Layout {
	t.Lay = v
	return t
}

// SetStackTop sets the [Layout.StackTop]:
// for Stacked layout, index of node to use as the top of the stack -- only node at this index is rendered -- if not a valid index, nothing is rendered
func (t *Layout) SetStackTop(v int) *Layout {
	t.StackTop = v
	return t
}

// SetTooltip sets the [Layout.Tooltip]
func (t *Layout) SetTooltip(v string) *Layout {
	t.Tooltip = v
	return t
}

// SetClass sets the [Layout.Class]
func (t *Layout) SetClass(v string) *Layout {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Layout.CustomContextMenu]
func (t *Layout) SetCustomContextMenu(v func(m *Scene)) *Layout {
	t.CustomContextMenu = v
	return t
}

// StretchType is the [gti.Type] for [Stretch]
var StretchType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Stretch",
	ShortName:  "gi.Stretch",
	IDName:     "stretch",
	Doc:        "Stretch adds an infinitely stretchy element for spacing out layouts\n(max-size = -1) set the width / height property to determine how much it\ntakes relative to other stretchy elements",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Stretch{},
})

// NewStretch adds a new [Stretch] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewStretch(par ki.Ki, name ...string) *Stretch {
	return par.NewChild(StretchType, name...).(*Stretch)
}

// KiType returns the [*gti.Type] of [Stretch]
func (t *Stretch) KiType() *gti.Type {
	return StretchType
}

// New returns a new [*Stretch] value
func (t *Stretch) New() ki.Ki {
	return &Stretch{}
}

// SetTooltip sets the [Stretch.Tooltip]
func (t *Stretch) SetTooltip(v string) *Stretch {
	t.Tooltip = v
	return t
}

// SetClass sets the [Stretch.Class]
func (t *Stretch) SetClass(v string) *Stretch {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Stretch.CustomContextMenu]
func (t *Stretch) SetCustomContextMenu(v func(m *Scene)) *Stretch {
	t.CustomContextMenu = v
	return t
}

// SpaceType is the [gti.Type] for [Space]
var SpaceType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Space",
	ShortName:  "gi.Space",
	IDName:     "space",
	Doc:        "Space adds a fixed sized (1 ch x 1 em by default) blank space to a layout -- set\nwidth / height property to change",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Space{},
})

// NewSpace adds a new [Space] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSpace(par ki.Ki, name ...string) *Space {
	return par.NewChild(SpaceType, name...).(*Space)
}

// KiType returns the [*gti.Type] of [Space]
func (t *Space) KiType() *gti.Type {
	return SpaceType
}

// New returns a new [*Space] value
func (t *Space) New() ki.Ki {
	return &Space{}
}

// SetTooltip sets the [Space.Tooltip]
func (t *Space) SetTooltip(v string) *Space {
	t.Tooltip = v
	return t
}

// SetClass sets the [Space.Class]
func (t *Space) SetClass(v string) *Space {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Space.CustomContextMenu]
func (t *Space) SetCustomContextMenu(v func(m *Scene)) *Space {
	t.CustomContextMenu = v
	return t
}

// MenuBarType is the [gti.Type] for [MenuBar]
var MenuBarType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.MenuBar",
	ShortName:  "gi.MenuBar",
	IDName:     "menu-bar",
	Doc:        "MenuBar is a Layout (typically LayoutHoriz) that renders a gradient\nbackground and has convenience methods for adding menus.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MainMenu", &gti.Field{Name: "MainMenu", Type: "bool", LocalType: "bool", Doc: "is this the main menu bar for a window?  controls whether displayed on macOS", Directives: gti.Directives{}, Tag: ""}},
		{"OSMainMenus", &gti.Field{Name: "OSMainMenus", Type: "map[string]*goki.dev/gi/v2/gi.Button", LocalType: "map[string]*Button", Doc: "map of main menu items for callback from OS main menu (MacOS specific)", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "goki.dev/gi/v2/gi.Layout", LocalType: "Layout", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &MenuBar{},
})

// NewMenuBar adds a new [MenuBar] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewMenuBar(par ki.Ki, name ...string) *MenuBar {
	return par.NewChild(MenuBarType, name...).(*MenuBar)
}

// KiType returns the [*gti.Type] of [MenuBar]
func (t *MenuBar) KiType() *gti.Type {
	return MenuBarType
}

// New returns a new [*MenuBar] value
func (t *MenuBar) New() ki.Ki {
	return &MenuBar{}
}

// SetMainMenu sets the [MenuBar.MainMenu]:
// is this the main menu bar for a window?  controls whether displayed on macOS
func (t *MenuBar) SetMainMenu(v bool) *MenuBar {
	t.MainMenu = v
	return t
}

// SetTooltip sets the [MenuBar.Tooltip]
func (t *MenuBar) SetTooltip(v string) *MenuBar {
	t.Tooltip = v
	return t
}

// SetClass sets the [MenuBar.Class]
func (t *MenuBar) SetClass(v string) *MenuBar {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [MenuBar.CustomContextMenu]
func (t *MenuBar) SetCustomContextMenu(v func(m *Scene)) *MenuBar {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [MenuBar.Lay]
func (t *MenuBar) SetLayout(v Layouts) *MenuBar {
	t.Lay = v
	return t
}

// SetStackTop sets the [MenuBar.StackTop]
func (t *MenuBar) SetStackTop(v int) *MenuBar {
	t.StackTop = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Preferences",
	ShortName: "gi.Preferences",
	IDName:    "preferences",
	Doc:       "Preferences are the overall user preferences for GoGi, providing some basic\ncustomization -- in addition, most gui settings can be styled using\nCSS-style sheets under CustomStyle.  These prefs are saved and loaded from\nthe GoGi user preferences directory -- see oswin/App for further info.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Theme", &gti.Field{Name: "Theme", Type: "goki.dev/gi/v2/gi.Themes", LocalType: "Themes", Doc: "the color theme", Directives: gti.Directives{}, Tag: ""}},
		{"Color", &gti.Field{Name: "Color", Type: "image/color.RGBA", LocalType: "color.RGBA", Doc: "the primary color used to generate the color scheme", Directives: gti.Directives{}, Tag: ""}},
		{"Zoom", &gti.Field{Name: "Zoom", Type: "float32", LocalType: "float32", Doc: "overall zoom factor as a percentage of the default zoom", Directives: gti.Directives{}, Tag: "def:\"100\" min:\"10\" max:\"1000\" step:\"10\""}},
		{"Density", &gti.Field{Name: "Density", Type: "goki.dev/gi/v2/gi.Densities", LocalType: "Densities", Doc: "the density (compactness) of content", Directives: gti.Directives{}, Tag: ""}},
		{"ScreenPrefs", &gti.Field{Name: "ScreenPrefs", Type: "map[string]goki.dev/gi/v2/gi.ScreenPrefs", LocalType: "map[string]ScreenPrefs", Doc: "screen-specific preferences -- will override overall defaults if set", Directives: gti.Directives{}, Tag: ""}},
		{"HiStyle", &gti.Field{Name: "HiStyle", Type: "goki.dev/gi/v2/gi.HiStyleName", LocalType: "HiStyleName", Doc: "text highlighting style / theme", Directives: gti.Directives{}, Tag: ""}},
		{"Params", &gti.Field{Name: "Params", Type: "goki.dev/gi/v2/gi.ParamPrefs", LocalType: "ParamPrefs", Doc: "parameters controlling GUI behavior", Directives: gti.Directives{}, Tag: ""}},
		{"Editor", &gti.Field{Name: "Editor", Type: "goki.dev/gi/v2/gi.EditorPrefs", LocalType: "EditorPrefs", Doc: "editor preferences -- for TextView etc", Directives: gti.Directives{}, Tag: ""}},
		{"KeyMap", &gti.Field{Name: "KeyMap", Type: "goki.dev/gi/v2/keyfun.MapName", LocalType: "keyfun.MapName", Doc: "select the active keymap from list of available keymaps -- see Edit KeyMaps for editing / saving / loading that list", Directives: gti.Directives{}, Tag: ""}},
		{"SaveKeyMaps", &gti.Field{Name: "SaveKeyMaps", Type: "bool", LocalType: "bool", Doc: "if set, the current available set of key maps is saved to your preferences directory, and automatically loaded at startup -- this should be set if you are using custom key maps, but it may be safer to keep it <i>OFF</i> if you are <i>not</i> using custom key maps, so that you'll always have the latest compiled-in standard key maps with all the current key functions bound to standard key chords", Directives: gti.Directives{}, Tag: ""}},
		{"SaveDetailed", &gti.Field{Name: "SaveDetailed", Type: "bool", LocalType: "bool", Doc: "if set, the detailed preferences are saved and loaded at startup -- only", Directives: gti.Directives{}, Tag: ""}},
		{"CustomStyles", &gti.Field{Name: "CustomStyles", Type: "goki.dev/ki/v2.Props", LocalType: "ki.Props", Doc: "a custom style sheet -- add a separate Props entry for each type of object, e.g., button, or class using .classname, or specific named element using #name -- all are case insensitive", Directives: gti.Directives{}, Tag: ""}},
		{"CustomStylesOverride", &gti.Field{Name: "CustomStylesOverride", Type: "bool", LocalType: "bool", Doc: "if true my custom styles override other styling (i.e., they come <i>last</i> in styling process -- otherwise they provide defaults that can be overridden by app-specific styling (i.e, they come first).", Directives: gti.Directives{}, Tag: ""}},
		{"FontFamily", &gti.Field{Name: "FontFamily", Type: "goki.dev/gi/v2/gi.FontName", LocalType: "FontName", Doc: "default font family when otherwise not specified", Directives: gti.Directives{}, Tag: ""}},
		{"MonoFont", &gti.Field{Name: "MonoFont", Type: "goki.dev/gi/v2/gi.FontName", LocalType: "FontName", Doc: "default mono-spaced font family", Directives: gti.Directives{}, Tag: ""}},
		{"FontPaths", &gti.Field{Name: "FontPaths", Type: "[]string", LocalType: "[]string", Doc: "extra font paths, beyond system defaults -- searched first", Directives: gti.Directives{}, Tag: ""}},
		{"User", &gti.Field{Name: "User", Type: "goki.dev/gi/v2/gi.User", LocalType: "User", Doc: "user info -- partially filled-out automatically if empty / when prefs first created", Directives: gti.Directives{}, Tag: ""}},
		{"FavPaths", &gti.Field{Name: "FavPaths", Type: "goki.dev/gi/v2/gi.FavPaths", LocalType: "FavPaths", Doc: "favorite paths, shown in FileViewer and also editable there", Directives: gti.Directives{}, Tag: ""}},
		{"FileViewSort", &gti.Field{Name: "FileViewSort", Type: "string", LocalType: "string", Doc: "column to sort by in FileView, and :up or :down for direction -- updated automatically via FileView", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"ColorFilename", &gti.Field{Name: "ColorFilename", Type: "goki.dev/gi/v2/gi.FileName", LocalType: "FileName", Doc: "filename for saving / loading colors", Directives: gti.Directives{}, Tag: "view:\"-\" ext:\".json\""}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", LocalType: "bool", Doc: "flag that is set by StructView by virtue of changeflag tag, whenever an edit is made.  Used to drive save menus etc.", Directives: gti.Directives{}, Tag: "view:\"-\" changeflag:\"+\" json:\"-\" xml:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{
		{"UpdateAll", &gti.Method{Name: "UpdateAll", Doc: "UpdateAll updates all open windows with current preferences -- triggers\nrebuild of default styles.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"Open", &gti.Method{Name: "Open", Doc: "Open preferences from GoGi standard prefs directory", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"error", &gti.Field{Name: "error", Type: "error", LocalType: "error", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
		{"Save", &gti.Method{Name: "Save", Doc: "Save saves the preferences to the GoGi standard prefs directory", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"error", &gti.Field{Name: "error", Type: "error", LocalType: "error", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
		{"Delete", &gti.Method{Name: "Delete", Doc: "Delete deletes the preferences from the GoGi standard prefs directory.\nThis is an unrecoverable action, and you should only do this if you\nare absolutely sure you want to. You may want to consider making a copy\nof your preferences through \"Save as\" before doing this.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"error", &gti.Field{Name: "error", Type: "error", LocalType: "error", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
		{"LightMode", &gti.Method{Name: "LightMode", Doc: "LightMode sets the color theme to light mode. It automatically\nsaves the preferences and updates all of the windows.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"DarkMode", &gti.Method{Name: "DarkMode", Doc: "DarkMode sets the color theme to dark mode. It automatically\nsaves the preferences and updates all of the windows.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"SaveZoom", &gti.Method{Name: "SaveZoom", Doc: "SaveZoom saves the current LogicalDPI scaling, either as the overall\ndefault or specific to the current screen.\n  - forCurrentScreen: if true, saves only for current screen", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"forCurrentScreen", &gti.Field{Name: "forCurrentScreen", Type: "bool", LocalType: "bool", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"ScreenInfo", &gti.Method{Name: "ScreenInfo", Doc: "ScreenInfo returns screen info for all screens on the device", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"Screen", &gti.Field{Name: "Screen", Type: "[]*goki.dev/goosi.Screen", LocalType: "[]*goosi.Screen", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
		{"VersionInfo", &gti.Method{Name: "VersionInfo", Doc: "VersionInfo returns GoGi version information", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"string", &gti.Field{Name: "string", Type: "string", LocalType: "string", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
		{"DeleteSavedWindowGeoms", &gti.Method{Name: "DeleteSavedWindowGeoms", Doc: "DeleteSavedWindowGeoms deletes the file that saves the position and size of\neach window, by screen, and clear current in-memory cache. You shouldn't generally\nneed to do this, but sometimes it is useful for testing or windows that are\nshowing up in bad places that you can't recover from.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"EditKeyMaps", &gti.Method{Name: "EditKeyMaps", Doc: "EditKeyMaps opens the KeyMapsView editor to create new keymaps / save /\nload from other files, etc.  Current avail keymaps are saved and loaded\nwith preferences automatically.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"EditHiStyles", &gti.Method{Name: "EditHiStyles", Doc: "EditHiStyles opens the HiStyleView editor to customize highlighting styles", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"EditDetailed", &gti.Method{Name: "EditDetailed", Doc: "EditDetailed opens the PrefsDetView editor to edit detailed\nparams that are not typically user-modified, but can be if you\nreally care. Turns on the SaveDetailed flag so these will be\nsaved and loaded automatically; you can toggle that back off\nif you don't actually want to.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"EditDebug", &gti.Method{Name: "EditDebug", Doc: "EditDebug opens the PrefsDbgView editor to control debugging\nparameters. These are not saved; they are only set dynamically\nduring running.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
	}),
})

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.ScreenPrefs",
	ShortName: "gi.ScreenPrefs",
	IDName:    "screen-prefs",
	Doc:       "ScreenPrefs are the per-screen preferences -- see oswin/App/Screen() for\ninfo on the different screens -- these prefs are indexed by the Screen.Name\n-- settings here override those in the global preferences.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Zoom", &gti.Field{Name: "Zoom", Type: "float32", LocalType: "float32", Doc: "overall zoom factor as a percentage of the default zoom", Directives: gti.Directives{}, Tag: "def:\"100\" min:\"10\" max:\"1000\" step:\"10\""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.ParamPrefs",
	ShortName: "gi.ParamPrefs",
	IDName:    "param-prefs",
	Doc:       "ParamPrefs contains misc parameters controlling GUI behavior.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"DoubleClickInterval", &gti.Field{Name: "DoubleClickInterval", Type: "time.Duration", LocalType: "time.Duration", Doc: "the maximum time interval in msec between button press events to count as a double-click", Directives: gti.Directives{}, Tag: "min:\"100\" step:\"50\""}},
		{"ScrollWheelSpeed", &gti.Field{Name: "ScrollWheelSpeed", Type: "float32", LocalType: "float32", Doc: "how fast the scroll wheel moves -- typically pixels per wheel step but units can be arbitrary.  It is generally impossible to standardize speed and variable across devices, and we don't have access to the system settings, so unfortunately you have to set it here.", Directives: gti.Directives{}, Tag: "min:\"0.01\" step:\"1\""}},
		{"LocalMainMenu", &gti.Field{Name: "LocalMainMenu", Type: "bool", LocalType: "bool", Doc: "controls whether the main menu is displayed locally at top of each window, in addition to global menu at the top of the screen.  Mac native apps do not do this, but OTOH it makes things more consistent with other platforms, and with larger screens, it can be convenient to have access to all the menu items right there.", Directives: gti.Directives{}, Tag: ""}},
		{"OnlyCloseActiveTab", &gti.Field{Name: "OnlyCloseActiveTab", Type: "bool", LocalType: "bool", Doc: "only support closing the currently selected active tab; if this is set to true, pressing the close button on other tabs will take you to that tab, from which you can close it", Directives: gti.Directives{}, Tag: "def:\"false\""}},
		{"ZebraStripeWeight", &gti.Field{Name: "ZebraStripeWeight", Type: "float32", LocalType: "float32", Doc: "the amount that alternating rows and columns are highlighted when showing tabular data (set to 0 to disable zebra striping)", Directives: gti.Directives{}, Tag: "def:\"0\" min:\"0\" max:\"100\" step:\"1\""}},
		{"BigFileSize", &gti.Field{Name: "BigFileSize", Type: "int", LocalType: "int", Doc: "the limit of file size, above which user will be prompted before opening / copying, etc.", Directives: gti.Directives{}, Tag: "def:\"10000000\""}},
		{"SavedPathsMax", &gti.Field{Name: "SavedPathsMax", Type: "int", LocalType: "int", Doc: "maximum number of saved paths to save in FileView", Directives: gti.Directives{}, Tag: ""}},
		{"Smooth3D", &gti.Field{Name: "Smooth3D", Type: "bool", LocalType: "bool", Doc: "turn on smoothing in 3D rendering -- this should be on by default but if you get an error telling you to turn it off, then do so (because your hardware can't handle it)", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.User",
	ShortName: "gi.User",
	IDName:    "user",
	Doc:       "User basic user information that might be needed for different apps",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Email", &gti.Field{Name: "Email", Type: "string", LocalType: "string", Doc: "default email address -- e.g., for recording changes in a version control system", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"User", &gti.Field{Name: "User", Type: "os/user.User", LocalType: "user.User", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.EditorPrefs",
	ShortName: "gi.EditorPrefs",
	IDName:    "editor-prefs",
	Doc:       "EditorPrefs contains editor preferences.  It can also be set\nfrom ki.Props style properties.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"TabSize", &gti.Field{Name: "TabSize", Type: "int", LocalType: "int", Doc: "size of a tab, in chars -- also determines indent level for space indent", Directives: gti.Directives{}, Tag: "xml:\"tab-size\""}},
		{"SpaceIndent", &gti.Field{Name: "SpaceIndent", Type: "bool", LocalType: "bool", Doc: "use spaces for indentation, otherwise tabs", Directives: gti.Directives{}, Tag: "xml:\"space-indent\""}},
		{"WordWrap", &gti.Field{Name: "WordWrap", Type: "bool", LocalType: "bool", Doc: "wrap lines at word boundaries -- otherwise long lines scroll off the end", Directives: gti.Directives{}, Tag: "xml:\"word-wrap\""}},
		{"LineNos", &gti.Field{Name: "LineNos", Type: "bool", LocalType: "bool", Doc: "show line numbers", Directives: gti.Directives{}, Tag: "xml:\"line-nos\""}},
		{"Completion", &gti.Field{Name: "Completion", Type: "bool", LocalType: "bool", Doc: "use the completion system to suggest options while typing", Directives: gti.Directives{}, Tag: "xml:\"completion\""}},
		{"SpellCorrect", &gti.Field{Name: "SpellCorrect", Type: "bool", LocalType: "bool", Doc: "suggest corrections for unknown words while typing", Directives: gti.Directives{}, Tag: "xml:\"spell-correct\""}},
		{"AutoIndent", &gti.Field{Name: "AutoIndent", Type: "bool", LocalType: "bool", Doc: "automatically indent lines when enter, tab, }, etc pressed", Directives: gti.Directives{}, Tag: "xml:\"auto-indent\""}},
		{"EmacsUndo", &gti.Field{Name: "EmacsUndo", Type: "bool", LocalType: "bool", Doc: "use emacs-style undo, where after a non-undo command, all the current undo actions are added to the undo stack, such that a subsequent undo is actually a redo", Directives: gti.Directives{}, Tag: "xml:\"emacs-undo\""}},
		{"DepthColor", &gti.Field{Name: "DepthColor", Type: "bool", LocalType: "bool", Doc: "colorize the background according to nesting depth", Directives: gti.Directives{}, Tag: "xml:\"depth-color\""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.FavPathItem",
	ShortName: "gi.FavPathItem",
	IDName:    "fav-path-item",
	Doc:       "FavPathItem represents one item in a favorite path list, for display of\nfavorites.  Is an ordered list instead of a map because user can organize\nin order",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Ic", &gti.Field{Name: "Ic", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "icon for item", Directives: gti.Directives{}, Tag: ""}},
		{"Name", &gti.Field{Name: "Name", Type: "string", LocalType: "string", Doc: "name of the favorite item", Directives: gti.Directives{}, Tag: "width:\"20\""}},
		{"Path", &gti.Field{Name: "Path", Type: "string", LocalType: "string", Doc: "", Directives: gti.Directives{}, Tag: "tableview:\"-select\""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.PrefsDetailed",
	ShortName: "gi.PrefsDetailed",
	IDName:    "prefs-detailed",
	Doc:       "PrefsDetailed are more detailed params not usually customized, but\navailable for those who really care..",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MenuMaxHeight", &gti.Field{Name: "MenuMaxHeight", Type: "int", LocalType: "int", Doc: "the maximum height of any menu popup panel in units of font height -- scroll bars are enforced beyond that size.", Directives: gti.Directives{}, Tag: "def:\"30\" min:\"5\" step:\"1\""}},
		{"DragStartTime", &gti.Field{Name: "DragStartTime", Type: "time.Duration", LocalType: "time.Duration", Doc: "the number of milliseconds to wait before initiating a regular mouse drag event (as opposed to a basic events.Press)", Directives: gti.Directives{}, Tag: "def:\"50\" min:\"5\" max:\"1000\" step:\"5\""}},
		{"DragStartDist", &gti.Field{Name: "DragStartDist", Type: "int", LocalType: "int", Doc: "the number of pixels that must be moved before initiating a regular mouse drag event (as opposed to a basic events.Press)", Directives: gti.Directives{}, Tag: "def:\"4\" min:\"0\" max:\"100\" step:\"1\""}},
		{"SlideStartTime", &gti.Field{Name: "SlideStartTime", Type: "time.Duration", LocalType: "time.Duration", Doc: "the number of milliseconds to wait before initiating a drag-n-drop event -- gotta drag it like you mean it", Directives: gti.Directives{}, Tag: "def:\"200\" min:\"5\" max:\"1000\" step:\"5\""}},
		{"SlideStartDist", &gti.Field{Name: "SlideStartDist", Type: "int", LocalType: "int", Doc: "the number of pixels that must be moved before initiating a drag-n-drop event -- gotta drag it like you mean it", Directives: gti.Directives{}, Tag: "def:\"20\" min:\"0\" max:\"100\" step:\"1\""}},
		{"LongHoverTime", &gti.Field{Name: "LongHoverTime", Type: "time.Duration", LocalType: "time.Duration", Doc: "the number of milliseconds to wait before initiating a hover event (e.g., for opening a tooltip)", Directives: gti.Directives{}, Tag: "def:\"500\" min:\"10\" max:\"10000\" step:\"10\""}},
		{"LongHoverStopDist", &gti.Field{Name: "LongHoverStopDist", Type: "int", LocalType: "int", Doc: "the maximum number of pixels that mouse can move and still register a Hover event", Directives: gti.Directives{}, Tag: "def:\"50\" min:\"0\" max:\"1000\" step:\"1\""}},
		{"CompleteWaitDuration", &gti.Field{Name: "CompleteWaitDuration", Type: "time.Duration", LocalType: "time.Duration", Doc: "the amount of time to wait before offering completions", Directives: gti.Directives{}, Tag: "def:\"0\" min:\"0\" max:\"10000\" step:\"10\""}},
		{"CompleteMaxItems", &gti.Field{Name: "CompleteMaxItems", Type: "int", LocalType: "int", Doc: "the maximum number of completions offered in popup", Directives: gti.Directives{}, Tag: "def:\"25\" min:\"5\" step:\"1\""}},
		{"CursorBlinkTime", &gti.Field{Name: "CursorBlinkTime", Type: "time.Duration", LocalType: "time.Duration", Doc: "time interval for cursor blinking on and off -- set to 0 to disable blinking", Directives: gti.Directives{}, Tag: "def:\"500\" min:\"0\" max:\"1000\" step:\"5\""}},
		{"LayoutAutoScrollDelayMSec", &gti.Field{Name: "LayoutAutoScrollDelayMSec", Type: "int", LocalType: "int", Doc: "is amount of time to wait (in Milliseconds) before trying to autoscroll again", Directives: gti.Directives{}, Tag: "def:\"25\" min:\"1\" step:\"5\""}},
		{"LayoutPageSteps", &gti.Field{Name: "LayoutPageSteps", Type: "int", LocalType: "int", Doc: "number of steps to take in PageUp / Down events in terms of number of items", Directives: gti.Directives{}, Tag: "def:\"10\" min:\"1\" step:\"1\""}},
		{"LayoutFocusNameTimeoutMSec", &gti.Field{Name: "LayoutFocusNameTimeoutMSec", Type: "int", LocalType: "int", Doc: "the number of milliseconds between keypresses to combine characters into name to search for within layout -- starts over after this delay", Directives: gti.Directives{}, Tag: "def:\"500\" min:\"0\" max:\"5000\" step:\"20\""}},
		{"LayoutFocusNameTabMSec", &gti.Field{Name: "LayoutFocusNameTabMSec", Type: "int", LocalType: "int", Doc: "the number of milliseconds since last focus name event to allow tab to focus on next element with same name.", Directives: gti.Directives{}, Tag: "def:\"2000\" min:\"10\" max:\"10000\" step:\"100\""}},
		{"DialogsSepRenderWin", &gti.Field{Name: "DialogsSepRenderWin", Type: "bool", LocalType: "bool", Doc: "open dialogs in separate windows -- else do as popups in main window", Directives: gti.Directives{}, Tag: "def:\"true\""}},
		{"TextViewClipHistMax", &gti.Field{Name: "TextViewClipHistMax", Type: "int", LocalType: "int", Doc: "Maximum amount of clipboard history to retain", Directives: gti.Directives{}, Tag: "def:\"100\" min:\"0\" max:\"1000\" step:\"5\""}},
		{"TextBufMaxScopeLines", &gti.Field{Name: "TextBufMaxScopeLines", Type: "int", LocalType: "int", Doc: "maximum number of lines to look for matching scope syntax (parens, brackets)", Directives: gti.Directives{}, Tag: "def:\"100\" min:\"10\" step:\"10\""}},
		{"TextBufDiffRevertLines", &gti.Field{Name: "TextBufDiffRevertLines", Type: "int", LocalType: "int", Doc: "text buffer max lines to use diff-based revert to more quickly update e.g., after file has been reformatted", Directives: gti.Directives{}, Tag: "def:\"10000\" min:\"0\" step:\"1000\""}},
		{"TextBufDiffRevertDiffs", &gti.Field{Name: "TextBufDiffRevertDiffs", Type: "int", LocalType: "int", Doc: "text buffer max diffs to use diff-based revert to more quickly update e.g., after file has been reformatted -- if too many differences, just revert", Directives: gti.Directives{}, Tag: "def:\"20\" min:\"0\" step:\"1\""}},
		{"TextBufMarkupDelayMSec", &gti.Field{Name: "TextBufMarkupDelayMSec", Type: "int", LocalType: "int", Doc: "number of milliseconds to wait before starting a new background markup process, after text changes within a single line (always does after line insertion / deletion)", Directives: gti.Directives{}, Tag: "def:\"1000\" min:\"100\" step:\"100\""}},
		{"MapInlineLen", &gti.Field{Name: "MapInlineLen", Type: "int", LocalType: "int", Doc: "the number of map elements at or below which an inline representation of the map will be presented -- more convenient for small #'s of props", Directives: gti.Directives{}, Tag: "def:\"2\" min:\"1\" step:\"1\""}},
		{"StructInlineLen", &gti.Field{Name: "StructInlineLen", Type: "int", LocalType: "int", Doc: "the number of elemental struct fields at or below which an inline representation of the struct will be presented -- more convenient for small structs", Directives: gti.Directives{}, Tag: "def:\"4\" min:\"2\" step:\"1\""}},
		{"SliceInlineLen", &gti.Field{Name: "SliceInlineLen", Type: "int", LocalType: "int", Doc: "the number of slice elements below which inline will be used", Directives: gti.Directives{}, Tag: "def:\"4\" min:\"2\" step:\"1\""}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", LocalType: "bool", Doc: "flag that is set by StructView by virtue of changeflag tag, whenever an edit is made.  Used to drive save menus etc.", Directives: gti.Directives{}, Tag: "view:\"-\" changeflag:\"+\" json:\"-\" xml:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{
		{"Open", &gti.Method{Name: "Open", Doc: "Open detailed preferences from GoGi standard prefs directory", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"error", &gti.Field{Name: "error", Type: "error", LocalType: "error", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
		{"Save", &gti.Method{Name: "Save", Doc: "Save saves current preferences to standard prefs_det.json file, which is auto-loaded at startup", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"error", &gti.Field{Name: "error", Type: "error", LocalType: "error", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
		{"Apply", &gti.Method{Name: "Apply", Doc: "Apply detailed preferences to all the relevant settings.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
	}),
})

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.PrefsDebug",
	ShortName: "gi.PrefsDebug",
	IDName:    "prefs-debug",
	Doc:       "PrefsDebug are debugging params",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"UpdateTrace", &gti.Field{Name: "UpdateTrace", Type: "*bool", LocalType: "*bool", Doc: "reports trace of updates that trigger re-rendering (printfs to stdout)", Directives: gti.Directives{}, Tag: ""}},
		{"RenderTrace", &gti.Field{Name: "RenderTrace", Type: "*bool", LocalType: "*bool", Doc: "reports trace of the nodes rendering (printfs to stdout)", Directives: gti.Directives{}, Tag: ""}},
		{"LayoutTrace", &gti.Field{Name: "LayoutTrace", Type: "*bool", LocalType: "*bool", Doc: "reports trace of all layouts (printfs to stdout)", Directives: gti.Directives{}, Tag: ""}},
		{"WinEventTrace", &gti.Field{Name: "WinEventTrace", Type: "*bool", LocalType: "*bool", Doc: "reports trace of window events (printfs to stdout)", Directives: gti.Directives{}, Tag: ""}},
		{"WinRenderTrace", &gti.Field{Name: "WinRenderTrace", Type: "*bool", LocalType: "*bool", Doc: "reports the stack trace leading up to win publish events which are expensive -- wrap multiple updates in UpdateStart / End to prevent", Directives: gti.Directives{}, Tag: ""}},
		{"WinGeomTrace", &gti.Field{Name: "WinGeomTrace", Type: "*bool", LocalType: "*bool", Doc: "WinGeomTrace records window geometry saving / loading functions", Directives: gti.Directives{}, Tag: ""}},
		{"KeyEventTrace", &gti.Field{Name: "KeyEventTrace", Type: "*bool", LocalType: "*bool", Doc: "reports trace of keyboard events (printfs to stdout)", Directives: gti.Directives{}, Tag: ""}},
		{"EventTrace", &gti.Field{Name: "EventTrace", Type: "*bool", LocalType: "*bool", Doc: "reports trace of event handling (printfs to stdout)", Directives: gti.Directives{}, Tag: ""}},
		{"DNDTrace", &gti.Field{Name: "DNDTrace", Type: "*bool", LocalType: "*bool", Doc: "reports trace of DND events handling", Directives: gti.Directives{}, Tag: ""}},
		{"GoCompleteTrace", &gti.Field{Name: "GoCompleteTrace", Type: "*bool", LocalType: "*bool", Doc: "reports trace of Go language completion & lookup process", Directives: gti.Directives{}, Tag: ""}},
		{"GoTypeTrace", &gti.Field{Name: "GoTypeTrace", Type: "*bool", LocalType: "*bool", Doc: "reports trace of Go language type parsing and inference process", Directives: gti.Directives{}, Tag: ""}},
		{"StructViewIfDebug", &gti.Field{Name: "StructViewIfDebug", Type: "*bool", LocalType: "*bool", Doc: "reports errors for viewif directives in struct field tags, for giv.StructView", Directives: gti.Directives{}, Tag: ""}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", LocalType: "bool", Doc: "flag that is set by StructView by virtue of changeflag tag, whenever an edit is made.  Used to drive save menus etc.", Directives: gti.Directives{}, Tag: "view:\"-\" changeflag:\"+\" json:\"-\" xml:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{
		{"Profile", &gti.Method{Name: "Profile", Doc: "Profile toggles profiling of program on or off, which does both\ntargeted and global CPU and Memory profiling.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
	}),
})

// ProgressBarType is the [gti.Type] for [ProgressBar]
var ProgressBarType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.ProgressBar",
	ShortName:  "gi.ProgressBar",
	IDName:     "progress-bar",
	Doc:        "ProgressBar is a progress bar that fills up bar as progress continues.\nCall Start with a maximum value to work toward, and ProgStep each time\na progress step has been accomplished -- increments the ProgCur by one\nand display is updated every ProgInc such steps.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ProgMax", &gti.Field{Name: "ProgMax", Type: "int", LocalType: "int", Doc: "maximum amount of progress to be achieved", Directives: gti.Directives{}, Tag: ""}},
		{"ProgInc", &gti.Field{Name: "ProgInc", Type: "int", LocalType: "int", Doc: "progress increment when display is updated -- automatically computed from ProgMax at Start but can be overwritten", Directives: gti.Directives{}, Tag: ""}},
		{"ProgCur", &gti.Field{Name: "ProgCur", Type: "int", LocalType: "int", Doc: "current progress level", Directives: gti.Directives{}, Tag: ""}},
		{"ProgMu", &gti.Field{Name: "ProgMu", Type: "sync.Mutex", LocalType: "sync.Mutex", Doc: "mutex for updating progress", Directives: gti.Directives{}, Tag: "set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Slider", &gti.Field{Name: "Slider", Type: "goki.dev/gi/v2/gi.Slider", LocalType: "Slider", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ProgressBar{},
})

// NewProgressBar adds a new [ProgressBar] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewProgressBar(par ki.Ki, name ...string) *ProgressBar {
	return par.NewChild(ProgressBarType, name...).(*ProgressBar)
}

// KiType returns the [*gti.Type] of [ProgressBar]
func (t *ProgressBar) KiType() *gti.Type {
	return ProgressBarType
}

// New returns a new [*ProgressBar] value
func (t *ProgressBar) New() ki.Ki {
	return &ProgressBar{}
}

// SetProgMax sets the [ProgressBar.ProgMax]:
// maximum amount of progress to be achieved
func (t *ProgressBar) SetProgMax(v int) *ProgressBar {
	t.ProgMax = v
	return t
}

// SetProgInc sets the [ProgressBar.ProgInc]:
// progress increment when display is updated -- automatically computed from ProgMax at Start but can be overwritten
func (t *ProgressBar) SetProgInc(v int) *ProgressBar {
	t.ProgInc = v
	return t
}

// SetProgCur sets the [ProgressBar.ProgCur]:
// current progress level
func (t *ProgressBar) SetProgCur(v int) *ProgressBar {
	t.ProgCur = v
	return t
}

// SetTooltip sets the [ProgressBar.Tooltip]
func (t *ProgressBar) SetTooltip(v string) *ProgressBar {
	t.Tooltip = v
	return t
}

// SetClass sets the [ProgressBar.Class]
func (t *ProgressBar) SetClass(v string) *ProgressBar {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [ProgressBar.CustomContextMenu]
func (t *ProgressBar) SetCustomContextMenu(v func(m *Scene)) *ProgressBar {
	t.CustomContextMenu = v
	return t
}

// SetDim sets the [ProgressBar.Dim]
func (t *ProgressBar) SetDim(v mat32.Dims) *ProgressBar {
	t.Dim = v
	return t
}

// SetMin sets the [ProgressBar.Min]
func (t *ProgressBar) SetMin(v float32) *ProgressBar {
	t.Min = v
	return t
}

// SetMax sets the [ProgressBar.Max]
func (t *ProgressBar) SetMax(v float32) *ProgressBar {
	t.Max = v
	return t
}

// SetStep sets the [ProgressBar.Step]
func (t *ProgressBar) SetStep(v float32) *ProgressBar {
	t.Step = v
	return t
}

// SetPageStep sets the [ProgressBar.PageStep]
func (t *ProgressBar) SetPageStep(v float32) *ProgressBar {
	t.PageStep = v
	return t
}

// SetValThumb sets the [ProgressBar.ValThumb]
func (t *ProgressBar) SetValThumb(v bool) *ProgressBar {
	t.ValThumb = v
	return t
}

// SetThumbVal sets the [ProgressBar.ThumbVal]
func (t *ProgressBar) SetThumbVal(v float32) *ProgressBar {
	t.ThumbVal = v
	return t
}

// SetThumbSize sets the [ProgressBar.ThumbSize]
func (t *ProgressBar) SetThumbSize(v units.Value) *ProgressBar {
	t.ThumbSize = v
	return t
}

// SetIcon sets the [ProgressBar.Icon]
func (t *ProgressBar) SetIcon(v icons.Icon) *ProgressBar {
	t.Icon = v
	return t
}

// SetTracking sets the [ProgressBar.Tracking]
func (t *ProgressBar) SetTracking(v bool) *ProgressBar {
	t.Tracking = v
	return t
}

// SetTrackThr sets the [ProgressBar.TrackThr]
func (t *ProgressBar) SetTrackThr(v float32) *ProgressBar {
	t.TrackThr = v
	return t
}

// SetSnap sets the [ProgressBar.Snap]
func (t *ProgressBar) SetSnap(v bool) *ProgressBar {
	t.Snap = v
	return t
}

// SetOff sets the [ProgressBar.Off]
func (t *ProgressBar) SetOff(v bool) *ProgressBar {
	t.Off = v
	return t
}

// SetPrec sets the [ProgressBar.Prec]
func (t *ProgressBar) SetPrec(v int) *ProgressBar {
	t.Prec = v
	return t
}

// SetValueColor sets the [ProgressBar.ValueColor]
func (t *ProgressBar) SetValueColor(v colors.Full) *ProgressBar {
	t.ValueColor = v
	return t
}

// SetThumbColor sets the [ProgressBar.ThumbColor]
func (t *ProgressBar) SetThumbColor(v colors.Full) *ProgressBar {
	t.ThumbColor = v
	return t
}

// SceneType is the [gti.Type] for [Scene]
var SceneType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Scene",
	ShortName: "gi.Scene",
	IDName:    "scene",
	Doc:       "Scene contains a Widget tree, rooted in an embedded Frame layout,\nwhich renders into its Pixels image.\nThe Scene is set in a Stage (pointer retained in Scene).\nStage has a StageMgr manager for controlling things like Popups\n(Menus and Dialogs, etc).\n\nEach Scene and Widget tree contains state specific to its particular usage\nwithin a given Stage and overall rendering context (e.g., bounding boxes\nand pointer to current parent Stage), so [TODO(rcoreilly): you need to finish this]",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "no-new", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Title", &gti.Field{Name: "Title", Type: "string", LocalType: "string", Doc: "title of the Scene", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Data", &gti.Field{Name: "Data", Type: "any", LocalType: "any", Doc: "Data is the optional data value being represented by this scene.\nUsed e.g., for recycling views of a given item instead of creating new one.", Directives: gti.Directives{}, Tag: ""}},
		{"TopAppBar", &gti.Field{Name: "TopAppBar", Type: "func(tb *goki.dev/gi/v2/gi.Toolbar)", LocalType: "func(tb *Toolbar)", Doc: "TopAppBar is a function used to construct a top app bar at the top of the\nscene when it is set up. It is copied by default to all FullWindow [DialogStage]s\ncreated in the context of this scene.", Directives: gti.Directives{}, Tag: ""}},
		{"Geom", &gti.Field{Name: "Geom", Type: "goki.dev/mat32/v2.Geom2DInt", LocalType: "mat32.Geom2DInt", Doc: "Size and position relative to overall rendering context.", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\""}},
		{"RenderState", &gti.Field{Name: "RenderState", Type: "goki.dev/girl/paint.State", LocalType: "paint.State", Doc: "render state for rendering", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\" set:\"-\""}},
		{"Pixels", &gti.Field{Name: "Pixels", Type: "*image.RGBA", LocalType: "*image.RGBA", Doc: "live pixels that we render into", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\" set:\"-\""}},
		{"BgColor", &gti.Field{Name: "BgColor", Type: "goki.dev/colors.Full", LocalType: "colors.Full", Doc: "background color for filling scene -- defaults to transparent so that popups can have rounded corners", Directives: gti.Directives{}, Tag: ""}},
		{"EventMgr", &gti.Field{Name: "EventMgr", Type: "goki.dev/gi/v2/gi.EventMgr", LocalType: "EventMgr", Doc: "event manager for this scene", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"Stage", &gti.Field{Name: "Stage", Type: "goki.dev/gi/v2/gi.Stage", LocalType: "Stage", Doc: "current stage in which this Scene is set", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"CurColor", &gti.Field{Name: "CurColor", Type: "image/color.RGBA", LocalType: "color.RGBA", Doc: "Current color in styling -- used for relative color names", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\" set:\"-\""}},
		{"LastRender", &gti.Field{Name: "LastRender", Type: "goki.dev/gi/v2/gi.RenderParams", LocalType: "RenderParams", Doc: "LastRender captures key params from last render.\nIf different then a new ApplyStyleScene is needed.", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\""}},
		{"StyleMu", &gti.Field{Name: "StyleMu", Type: "sync.RWMutex", LocalType: "sync.RWMutex", Doc: "StyleMu is RW mutex protecting access to Style-related global vars", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\" set:\"-\""}},
		{"ShowLayoutIter", &gti.Field{Name: "ShowLayoutIter", Type: "int", LocalType: "int", Doc: "ShowLayoutIter counts up at start of showing a Scene\nfor a sequence of Layout passes to ensure proper initial sizing.", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "goki.dev/gi/v2/gi.Frame", LocalType: "Frame", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Scene{},
})

// KiType returns the [*gti.Type] of [Scene]
func (t *Scene) KiType() *gti.Type {
	return SceneType
}

// New returns a new [*Scene] value
func (t *Scene) New() ki.Ki {
	return &Scene{}
}

// SetData sets the [Scene.Data]:
// Data is the optional data value being represented by this scene.
// Used e.g., for recycling views of a given item instead of creating new one.
func (t *Scene) SetData(v any) *Scene {
	t.Data = v
	return t
}

// SetTopAppBar sets the [Scene.TopAppBar]:
// TopAppBar is a function used to construct a top app bar at the top of the
// scene when it is set up. It is copied by default to all FullWindow [DialogStage]s
// created in the context of this scene.
func (t *Scene) SetTopAppBar(v func(tb *Toolbar)) *Scene {
	t.TopAppBar = v
	return t
}

// SetBgColor sets the [Scene.BgColor]:
// background color for filling scene -- defaults to transparent so that popups can have rounded corners
func (t *Scene) SetBgColor(v colors.Full) *Scene {
	t.BgColor = v
	return t
}

// SetTooltip sets the [Scene.Tooltip]
func (t *Scene) SetTooltip(v string) *Scene {
	t.Tooltip = v
	return t
}

// SetClass sets the [Scene.Class]
func (t *Scene) SetClass(v string) *Scene {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Scene.CustomContextMenu]
func (t *Scene) SetCustomContextMenu(v func(m *Scene)) *Scene {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [Scene.Lay]
func (t *Scene) SetLayout(v Layouts) *Scene {
	t.Lay = v
	return t
}

// SetStackTop sets the [Scene.StackTop]
func (t *Scene) SetStackTop(v int) *Scene {
	t.StackTop = v
	return t
}

// SetStripes sets the [Scene.Stripes]
func (t *Scene) SetStripes(v Stripes) *Scene {
	t.Stripes = v
	return t
}

// SeparatorType is the [gti.Type] for [Separator]
var SeparatorType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Separator",
	ShortName:  "gi.Separator",
	IDName:     "separator",
	Doc:        "Separator draws a vertical or horizontal line",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Horiz", &gti.Field{Name: "Horiz", Type: "bool", LocalType: "bool", Doc: "whether this is a horizontal separator; if false, it is vertical", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Separator{},
})

// NewSeparator adds a new [Separator] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSeparator(par ki.Ki, name ...string) *Separator {
	return par.NewChild(SeparatorType, name...).(*Separator)
}

// KiType returns the [*gti.Type] of [Separator]
func (t *Separator) KiType() *gti.Type {
	return SeparatorType
}

// New returns a new [*Separator] value
func (t *Separator) New() ki.Ki {
	return &Separator{}
}

// SetHoriz sets the [Separator.Horiz]:
// whether this is a horizontal separator; if false, it is vertical
func (t *Separator) SetHoriz(v bool) *Separator {
	t.Horiz = v
	return t
}

// SetTooltip sets the [Separator.Tooltip]
func (t *Separator) SetTooltip(v string) *Separator {
	t.Tooltip = v
	return t
}

// SetClass sets the [Separator.Class]
func (t *Separator) SetClass(v string) *Separator {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Separator.CustomContextMenu]
func (t *Separator) SetCustomContextMenu(v func(m *Scene)) *Separator {
	t.CustomContextMenu = v
	return t
}

// SliderType is the [gti.Type] for [Slider]
var SliderType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Slider",
	ShortName: "gi.Slider",
	IDName:    "slider",
	Doc:       "Slider is a slideable widget that provides slider functionality for two major modes.\nValThumb = false is a slider with a fixed-size thumb knob, while = true has a thumb\nthat represents a value, as in a scrollbar, and the scrolling range is size - thumbsize",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Type", &gti.Field{Name: "Type", Type: "goki.dev/gi/v2/gi.SliderTypes", LocalType: "SliderTypes", Doc: "the type of the slider", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Value", &gti.Field{Name: "Value", Type: "float32", LocalType: "float32", Doc: "current value", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Dim", &gti.Field{Name: "Dim", Type: "goki.dev/mat32/v2.Dims", LocalType: "mat32.Dims", Doc: "dimension along which the slider slides", Directives: gti.Directives{}, Tag: ""}},
		{"Min", &gti.Field{Name: "Min", Type: "float32", LocalType: "float32", Doc: "minimum value in range", Directives: gti.Directives{}, Tag: ""}},
		{"Max", &gti.Field{Name: "Max", Type: "float32", LocalType: "float32", Doc: "maximum value in range", Directives: gti.Directives{}, Tag: ""}},
		{"Step", &gti.Field{Name: "Step", Type: "float32", LocalType: "float32", Doc: "smallest step size to increment", Directives: gti.Directives{}, Tag: ""}},
		{"PageStep", &gti.Field{Name: "PageStep", Type: "float32", LocalType: "float32", Doc: "larger PageUp / Dn step size", Directives: gti.Directives{}, Tag: ""}},
		{"ValThumb", &gti.Field{Name: "ValThumb", Type: "bool", LocalType: "bool", Doc: "if true, has a proportionally-sized thumb knob reflecting another value -- e.g., the amount visible in a scrollbar, and thumb is completely inside Size -- otherwise ThumbSize affects Size so that full Size range can be traversed", Directives: gti.Directives{}, Tag: ""}},
		{"ThumbVal", &gti.Field{Name: "ThumbVal", Type: "float32", LocalType: "float32", Doc: "value that the thumb represents, in the same units", Directives: gti.Directives{}, Tag: ""}},
		{"ThumbSize", &gti.Field{Name: "ThumbSize", Type: "goki.dev/girl/units.Value", LocalType: "units.Value", Doc: "styled fixed size of the thumb -- only if not doing ValThumb", Directives: gti.Directives{}, Tag: ""}},
		{"Icon", &gti.Field{Name: "Icon", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "optional icon for the dragging knob", Directives: gti.Directives{}, Tag: "view:\"show-name\""}},
		{"Tracking", &gti.Field{Name: "Tracking", Type: "bool", LocalType: "bool", Doc: "if true, will send continuous updates of value changes as user moves the slider -- otherwise only at the end -- see TrackThr for a threshold on amount of change", Directives: gti.Directives{}, Tag: ""}},
		{"TrackThr", &gti.Field{Name: "TrackThr", Type: "float32", LocalType: "float32", Doc: "threshold for amount of change in scroll value before emitting a signal in Tracking mode", Directives: gti.Directives{}, Tag: ""}},
		{"Snap", &gti.Field{Name: "Snap", Type: "bool", LocalType: "bool", Doc: "snap the values to Step size increments", Directives: gti.Directives{}, Tag: ""}},
		{"Off", &gti.Field{Name: "Off", Type: "bool", LocalType: "bool", Doc: "can turn off e.g., scrollbar rendering with this flag -- just prevents rendering", Directives: gti.Directives{}, Tag: ""}},
		{"Prec", &gti.Field{Name: "Prec", Type: "int", LocalType: "int", Doc: "specifies the precision of decimal places (total, not after the decimal point) to use in representing the number -- this helps to truncate small weird floating point values in the nether regions", Directives: gti.Directives{}, Tag: "xml:\"prec\""}},
		{"ValueColor", &gti.Field{Name: "ValueColor", Type: "goki.dev/colors.Full", LocalType: "colors.Full", Doc: "the background color that is used for styling the selected value section of the slider; it should be set in the StyleFuncs, just like the main style object is", Directives: gti.Directives{}, Tag: ""}},
		{"ThumbColor", &gti.Field{Name: "ThumbColor", Type: "goki.dev/colors.Full", LocalType: "colors.Full", Doc: "the background color that is used for styling the thumb (handle) of the slider; it should be set in the StyleFuncs, just like the main style object is", Directives: gti.Directives{}, Tag: ""}},
		{"StyleBox", &gti.Field{Name: "StyleBox", Type: "goki.dev/girl/styles.Style", LocalType: "styles.Style", Doc: "an additional style object that is used for styling the overall box around the slider; it should be set in the StyleFuncs, just the like the main style object is; it typically has no border and a white/black background; it needs a background to allow local re-rendering", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Pos", &gti.Field{Name: "Pos", Type: "float32", LocalType: "float32", Doc: "logical position of the slider relative to Size", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\""}},
		{"LastValue", &gti.Field{Name: "LastValue", Type: "float32", LocalType: "float32", Doc: "previous emitted value - don't re-emit if it is the same", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" xml:\"-\" json:\"-\" set:\"-\""}},
		{"Size", &gti.Field{Name: "Size", Type: "float32", LocalType: "float32", Doc: "computed size of the slide box in the relevant dimension -- range of motion -- exclusive of spacing -- based on layout allocation", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\""}},
		{"ThSize", &gti.Field{Name: "ThSize", Type: "float32", LocalType: "float32", Doc: "computed size of the thumb -- if ValThumb then this is auto-sized based on ThumbVal and is subtracted from Size in computing Value -- this is the display size version subject to SliderMinThumbSize", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\""}},
		{"ThSizeReal", &gti.Field{Name: "ThSizeReal", Type: "float32", LocalType: "float32", Doc: "computed size of the thumb, without any SliderMinThumbSize limitation -- use this for more accurate calculations of true value", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\""}},
		{"SlideStartPos", &gti.Field{Name: "SlideStartPos", Type: "float32", LocalType: "float32", Doc: "underlying drag position of slider -- not subject to snapping", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Slider{},
})

// NewSlider adds a new [Slider] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSlider(par ki.Ki, name ...string) *Slider {
	return par.NewChild(SliderType, name...).(*Slider)
}

// KiType returns the [*gti.Type] of [Slider]
func (t *Slider) KiType() *gti.Type {
	return SliderType
}

// New returns a new [*Slider] value
func (t *Slider) New() ki.Ki {
	return &Slider{}
}

// SliderEmbedder is an interface that all types that embed Slider satisfy
type SliderEmbedder interface {
	AsSlider() *Slider
}

// AsSlider returns the given value as a value of type Slider if the type
// of the given value embeds Slider, or nil otherwise
func AsSlider(k ki.Ki) *Slider {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(SliderEmbedder); ok {
		return t.AsSlider()
	}
	return nil
}

// AsSlider satisfies the [SliderEmbedder] interface
func (t *Slider) AsSlider() *Slider {
	return t
}

// SetDim sets the [Slider.Dim]:
// dimension along which the slider slides
func (t *Slider) SetDim(v mat32.Dims) *Slider {
	t.Dim = v
	return t
}

// SetMin sets the [Slider.Min]:
// minimum value in range
func (t *Slider) SetMin(v float32) *Slider {
	t.Min = v
	return t
}

// SetMax sets the [Slider.Max]:
// maximum value in range
func (t *Slider) SetMax(v float32) *Slider {
	t.Max = v
	return t
}

// SetStep sets the [Slider.Step]:
// smallest step size to increment
func (t *Slider) SetStep(v float32) *Slider {
	t.Step = v
	return t
}

// SetPageStep sets the [Slider.PageStep]:
// larger PageUp / Dn step size
func (t *Slider) SetPageStep(v float32) *Slider {
	t.PageStep = v
	return t
}

// SetValThumb sets the [Slider.ValThumb]:
// if true, has a proportionally-sized thumb knob reflecting another value -- e.g., the amount visible in a scrollbar, and thumb is completely inside Size -- otherwise ThumbSize affects Size so that full Size range can be traversed
func (t *Slider) SetValThumb(v bool) *Slider {
	t.ValThumb = v
	return t
}

// SetThumbVal sets the [Slider.ThumbVal]:
// value that the thumb represents, in the same units
func (t *Slider) SetThumbVal(v float32) *Slider {
	t.ThumbVal = v
	return t
}

// SetThumbSize sets the [Slider.ThumbSize]:
// styled fixed size of the thumb -- only if not doing ValThumb
func (t *Slider) SetThumbSize(v units.Value) *Slider {
	t.ThumbSize = v
	return t
}

// SetIcon sets the [Slider.Icon]:
// optional icon for the dragging knob
func (t *Slider) SetIcon(v icons.Icon) *Slider {
	t.Icon = v
	return t
}

// SetTracking sets the [Slider.Tracking]:
// if true, will send continuous updates of value changes as user moves the slider -- otherwise only at the end -- see TrackThr for a threshold on amount of change
func (t *Slider) SetTracking(v bool) *Slider {
	t.Tracking = v
	return t
}

// SetTrackThr sets the [Slider.TrackThr]:
// threshold for amount of change in scroll value before emitting a signal in Tracking mode
func (t *Slider) SetTrackThr(v float32) *Slider {
	t.TrackThr = v
	return t
}

// SetSnap sets the [Slider.Snap]:
// snap the values to Step size increments
func (t *Slider) SetSnap(v bool) *Slider {
	t.Snap = v
	return t
}

// SetOff sets the [Slider.Off]:
// can turn off e.g., scrollbar rendering with this flag -- just prevents rendering
func (t *Slider) SetOff(v bool) *Slider {
	t.Off = v
	return t
}

// SetPrec sets the [Slider.Prec]:
// specifies the precision of decimal places (total, not after the decimal point) to use in representing the number -- this helps to truncate small weird floating point values in the nether regions
func (t *Slider) SetPrec(v int) *Slider {
	t.Prec = v
	return t
}

// SetValueColor sets the [Slider.ValueColor]:
// the background color that is used for styling the selected value section of the slider; it should be set in the StyleFuncs, just like the main style object is
func (t *Slider) SetValueColor(v colors.Full) *Slider {
	t.ValueColor = v
	return t
}

// SetThumbColor sets the [Slider.ThumbColor]:
// the background color that is used for styling the thumb (handle) of the slider; it should be set in the StyleFuncs, just like the main style object is
func (t *Slider) SetThumbColor(v colors.Full) *Slider {
	t.ThumbColor = v
	return t
}

// SetTooltip sets the [Slider.Tooltip]
func (t *Slider) SetTooltip(v string) *Slider {
	t.Tooltip = v
	return t
}

// SetClass sets the [Slider.Class]
func (t *Slider) SetClass(v string) *Slider {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Slider.CustomContextMenu]
func (t *Slider) SetCustomContextMenu(v func(m *Scene)) *Slider {
	t.CustomContextMenu = v
	return t
}

// SnackbarType is the [gti.Type] for [Snackbar]
var SnackbarType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Snackbar",
	ShortName: "gi.Snackbar",
	IDName:    "snackbar",
	Doc:       "Snackbar is a scene with methods for configuring a snackbar",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "no-new", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Stage", &gti.Field{Name: "Stage", Type: "*goki.dev/gi/v2/gi.PopupStage", LocalType: "*PopupStage", Doc: "Stage is the popup stage associated with the dialog", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Scene", &gti.Field{Name: "Scene", Type: "goki.dev/gi/v2/gi.Scene", LocalType: "Scene", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Snackbar{},
})

// KiType returns the [*gti.Type] of [Snackbar]
func (t *Snackbar) KiType() *gti.Type {
	return SnackbarType
}

// New returns a new [*Snackbar] value
func (t *Snackbar) New() ki.Ki {
	return &Snackbar{}
}

// SetStage sets the [Snackbar.Stage]:
// Stage is the popup stage associated with the dialog
func (t *Snackbar) SetStage(v *PopupStage) *Snackbar {
	t.Stage = v
	return t
}

// SetTooltip sets the [Snackbar.Tooltip]
func (t *Snackbar) SetTooltip(v string) *Snackbar {
	t.Tooltip = v
	return t
}

// SetClass sets the [Snackbar.Class]
func (t *Snackbar) SetClass(v string) *Snackbar {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Snackbar.CustomContextMenu]
func (t *Snackbar) SetCustomContextMenu(v func(m *Scene)) *Snackbar {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [Snackbar.Lay]
func (t *Snackbar) SetLayout(v Layouts) *Snackbar {
	t.Lay = v
	return t
}

// SetStackTop sets the [Snackbar.StackTop]
func (t *Snackbar) SetStackTop(v int) *Snackbar {
	t.StackTop = v
	return t
}

// SetStripes sets the [Snackbar.Stripes]
func (t *Snackbar) SetStripes(v Stripes) *Snackbar {
	t.Stripes = v
	return t
}

// SetData sets the [Snackbar.Data]
func (t *Snackbar) SetData(v any) *Snackbar {
	t.Data = v
	return t
}

// SetTopAppBar sets the [Snackbar.TopAppBar]
func (t *Snackbar) SetTopAppBar(v func(tb *Toolbar)) *Snackbar {
	t.TopAppBar = v
	return t
}

// SetBgColor sets the [Snackbar.BgColor]
func (t *Snackbar) SetBgColor(v colors.Full) *Snackbar {
	t.BgColor = v
	return t
}

// SpellType is the [gti.Type] for [Spell]
var SpellType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Spell",
	ShortName:  "gi.Spell",
	IDName:     "spell",
	Doc:        "Spell",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SrcLn", &gti.Field{Name: "SrcLn", Type: "int", LocalType: "int", Doc: "line number in source that spelling is operating on, if relevant", Directives: gti.Directives{}, Tag: ""}},
		{"SrcCh", &gti.Field{Name: "SrcCh", Type: "int", LocalType: "int", Doc: "character position in source that spelling is operating on (start of word to be corrected)", Directives: gti.Directives{}, Tag: ""}},
		{"Suggest", &gti.Field{Name: "Suggest", Type: "[]string", LocalType: "[]string", Doc: "list of suggested corrections", Directives: gti.Directives{}, Tag: ""}},
		{"Word", &gti.Field{Name: "Word", Type: "string", LocalType: "string", Doc: "word being checked", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"LastLearned", &gti.Field{Name: "LastLearned", Type: "string", LocalType: "string", Doc: "last word learned -- can be undone -- stored in lowercase format", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Correction", &gti.Field{Name: "Correction", Type: "string", LocalType: "string", Doc: "the user's correction selection", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Sc", &gti.Field{Name: "Sc", Type: "*goki.dev/gi/v2/gi.Scene", LocalType: "*Scene", Doc: "the scene where the current popup menu is presented", Directives: gti.Directives{}, Tag: " set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Node", &gti.Field{Name: "Node", Type: "goki.dev/ki/v2.Node", LocalType: "ki.Node", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Spell{},
})

// NewSpell adds a new [Spell] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSpell(par ki.Ki, name ...string) *Spell {
	return par.NewChild(SpellType, name...).(*Spell)
}

// KiType returns the [*gti.Type] of [Spell]
func (t *Spell) KiType() *gti.Type {
	return SpellType
}

// New returns a new [*Spell] value
func (t *Spell) New() ki.Ki {
	return &Spell{}
}

// SetSrcLn sets the [Spell.SrcLn]:
// line number in source that spelling is operating on, if relevant
func (t *Spell) SetSrcLn(v int) *Spell {
	t.SrcLn = v
	return t
}

// SetSrcCh sets the [Spell.SrcCh]:
// character position in source that spelling is operating on (start of word to be corrected)
func (t *Spell) SetSrcCh(v int) *Spell {
	t.SrcCh = v
	return t
}

// SetSuggest sets the [Spell.Suggest]:
// list of suggested corrections
func (t *Spell) SetSuggest(v []string) *Spell {
	t.Suggest = v
	return t
}

// SpinnerType is the [gti.Type] for [Spinner]
var SpinnerType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Spinner",
	ShortName: "gi.Spinner",
	IDName:    "spinner",
	Doc:       "Spinner combines a TextField with up / down buttons for incrementing /\ndecrementing values -- all configured within the Parts of the widget",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Value", &gti.Field{Name: "Value", Type: "float32", LocalType: "float32", Doc: "current value", Directives: gti.Directives{}, Tag: "xml:\"value\" set:\"-\""}},
		{"HasMin", &gti.Field{Name: "HasMin", Type: "bool", LocalType: "bool", Doc: "is there a minimum value to enforce", Directives: gti.Directives{}, Tag: "xml:\"has-min\" set:\"-\""}},
		{"Min", &gti.Field{Name: "Min", Type: "float32", LocalType: "float32", Doc: "minimum value in range", Directives: gti.Directives{}, Tag: "xml:\"min\" set:\"-\""}},
		{"HasMax", &gti.Field{Name: "HasMax", Type: "bool", LocalType: "bool", Doc: "is there a maximumvalue to enforce", Directives: gti.Directives{}, Tag: "xml:\"has-max\" set:\"-\""}},
		{"Max", &gti.Field{Name: "Max", Type: "float32", LocalType: "float32", Doc: "maximum value in range", Directives: gti.Directives{}, Tag: "xml:\"max\" set:\"-\""}},
		{"Step", &gti.Field{Name: "Step", Type: "float32", LocalType: "float32", Doc: "smallest step size to increment", Directives: gti.Directives{}, Tag: "xml:\"step\""}},
		{"PageStep", &gti.Field{Name: "PageStep", Type: "float32", LocalType: "float32", Doc: "larger PageUp / Dn step size", Directives: gti.Directives{}, Tag: "xml:\"pagestep\""}},
		{"Prec", &gti.Field{Name: "Prec", Type: "int", LocalType: "int", Doc: "specifies the precision of decimal places (total, not after the decimal point) to use in representing the number -- this helps to truncate small weird floating point values in the nether regions", Directives: gti.Directives{}, Tag: ""}},
		{"Format", &gti.Field{Name: "Format", Type: "string", LocalType: "string", Doc: "prop = format -- format string for printing the value -- blank defaults to %g.  If decimal based (ends in d, b, c, o, O, q, x, X, or U) then value is converted to decimal prior to printing", Directives: gti.Directives{}, Tag: "xml:\"format\""}},
		{"UpIcon", &gti.Field{Name: "UpIcon", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "icon to use for up button -- defaults to", Directives: gti.Directives{}, Tag: "view:\"show-name\""}},
		{"DownIcon", &gti.Field{Name: "DownIcon", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "icon to use for down button -- defaults to", Directives: gti.Directives{}, Tag: "view:\"show-name\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Spinner{},
})

// NewSpinner adds a new [Spinner] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSpinner(par ki.Ki, name ...string) *Spinner {
	return par.NewChild(SpinnerType, name...).(*Spinner)
}

// KiType returns the [*gti.Type] of [Spinner]
func (t *Spinner) KiType() *gti.Type {
	return SpinnerType
}

// New returns a new [*Spinner] value
func (t *Spinner) New() ki.Ki {
	return &Spinner{}
}

// SpinnerEmbedder is an interface that all types that embed Spinner satisfy
type SpinnerEmbedder interface {
	AsSpinner() *Spinner
}

// AsSpinner returns the given value as a value of type Spinner if the type
// of the given value embeds Spinner, or nil otherwise
func AsSpinner(k ki.Ki) *Spinner {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(SpinnerEmbedder); ok {
		return t.AsSpinner()
	}
	return nil
}

// AsSpinner satisfies the [SpinnerEmbedder] interface
func (t *Spinner) AsSpinner() *Spinner {
	return t
}

// SetStep sets the [Spinner.Step]:
// smallest step size to increment
func (t *Spinner) SetStep(v float32) *Spinner {
	t.Step = v
	return t
}

// SetPageStep sets the [Spinner.PageStep]:
// larger PageUp / Dn step size
func (t *Spinner) SetPageStep(v float32) *Spinner {
	t.PageStep = v
	return t
}

// SetPrec sets the [Spinner.Prec]:
// specifies the precision of decimal places (total, not after the decimal point) to use in representing the number -- this helps to truncate small weird floating point values in the nether regions
func (t *Spinner) SetPrec(v int) *Spinner {
	t.Prec = v
	return t
}

// SetFormat sets the [Spinner.Format]:
// prop = format -- format string for printing the value -- blank defaults to %g.  If decimal based (ends in d, b, c, o, O, q, x, X, or U) then value is converted to decimal prior to printing
func (t *Spinner) SetFormat(v string) *Spinner {
	t.Format = v
	return t
}

// SetUpIcon sets the [Spinner.UpIcon]:
// icon to use for up button -- defaults to
func (t *Spinner) SetUpIcon(v icons.Icon) *Spinner {
	t.UpIcon = v
	return t
}

// SetDownIcon sets the [Spinner.DownIcon]:
// icon to use for down button -- defaults to
func (t *Spinner) SetDownIcon(v icons.Icon) *Spinner {
	t.DownIcon = v
	return t
}

// SetTooltip sets the [Spinner.Tooltip]
func (t *Spinner) SetTooltip(v string) *Spinner {
	t.Tooltip = v
	return t
}

// SetClass sets the [Spinner.Class]
func (t *Spinner) SetClass(v string) *Spinner {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Spinner.CustomContextMenu]
func (t *Spinner) SetCustomContextMenu(v func(m *Scene)) *Spinner {
	t.CustomContextMenu = v
	return t
}

// SplitsType is the [gti.Type] for [Splits]
var SplitsType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Splits",
	ShortName: "gi.Splits",
	IDName:    "splits",
	Doc:       "Splits allocates a fixed proportion of space to each child, along given\ndimension, always using only the available space given to it by its parent\n(i.e., it will force its children, which should be layouts (typically\nFrame's), to have their own scroll bars as necessary).  It should\ngenerally be used as a main outer-level structure within a window,\nproviding a framework for inner elements -- it allows individual child\nelements to update independently and thus is important for speeding update\nperformance.  It uses the Widget Parts to hold the splitter widgets\nseparately from the children that contain the rest of the scenegraph to be\ndisplayed within each region.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Dim", &gti.Field{Name: "Dim", Type: "goki.dev/mat32/v2.Dims", LocalType: "mat32.Dims", Doc: "dimension along which to split the space", Directives: gti.Directives{}, Tag: ""}},
		{"Splits", &gti.Field{Name: "Splits", Type: "[]float32", LocalType: "[]float32", Doc: "proportion (0-1 normalized, enforced) of space allocated to each element -- can enter 0 to collapse a given element", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"SavedSplits", &gti.Field{Name: "SavedSplits", Type: "[]float32", LocalType: "[]float32", Doc: "A saved version of the splits which can be restored -- for dynamic collapse / expand operations", Directives: gti.Directives{}, Tag: "set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Splits{},
})

// NewSplits adds a new [Splits] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSplits(par ki.Ki, name ...string) *Splits {
	return par.NewChild(SplitsType, name...).(*Splits)
}

// KiType returns the [*gti.Type] of [Splits]
func (t *Splits) KiType() *gti.Type {
	return SplitsType
}

// New returns a new [*Splits] value
func (t *Splits) New() ki.Ki {
	return &Splits{}
}

// SplitsEmbedder is an interface that all types that embed Splits satisfy
type SplitsEmbedder interface {
	AsSplits() *Splits
}

// AsSplits returns the given value as a value of type Splits if the type
// of the given value embeds Splits, or nil otherwise
func AsSplits(k ki.Ki) *Splits {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(SplitsEmbedder); ok {
		return t.AsSplits()
	}
	return nil
}

// AsSplits satisfies the [SplitsEmbedder] interface
func (t *Splits) AsSplits() *Splits {
	return t
}

// SetDim sets the [Splits.Dim]:
// dimension along which to split the space
func (t *Splits) SetDim(v mat32.Dims) *Splits {
	t.Dim = v
	return t
}

// SetTooltip sets the [Splits.Tooltip]
func (t *Splits) SetTooltip(v string) *Splits {
	t.Tooltip = v
	return t
}

// SetClass sets the [Splits.Class]
func (t *Splits) SetClass(v string) *Splits {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Splits.CustomContextMenu]
func (t *Splits) SetCustomContextMenu(v func(m *Scene)) *Splits {
	t.CustomContextMenu = v
	return t
}

// SwitchType is the [gti.Type] for [Switch]
var SwitchType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Switch",
	ShortName:  "gi.Switch",
	IDName:     "switch",
	Doc:        "Switch is a widget that can toggle between an on and off state.\nIt can be displayed as a switch, checkbox, or radio button.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Type", &gti.Field{Name: "Type", Type: "goki.dev/gi/v2/gi.SwitchTypes", LocalType: "SwitchTypes", Doc: "the type of switch that this is", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Text", &gti.Field{Name: "Text", Type: "string", LocalType: "string", Doc: "the label text for the switch", Directives: gti.Directives{}, Tag: ""}},
		{"IconOn", &gti.Field{Name: "IconOn", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "icon to use for the on, checked state of the switch", Directives: gti.Directives{}, Tag: "view:\"show-name\""}},
		{"IconOff", &gti.Field{Name: "IconOff", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "icon to use for the off, unchecked state of the switch", Directives: gti.Directives{}, Tag: "view:\"show-name\""}},
		{"IconDisab", &gti.Field{Name: "IconDisab", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "icon to use for the disabled state of the switch", Directives: gti.Directives{}, Tag: "view:\"show-name\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Switch{},
})

// NewSwitch adds a new [Switch] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSwitch(par ki.Ki, name ...string) *Switch {
	return par.NewChild(SwitchType, name...).(*Switch)
}

// KiType returns the [*gti.Type] of [Switch]
func (t *Switch) KiType() *gti.Type {
	return SwitchType
}

// New returns a new [*Switch] value
func (t *Switch) New() ki.Ki {
	return &Switch{}
}

// SetText sets the [Switch.Text]:
// the label text for the switch
func (t *Switch) SetText(v string) *Switch {
	t.Text = v
	return t
}

// SetIconOn sets the [Switch.IconOn]:
// icon to use for the on, checked state of the switch
func (t *Switch) SetIconOn(v icons.Icon) *Switch {
	t.IconOn = v
	return t
}

// SetIconOff sets the [Switch.IconOff]:
// icon to use for the off, unchecked state of the switch
func (t *Switch) SetIconOff(v icons.Icon) *Switch {
	t.IconOff = v
	return t
}

// SetIconDisab sets the [Switch.IconDisab]:
// icon to use for the disabled state of the switch
func (t *Switch) SetIconDisab(v icons.Icon) *Switch {
	t.IconDisab = v
	return t
}

// SetTooltip sets the [Switch.Tooltip]
func (t *Switch) SetTooltip(v string) *Switch {
	t.Tooltip = v
	return t
}

// SetClass sets the [Switch.Class]
func (t *Switch) SetClass(v string) *Switch {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Switch.CustomContextMenu]
func (t *Switch) SetCustomContextMenu(v func(m *Scene)) *Switch {
	t.CustomContextMenu = v
	return t
}

// SwitchesType is the [gti.Type] for [Switches]
var SwitchesType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Switches",
	ShortName: "gi.Switches",
	IDName:    "switches",
	Doc:       "Switches is a widget for containing a set of switches.\nIt can optionally enforce mutual exclusivity (i.e., Radio Buttons).\nThe buttons are all in the Parts of the widget and the Parts layout\ndetermines how they are displayed.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Type", &gti.Field{Name: "Type", Type: "goki.dev/gi/v2/gi.SwitchTypes", LocalType: "SwitchTypes", Doc: "the type of switches that will be made", Directives: gti.Directives{}, Tag: ""}},
		{"Items", &gti.Field{Name: "Items", Type: "[]string", LocalType: "[]string", Doc: "the list of items (switch labels)", Directives: gti.Directives{}, Tag: ""}},
		{"Tooltips", &gti.Field{Name: "Tooltips", Type: "[]string", LocalType: "[]string", Doc: "an optional list of tooltips displayed on hover for checkbox items; the indices for tooltips correspond to those for items", Directives: gti.Directives{}, Tag: ""}},
		{"Mutex", &gti.Field{Name: "Mutex", Type: "bool", LocalType: "bool", Doc: "whether to make the items mutually exclusive (checking one turns off all the others)", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "goki.dev/gi/v2/gi.Frame", LocalType: "Frame", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Switches{},
})

// NewSwitches adds a new [Switches] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSwitches(par ki.Ki, name ...string) *Switches {
	return par.NewChild(SwitchesType, name...).(*Switches)
}

// KiType returns the [*gti.Type] of [Switches]
func (t *Switches) KiType() *gti.Type {
	return SwitchesType
}

// New returns a new [*Switches] value
func (t *Switches) New() ki.Ki {
	return &Switches{}
}

// SwitchesEmbedder is an interface that all types that embed Switches satisfy
type SwitchesEmbedder interface {
	AsSwitches() *Switches
}

// AsSwitches returns the given value as a value of type Switches if the type
// of the given value embeds Switches, or nil otherwise
func AsSwitches(k ki.Ki) *Switches {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(SwitchesEmbedder); ok {
		return t.AsSwitches()
	}
	return nil
}

// AsSwitches satisfies the [SwitchesEmbedder] interface
func (t *Switches) AsSwitches() *Switches {
	return t
}

// SetType sets the [Switches.Type]:
// the type of switches that will be made
func (t *Switches) SetType(v SwitchTypes) *Switches {
	t.Type = v
	return t
}

// SetItems sets the [Switches.Items]:
// the list of items (switch labels)
func (t *Switches) SetItems(v []string) *Switches {
	t.Items = v
	return t
}

// SetTooltips sets the [Switches.Tooltips]:
// an optional list of tooltips displayed on hover for checkbox items; the indices for tooltips correspond to those for items
func (t *Switches) SetTooltips(v []string) *Switches {
	t.Tooltips = v
	return t
}

// SetMutex sets the [Switches.Mutex]:
// whether to make the items mutually exclusive (checking one turns off all the others)
func (t *Switches) SetMutex(v bool) *Switches {
	t.Mutex = v
	return t
}

// SetTooltip sets the [Switches.Tooltip]
func (t *Switches) SetTooltip(v string) *Switches {
	t.Tooltip = v
	return t
}

// SetClass sets the [Switches.Class]
func (t *Switches) SetClass(v string) *Switches {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Switches.CustomContextMenu]
func (t *Switches) SetCustomContextMenu(v func(m *Scene)) *Switches {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [Switches.Lay]
func (t *Switches) SetLayout(v Layouts) *Switches {
	t.Lay = v
	return t
}

// SetStackTop sets the [Switches.StackTop]
func (t *Switches) SetStackTop(v int) *Switches {
	t.StackTop = v
	return t
}

// SetStripes sets the [Switches.Stripes]
func (t *Switches) SetStripes(v Stripes) *Switches {
	t.Stripes = v
	return t
}

// TabsType is the [gti.Type] for [Tabs]
var TabsType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Tabs",
	ShortName: "gi.Tabs",
	IDName:    "tabs",
	Doc:       "Tabs switches among child widgets via tabs.  The selected widget gets\nthe full allocated space avail after the tabs are accounted for.  The\nTabs is just a Vertical layout that manages two child widgets: a\nHorizFlow Layout for the tabs (which can flow across multiple rows as\nneeded) and a Stacked Frame that actually contains all the children, and\nprovides scrollbars as needed to any content within.  Typically should have\nmax stretch and a set preferred size, so it expands.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MaxChars", &gti.Field{Name: "MaxChars", Type: "int", LocalType: "int", Doc: "maximum number of characters to include in tab label -- elides labels that are longer than that", Directives: gti.Directives{}, Tag: ""}},
		{"NewTabButton", &gti.Field{Name: "NewTabButton", Type: "bool", LocalType: "bool", Doc: "show a new tab button at right of list of tabs", Directives: gti.Directives{}, Tag: ""}},
		{"DeleteTabButtons", &gti.Field{Name: "DeleteTabButtons", Type: "bool", LocalType: "bool", Doc: "if true, tabs are user-deleteable (true by default)", Directives: gti.Directives{}, Tag: ""}},
		{"Mu", &gti.Field{Name: "Mu", Type: "sync.Mutex", LocalType: "sync.Mutex", Doc: "mutex protecting updates to tabs -- tabs can be driven programmatically and via user input so need extra protection", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "goki.dev/gi/v2/gi.Layout", LocalType: "Layout", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Tabs{},
})

// NewTabs adds a new [Tabs] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTabs(par ki.Ki, name ...string) *Tabs {
	return par.NewChild(TabsType, name...).(*Tabs)
}

// KiType returns the [*gti.Type] of [Tabs]
func (t *Tabs) KiType() *gti.Type {
	return TabsType
}

// New returns a new [*Tabs] value
func (t *Tabs) New() ki.Ki {
	return &Tabs{}
}

// TabsEmbedder is an interface that all types that embed Tabs satisfy
type TabsEmbedder interface {
	AsTabs() *Tabs
}

// AsTabs returns the given value as a value of type Tabs if the type
// of the given value embeds Tabs, or nil otherwise
func AsTabs(k ki.Ki) *Tabs {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(TabsEmbedder); ok {
		return t.AsTabs()
	}
	return nil
}

// AsTabs satisfies the [TabsEmbedder] interface
func (t *Tabs) AsTabs() *Tabs {
	return t
}

// SetMaxChars sets the [Tabs.MaxChars]:
// maximum number of characters to include in tab label -- elides labels that are longer than that
func (t *Tabs) SetMaxChars(v int) *Tabs {
	t.MaxChars = v
	return t
}

// SetNewTabButton sets the [Tabs.NewTabButton]:
// show a new tab button at right of list of tabs
func (t *Tabs) SetNewTabButton(v bool) *Tabs {
	t.NewTabButton = v
	return t
}

// SetDeleteTabButtons sets the [Tabs.DeleteTabButtons]:
// if true, tabs are user-deleteable (true by default)
func (t *Tabs) SetDeleteTabButtons(v bool) *Tabs {
	t.DeleteTabButtons = v
	return t
}

// SetTooltip sets the [Tabs.Tooltip]
func (t *Tabs) SetTooltip(v string) *Tabs {
	t.Tooltip = v
	return t
}

// SetClass sets the [Tabs.Class]
func (t *Tabs) SetClass(v string) *Tabs {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Tabs.CustomContextMenu]
func (t *Tabs) SetCustomContextMenu(v func(m *Scene)) *Tabs {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [Tabs.Lay]
func (t *Tabs) SetLayout(v Layouts) *Tabs {
	t.Lay = v
	return t
}

// SetStackTop sets the [Tabs.StackTop]
func (t *Tabs) SetStackTop(v int) *Tabs {
	t.StackTop = v
	return t
}

// TabType is the [gti.Type] for [Tab]
var TabType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Tab",
	ShortName:  "gi.Tab",
	IDName:     "tab",
	Doc:        "Tab is a tab button that contains a larger select button\nand a smaller close button. The Indicator icon is used for\nthe close icon.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"DeleteButton", &gti.Field{Name: "DeleteButton", Type: "bool", LocalType: "bool", Doc: "if true, this tab has a delete button (true by default)", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Button", &gti.Field{Name: "Button", Type: "goki.dev/gi/v2/gi.Button", LocalType: "Button", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Tab{},
})

// NewTab adds a new [Tab] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTab(par ki.Ki, name ...string) *Tab {
	return par.NewChild(TabType, name...).(*Tab)
}

// KiType returns the [*gti.Type] of [Tab]
func (t *Tab) KiType() *gti.Type {
	return TabType
}

// New returns a new [*Tab] value
func (t *Tab) New() ki.Ki {
	return &Tab{}
}

// SetDeleteButton sets the [Tab.DeleteButton]:
// if true, this tab has a delete button (true by default)
func (t *Tab) SetDeleteButton(v bool) *Tab {
	t.DeleteButton = v
	return t
}

// SetTooltip sets the [Tab.Tooltip]
func (t *Tab) SetTooltip(v string) *Tab {
	t.Tooltip = v
	return t
}

// SetClass sets the [Tab.Class]
func (t *Tab) SetClass(v string) *Tab {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Tab.CustomContextMenu]
func (t *Tab) SetCustomContextMenu(v func(m *Scene)) *Tab {
	t.CustomContextMenu = v
	return t
}

// SetType sets the [Tab.Type]
func (t *Tab) SetType(v ButtonTypes) *Tab {
	t.Type = v
	return t
}

// SetText sets the [Tab.Text]
func (t *Tab) SetText(v string) *Tab {
	t.Text = v
	return t
}

// SetIcon sets the [Tab.Icon]
func (t *Tab) SetIcon(v icons.Icon) *Tab {
	t.Icon = v
	return t
}

// SetIndicator sets the [Tab.Indicator]
func (t *Tab) SetIndicator(v icons.Icon) *Tab {
	t.Indicator = v
	return t
}

// SetShortcut sets the [Tab.Shortcut]
func (t *Tab) SetShortcut(v key.Chord) *Tab {
	t.Shortcut = v
	return t
}

// SetMenu sets the [Tab.Menu]
func (t *Tab) SetMenu(v func(m *Scene)) *Tab {
	t.Menu = v
	return t
}

// SetData sets the [Tab.Data]
func (t *Tab) SetData(v any) *Tab {
	t.Data = v
	return t
}

// SetUpdateFunc sets the [Tab.UpdateFunc]
func (t *Tab) SetUpdateFunc(v func()) *Tab {
	t.UpdateFunc = v
	return t
}

// TextFieldType is the [gti.Type] for [TextField]
var TextFieldType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.TextField",
	ShortName: "gi.TextField",
	IDName:    "text-field",
	Doc:       "TextField is a widget for editing a line of text",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Txt", &gti.Field{Name: "Txt", Type: "string", LocalType: "string", Doc: "the last saved value of the text string being edited", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"text\" set:\"-\""}},
		{"Placeholder", &gti.Field{Name: "Placeholder", Type: "string", LocalType: "string", Doc: "text that is displayed when the field is empty, in a lower-contrast manner", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"placeholder\""}},
		{"Complete", &gti.Field{Name: "Complete", Type: "*goki.dev/gi/v2/gi.Complete", LocalType: "*Complete", Doc: "functions and data for textfield completion", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\""}},
		{"NoEcho", &gti.Field{Name: "NoEcho", Type: "bool", LocalType: "bool", Doc: "replace displayed characters with bullets to conceal text", Directives: gti.Directives{}, Tag: ""}},
		{"LeadingIcon", &gti.Field{Name: "LeadingIcon", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "if specified, a button will be added at the start of the text field with this icon", Directives: gti.Directives{}, Tag: ""}},
		{"TrailingIcon", &gti.Field{Name: "TrailingIcon", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "if specified, a button will be added at the end of the text field with this icon", Directives: gti.Directives{}, Tag: ""}},
		{"CursorWidth", &gti.Field{Name: "CursorWidth", Type: "goki.dev/girl/units.Value", LocalType: "units.Value", Doc: "width of cursor -- set from cursor-width property (inherited)", Directives: gti.Directives{}, Tag: "xml:\"cursor-width\""}},
		{"Type", &gti.Field{Name: "Type", Type: "goki.dev/gi/v2/gi.TextFieldTypes", LocalType: "TextFieldTypes", Doc: "the type of the text field", Directives: gti.Directives{}, Tag: ""}},
		{"PlaceholderColor", &gti.Field{Name: "PlaceholderColor", Type: "image/color.RGBA", LocalType: "color.RGBA", Doc: "the color used for the placeholder text; this should be set in Stylers like all other style properties; it is typically a highlighted version of the normal text color", Directives: gti.Directives{}, Tag: ""}},
		{"SelectColor", &gti.Field{Name: "SelectColor", Type: "goki.dev/colors.Full", LocalType: "colors.Full", Doc: "the color used for the text selection background color on active text fields; this should be set in Stylers like all other style properties", Directives: gti.Directives{}, Tag: ""}},
		{"CursorColor", &gti.Field{Name: "CursorColor", Type: "goki.dev/colors.Full", LocalType: "colors.Full", Doc: "the color used for the text field cursor (caret); this should be set in Stylers like all other style properties", Directives: gti.Directives{}, Tag: ""}},
		{"Edited", &gti.Field{Name: "Edited", Type: "bool", LocalType: "bool", Doc: "true if the text has been edited relative to the original", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" set:\"-\""}},
		{"EditTxt", &gti.Field{Name: "EditTxt", Type: "[]rune", LocalType: "[]rune", Doc: "the live text string being edited, with latest modifications -- encoded as runes", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" set:\"-\""}},
		{"MaxWidthReq", &gti.Field{Name: "MaxWidthReq", Type: "int", LocalType: "int", Doc: "maximum width that field will request, in characters, during GetSize process -- if 0 then is 50 -- ensures that large strings don't request super large values -- standard max-width can override", Directives: gti.Directives{}, Tag: ""}},
		{"EffPos", &gti.Field{Name: "EffPos", Type: "goki.dev/mat32/v2.Vec2", LocalType: "mat32.Vec2", Doc: "effective position with any leading icon space added", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"EffSize", &gti.Field{Name: "EffSize", Type: "goki.dev/mat32/v2.Vec2", LocalType: "mat32.Vec2", Doc: "effective size, subtracting any leading and trailing icon space", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"StartPos", &gti.Field{Name: "StartPos", Type: "int", LocalType: "int", Doc: "starting display position in the string", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"EndPos", &gti.Field{Name: "EndPos", Type: "int", LocalType: "int", Doc: "ending display position in the string", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"CursorPos", &gti.Field{Name: "CursorPos", Type: "int", LocalType: "int", Doc: "current cursor position", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"CharWidth", &gti.Field{Name: "CharWidth", Type: "int", LocalType: "int", Doc: "approximate number of chars that can be displayed at any time -- computed from font size etc", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"SelectStart", &gti.Field{Name: "SelectStart", Type: "int", LocalType: "int", Doc: "starting position of selection in the string", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"SelectEnd", &gti.Field{Name: "SelectEnd", Type: "int", LocalType: "int", Doc: "ending position of selection in the string", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"SelectInit", &gti.Field{Name: "SelectInit", Type: "int", LocalType: "int", Doc: "initial selection position -- where it started", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"SelectMode", &gti.Field{Name: "SelectMode", Type: "bool", LocalType: "bool", Doc: "if true, select text as cursor moves", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\""}},
		{"RenderAll", &gti.Field{Name: "RenderAll", Type: "goki.dev/girl/paint.Text", LocalType: "paint.Text", Doc: "render version of entire text, for sizing", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"RenderVis", &gti.Field{Name: "RenderVis", Type: "goki.dev/girl/paint.Text", LocalType: "paint.Text", Doc: "render version of just visible text", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"FontHeight", &gti.Field{Name: "FontHeight", Type: "float32", LocalType: "float32", Doc: "font height, cached during styling", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"BlinkOn", &gti.Field{Name: "BlinkOn", Type: "bool", LocalType: "bool", Doc: "oscillates between on and off for blinking", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"CursorMu", &gti.Field{Name: "CursorMu", Type: "sync.Mutex", LocalType: "sync.Mutex", Doc: "mutex for updating cursor between blinker and field", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TextField{},
})

// NewTextField adds a new [TextField] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTextField(par ki.Ki, name ...string) *TextField {
	return par.NewChild(TextFieldType, name...).(*TextField)
}

// KiType returns the [*gti.Type] of [TextField]
func (t *TextField) KiType() *gti.Type {
	return TextFieldType
}

// New returns a new [*TextField] value
func (t *TextField) New() ki.Ki {
	return &TextField{}
}

// TextFieldEmbedder is an interface that all types that embed TextField satisfy
type TextFieldEmbedder interface {
	AsTextField() *TextField
}

// AsTextField returns the given value as a value of type TextField if the type
// of the given value embeds TextField, or nil otherwise
func AsTextField(k ki.Ki) *TextField {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(TextFieldEmbedder); ok {
		return t.AsTextField()
	}
	return nil
}

// AsTextField satisfies the [TextFieldEmbedder] interface
func (t *TextField) AsTextField() *TextField {
	return t
}

// SetPlaceholder sets the [TextField.Placeholder]:
// text that is displayed when the field is empty, in a lower-contrast manner
func (t *TextField) SetPlaceholder(v string) *TextField {
	t.Placeholder = v
	return t
}

// SetComplete sets the [TextField.Complete]:
// functions and data for textfield completion
func (t *TextField) SetComplete(v *Complete) *TextField {
	t.Complete = v
	return t
}

// SetNoEcho sets the [TextField.NoEcho]:
// replace displayed characters with bullets to conceal text
func (t *TextField) SetNoEcho(v bool) *TextField {
	t.NoEcho = v
	return t
}

// SetLeadingIcon sets the [TextField.LeadingIcon]:
// if specified, a button will be added at the start of the text field with this icon
func (t *TextField) SetLeadingIcon(v icons.Icon) *TextField {
	t.LeadingIcon = v
	return t
}

// SetTrailingIcon sets the [TextField.TrailingIcon]:
// if specified, a button will be added at the end of the text field with this icon
func (t *TextField) SetTrailingIcon(v icons.Icon) *TextField {
	t.TrailingIcon = v
	return t
}

// SetCursorWidth sets the [TextField.CursorWidth]:
// width of cursor -- set from cursor-width property (inherited)
func (t *TextField) SetCursorWidth(v units.Value) *TextField {
	t.CursorWidth = v
	return t
}

// SetType sets the [TextField.Type]:
// the type of the text field
func (t *TextField) SetType(v TextFieldTypes) *TextField {
	t.Type = v
	return t
}

// SetPlaceholderColor sets the [TextField.PlaceholderColor]:
// the color used for the placeholder text; this should be set in Stylers like all other style properties; it is typically a highlighted version of the normal text color
func (t *TextField) SetPlaceholderColor(v color.RGBA) *TextField {
	t.PlaceholderColor = v
	return t
}

// SetSelectColor sets the [TextField.SelectColor]:
// the color used for the text selection background color on active text fields; this should be set in Stylers like all other style properties
func (t *TextField) SetSelectColor(v colors.Full) *TextField {
	t.SelectColor = v
	return t
}

// SetCursorColor sets the [TextField.CursorColor]:
// the color used for the text field cursor (caret); this should be set in Stylers like all other style properties
func (t *TextField) SetCursorColor(v colors.Full) *TextField {
	t.CursorColor = v
	return t
}

// SetMaxWidthReq sets the [TextField.MaxWidthReq]:
// maximum width that field will request, in characters, during GetSize process -- if 0 then is 50 -- ensures that large strings don't request super large values -- standard max-width can override
func (t *TextField) SetMaxWidthReq(v int) *TextField {
	t.MaxWidthReq = v
	return t
}

// SetSelectMode sets the [TextField.SelectMode]:
// if true, select text as cursor moves
func (t *TextField) SetSelectMode(v bool) *TextField {
	t.SelectMode = v
	return t
}

// SetTooltip sets the [TextField.Tooltip]
func (t *TextField) SetTooltip(v string) *TextField {
	t.Tooltip = v
	return t
}

// SetClass sets the [TextField.Class]
func (t *TextField) SetClass(v string) *TextField {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [TextField.CustomContextMenu]
func (t *TextField) SetCustomContextMenu(v func(m *Scene)) *TextField {
	t.CustomContextMenu = v
	return t
}

// ToolbarType is the [gti.Type] for [Toolbar]
var ToolbarType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Toolbar",
	ShortName: "gi.Toolbar",
	IDName:    "toolbar",
	Doc:       "Toolbar is a [Frame] that is useful for holding [Button]s that do things.\nIt automatically moves items that do not fit into an overflow menu, and\nmanages additional items that are always placed onto this overflow menu.\nSet the Scene.TopAppBar to a toolbar function\nIn general it should be possible to use a single toolbar + overflow to\nmanage all an app's functionality, in a way that is portable across\nmobile and desktop environments.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"OverflowItems", &gti.Field{Name: "OverflowItems", Type: "goki.dev/ki/v2.Slice", LocalType: "ki.Slice", Doc: "items moved from the main toolbar, will be shown in the overflow menu", Directives: gti.Directives{}, Tag: "set:\"-\" json:\"-\" xml:\"-\""}},
		{"OverflowMenus", &gti.Field{Name: "OverflowMenus", Type: "[]func(m *goki.dev/gi/v2/gi.Scene)", LocalType: "[]func(m *Scene)", Doc: "functions for overflow menu: use AddOverflowMenu to add.\nThese are processed in _reverse_ order (last in, first called)\nso that the default items are added last.", Directives: gti.Directives{}, Tag: "set:\"-\" json:\"-\" xml:\"-\""}},
		{"OverflowButton", &gti.Field{Name: "OverflowButton", Type: "*goki.dev/gi/v2/gi.Button", LocalType: "*Button", Doc: "This is the overflow button", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "goki.dev/gi/v2/gi.Frame", LocalType: "Frame", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Toolbar{},
})

// NewToolbar adds a new [Toolbar] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewToolbar(par ki.Ki, name ...string) *Toolbar {
	return par.NewChild(ToolbarType, name...).(*Toolbar)
}

// KiType returns the [*gti.Type] of [Toolbar]
func (t *Toolbar) KiType() *gti.Type {
	return ToolbarType
}

// New returns a new [*Toolbar] value
func (t *Toolbar) New() ki.Ki {
	return &Toolbar{}
}

// ToolbarEmbedder is an interface that all types that embed Toolbar satisfy
type ToolbarEmbedder interface {
	AsToolbar() *Toolbar
}

// AsToolbar returns the given value as a value of type Toolbar if the type
// of the given value embeds Toolbar, or nil otherwise
func AsToolbar(k ki.Ki) *Toolbar {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(ToolbarEmbedder); ok {
		return t.AsToolbar()
	}
	return nil
}

// AsToolbar satisfies the [ToolbarEmbedder] interface
func (t *Toolbar) AsToolbar() *Toolbar {
	return t
}

// SetOverflowButton sets the [Toolbar.OverflowButton]:
// This is the overflow button
func (t *Toolbar) SetOverflowButton(v *Button) *Toolbar {
	t.OverflowButton = v
	return t
}

// SetTooltip sets the [Toolbar.Tooltip]
func (t *Toolbar) SetTooltip(v string) *Toolbar {
	t.Tooltip = v
	return t
}

// SetClass sets the [Toolbar.Class]
func (t *Toolbar) SetClass(v string) *Toolbar {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Toolbar.CustomContextMenu]
func (t *Toolbar) SetCustomContextMenu(v func(m *Scene)) *Toolbar {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [Toolbar.Lay]
func (t *Toolbar) SetLayout(v Layouts) *Toolbar {
	t.Lay = v
	return t
}

// SetStackTop sets the [Toolbar.StackTop]
func (t *Toolbar) SetStackTop(v int) *Toolbar {
	t.StackTop = v
	return t
}

// SetStripes sets the [Toolbar.Stripes]
func (t *Toolbar) SetStripes(v Stripes) *Toolbar {
	t.Stripes = v
	return t
}

// WidgetBaseType is the [gti.Type] for [WidgetBase]
var WidgetBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.WidgetBase",
	ShortName:  "gi.WidgetBase",
	IDName:     "widget-base",
	Doc:        "WidgetBase is the base type for all Widget Widget elements, which are\nmanaged by a containing Layout, and use all 5 rendering passes.  All\nelemental widgets must support the ReadOnly and Selected states in a\nreasonable way (Selected only essential when also ReadOnly), so they can\nfunction appropriately in a chooser (e.g., SliceView or TableView) -- this\nincludes toggling selection on left mouse press.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Tooltip", &gti.Field{Name: "Tooltip", Type: "string", LocalType: "string", Doc: "text for the tooltip for this widget, which can use HTML formatting", Directives: gti.Directives{}, Tag: ""}},
		{"Class", &gti.Field{Name: "Class", Type: "string", LocalType: "string", Doc: "user-defined class name(s) used primarily for attaching CSS styles to different display elements -- multiple class names can be used to combine properties: use spaces to separate per css standard", Directives: gti.Directives{}, Tag: ""}},
		{"CSS", &gti.Field{Name: "CSS", Type: "goki.dev/ki/v2.Props", LocalType: "ki.Props", Doc: "cascading style sheet at this level -- these styles apply here and to everything below, until superceded -- use .class and #name Props elements to apply entire styles to given elements, and type for element type", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"CSSAgg", &gti.Field{Name: "CSSAgg", Type: "goki.dev/ki/v2.Props", LocalType: "ki.Props", Doc: "aggregated css properties from all higher nodes down to me", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"no-inline\" set:\"-\""}},
		{"BBox", &gti.Field{Name: "BBox", Type: "image.Rectangle", LocalType: "image.Rectangle", Doc: "raw original bounding box for the widget within its parent Scene -- used for computing ScBBox.  This is not updated by LayoutScroll, whereas ScBBox is", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"ObjBBox", &gti.Field{Name: "ObjBBox", Type: "image.Rectangle", LocalType: "image.Rectangle", Doc: "full object bbox -- this is BBox + LayoutScroll delta, but NOT intersected with parent's parBBox -- used for computing color gradients or other object-specific geometry computations", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"ScBBox", &gti.Field{Name: "ScBBox", Type: "image.Rectangle", LocalType: "image.Rectangle", Doc: "2D bounding box for region occupied within immediate parent Scene object that we render onto. These are the pixels we draw into, filtered through parent bounding boxes. Used for render Bounds clipping", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"OnWidgetAdders", &gti.Field{Name: "OnWidgetAdders", Type: "[]func(w goki.dev/gi/v2/gi.Widget)", LocalType: "[]func(w Widget)", Doc: "A slice of functions to call on all widgets that are added as children to this widget or its children.\nThese functions are called in sequential ascending order, so the last added one is called\nlast and thus can override anything set by the other ones. These should be set using\nOnWidgetAdded, which can be called by both end-user and internal code.", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"Stylers", &gti.Field{Name: "Stylers", Type: "[]func(s *goki.dev/girl/styles.Style)", LocalType: "[]func(s *styles.Style)", Doc: "a slice of stylers that are called in sequential ascending order (so the last added styler is called last and thus overrides all other functions) to style the element; these should be set using Style, which can be called by end-user and internal code", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"OverrideStyle", &gti.Field{Name: "OverrideStyle", Type: "bool", LocalType: "bool", Doc: "override the computed styles and allow directly editing Style", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"Styles", &gti.Field{Name: "Styles", Type: "goki.dev/girl/styles.Style", LocalType: "styles.Style", Doc: "styling settings for this widget -- set in SetApplyStyle during an initialization step, and when the structure changes; they are determined by, in increasing priority order, the default values, the ki node properties, and the StyleFunc (the recommended way to set styles is through the StyleFunc -- setting this field directly outside of that will have no effect unless OverrideStyle is on)", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"Listeners", &gti.Field{Name: "Listeners", Type: "goki.dev/goosi/events.Listeners", LocalType: "events.Listeners", Doc: "Listeners are event listener functions for processing events on this widget.\ntype specific Listeners are added in OnInit when the widget is initialized.", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"Parts", &gti.Field{Name: "Parts", Type: "*goki.dev/gi/v2/gi.Layout", LocalType: "*Layout", Doc: "a separate tree of sub-widgets that implement discrete parts of a widget -- positions are always relative to the parent widget -- fully managed by the widget and not saved", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view-closed:\"true\" set:\"-\""}},
		{"LayState", &gti.Field{Name: "LayState", Type: "goki.dev/gi/v2/gi.LayoutState", LocalType: "LayoutState", Doc: "all the layout state information for this widget", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"CustomContextMenu", &gti.Field{Name: "CustomContextMenu", Type: "func(m *goki.dev/gi/v2/gi.Scene)", LocalType: "func(m *Scene)", Doc: "an optional context menu constructor function called by [Widget.MakeContextMenu] after any type-specified items are added.\nThis function can decide where to insert new elements, and it should typically add a separator to disambiguate.", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\""}},
		{"Sc", &gti.Field{Name: "Sc", Type: "*goki.dev/gi/v2/gi.Scene", LocalType: "*Scene", Doc: "parent scene.  Only for use as a last resort when arg is not available -- otherwise always use the arg.  Set during Config.", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"StyMu", &gti.Field{Name: "StyMu", Type: "sync.RWMutex", LocalType: "sync.RWMutex", Doc: "mutex protecting the Style field", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"BBoxMu", &gti.Field{Name: "BBoxMu", Type: "sync.RWMutex", LocalType: "sync.RWMutex", Doc: "mutex protecting the BBox fields", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Node", &gti.Field{Name: "Node", Type: "goki.dev/ki/v2.Node", LocalType: "ki.Node", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &WidgetBase{},
})

// NewWidgetBase adds a new [WidgetBase] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewWidgetBase(par ki.Ki, name ...string) *WidgetBase {
	return par.NewChild(WidgetBaseType, name...).(*WidgetBase)
}

// KiType returns the [*gti.Type] of [WidgetBase]
func (t *WidgetBase) KiType() *gti.Type {
	return WidgetBaseType
}

// New returns a new [*WidgetBase] value
func (t *WidgetBase) New() ki.Ki {
	return &WidgetBase{}
}

// SetTooltip sets the [WidgetBase.Tooltip]:
// text for the tooltip for this widget, which can use HTML formatting
func (t *WidgetBase) SetTooltip(v string) *WidgetBase {
	t.Tooltip = v
	return t
}

// SetClass sets the [WidgetBase.Class]:
// user-defined class name(s) used primarily for attaching CSS styles to different display elements -- multiple class names can be used to combine properties: use spaces to separate per css standard
func (t *WidgetBase) SetClass(v string) *WidgetBase {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [WidgetBase.CustomContextMenu]:
// an optional context menu constructor function called by [Widget.MakeContextMenu] after any type-specified items are added.
// This function can decide where to insert new elements, and it should typically add a separator to disambiguate.
func (t *WidgetBase) SetCustomContextMenu(v func(m *Scene)) *WidgetBase {
	t.CustomContextMenu = v
	return t
}

var _ = gti.AddFunc(&gti.Func{
	Name: "goki.dev/gi/v2/gi.DefaultTopAppBar",
	Doc:  "DefaultTopAppBar is the default value for [Scene.TopAppBar].\nIt adds navigation buttons and an editable chooser bar,\nand calls AddDefaultOverflowMenu to provide default menu items,\nwhich will appear below any other OverflowMenu items added.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"tb", &gti.Field{Name: "tb", Type: "*goki.dev/gi/v2/gi.Toolbar", LocalType: "*Toolbar", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
})
