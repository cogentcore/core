// Code generated by "goki generate"; DO NOT EDIT.

package gi

import (
	"image"
	"image/color"
	"time"

	"goki.dev/events"
	"goki.dev/events/key"
	"goki.dev/fi/uri"
	"goki.dev/gti"
	"goki.dev/icons"
	"goki.dev/ki"
	"goki.dev/mat32"
	"goki.dev/pi/complete"
	"goki.dev/styles"
	"goki.dev/units"
)

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.App", IDName: "app", Doc: "App encapsulates various properties of the overall application,\nincluding managing an AppBar and associated elements.", Directives: []gti.Directive{{Tool: "gti", Directive: "add", Args: []string{"-setters"}}}, Fields: []gti.Field{{Name: "Name", Doc: "Name can be used in relevant window titles and prompts,\nand specifies the default application-specific data directory"}, {Name: "About", Doc: "About sets the 'about' info for the app, which appears as a menu option\nin the default app menu."}, {Name: "Icon", Doc: "Icon specifies the app icon, which is passed to [goosi.Window.SetIcon].\nIt should typically be set using [App.SetIconSVG]."}, {Name: "AppBarConfig", Doc: "AppBarConfig is the function that configures the AppBar,\ntypically put in the [Scene.Bars.Top] (i.e., a TopAppBar).\nSet to StdAppBarConfig by default, which makes the standard AppBar behavior.\nMost apps will define their own version to add App-specific\nfunctionality, and set this accordingly.\nIf this is nil, then no TopAppBar will be created by default."}}})

// SetName sets the [App.Name]:
// Name can be used in relevant window titles and prompts,
// and specifies the default application-specific data directory
func (t *App) SetName(v string) *App { t.Name = v; return t }

// SetAbout sets the [App.About]:
// About sets the 'about' info for the app, which appears as a menu option
// in the default app menu.
func (t *App) SetAbout(v string) *App { t.About = v; return t }

// SetIcon sets the [App.Icon]:
// Icon specifies the app icon, which is passed to [goosi.Window.SetIcon].
// It should typically be set using [App.SetIconSVG].
func (t *App) SetIcon(v ...image.Image) *App { t.Icon = v; return t }

// SetAppBarConfig sets the [App.AppBarConfig]:
// AppBarConfig is the function that configures the AppBar,
// typically put in the [Scene.Bars.Top] (i.e., a TopAppBar).
// Set to StdAppBarConfig by default, which makes the standard AppBar behavior.
// Most apps will define their own version to add App-specific
// functionality, and set this accordingly.
// If this is nil, then no TopAppBar will be created by default.
func (t *App) SetAppBarConfig(v func(pw Widget)) *App { t.AppBarConfig = v; return t }

// AppChooserType is the [gti.Type] for [AppChooser]
var AppChooserType = gti.AddType(&gti.Type{Name: "goki.dev/gi.AppChooser", IDName: "app-chooser", Doc: "AppChooser is an editable chooser element, typically placed at the start\nof the TopAppBar, that provides direct access to all manner of app resources.", Embeds: []gti.Field{{Name: "Chooser"}}, Fields: []gti.Field{{Name: "Resources", Doc: "Resources are generators for resources accessible by the AppChooser"}}, Instance: &AppChooser{}})

// NewAppChooser adds a new [AppChooser] with the given name to the given parent:
// AppChooser is an editable chooser element, typically placed at the start
// of the TopAppBar, that provides direct access to all manner of app resources.
func NewAppChooser(par ki.Ki, name ...string) *AppChooser {
	return par.NewChild(AppChooserType, name...).(*AppChooser)
}

// KiType returns the [*gti.Type] of [AppChooser]
func (t *AppChooser) KiType() *gti.Type { return AppChooserType }

// New returns a new [*AppChooser] value
func (t *AppChooser) New() ki.Ki { return &AppChooser{} }

// SetResources sets the [AppChooser.Resources]:
// Resources are generators for resources accessible by the AppChooser
func (t *AppChooser) SetResources(v uri.Resources) *AppChooser { t.Resources = v; return t }

// SetTooltip sets the [AppChooser.Tooltip]
func (t *AppChooser) SetTooltip(v string) *AppChooser { t.Tooltip = v; return t }

// SetType sets the [AppChooser.Type]
func (t *AppChooser) SetType(v ChooserTypes) *AppChooser { t.Type = v; return t }

// SetIcon sets the [AppChooser.Icon]
func (t *AppChooser) SetIcon(v icons.Icon) *AppChooser { t.Icon = v; return t }

// SetIndicator sets the [AppChooser.Indicator]
func (t *AppChooser) SetIndicator(v icons.Icon) *AppChooser { t.Indicator = v; return t }

// SetEditable sets the [AppChooser.Editable]
func (t *AppChooser) SetEditable(v bool) *AppChooser { t.Editable = v; return t }

// SetAllowNew sets the [AppChooser.AllowNew]
func (t *AppChooser) SetAllowNew(v bool) *AppChooser { t.AllowNew = v; return t }

// SetItems sets the [AppChooser.Items]
func (t *AppChooser) SetItems(v ...any) *AppChooser { t.Items = v; return t }

// SetLabels sets the [AppChooser.Labels]
func (t *AppChooser) SetLabels(v ...string) *AppChooser { t.Labels = v; return t }

// SetIcons sets the [AppChooser.Icons]
func (t *AppChooser) SetIcons(v ...icons.Icon) *AppChooser { t.Icons = v; return t }

// SetTooltips sets the [AppChooser.Tooltips]
func (t *AppChooser) SetTooltips(v ...string) *AppChooser { t.Tooltips = v; return t }

// SetMaxLength sets the [AppChooser.MaxLength]
func (t *AppChooser) SetMaxLength(v int) *AppChooser { t.MaxLength = v; return t }

// SetItemsFunc sets the [AppChooser.ItemsFunc]
func (t *AppChooser) SetItemsFunc(v func()) *AppChooser { t.ItemsFunc = v; return t }

// BodyType is the [gti.Type] for [Body]
var BodyType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Body", IDName: "body", Doc: "Body holds the primary content of a Scene", Directives: []gti.Directive{{Tool: "goki", Directive: "no-new"}}, Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "Title", Doc: "title of the Body, also used for window title where relevant"}}, Instance: &Body{}})

// KiType returns the [*gti.Type] of [Body]
func (t *Body) KiType() *gti.Type { return BodyType }

// New returns a new [*Body] value
func (t *Body) New() ki.Ki { return &Body{} }

// SetTitle sets the [Body.Title]:
// title of the Body, also used for window title where relevant
func (t *Body) SetTitle(v string) *Body { t.Title = v; return t }

// SetTooltip sets the [Body.Tooltip]
func (t *Body) SetTooltip(v string) *Body { t.Tooltip = v; return t }

// SetStackTop sets the [Body.StackTop]
func (t *Body) SetStackTop(v int) *Body { t.StackTop = v; return t }

// SetStripes sets the [Body.Stripes]
func (t *Body) SetStripes(v Stripes) *Body { t.Stripes = v; return t }

// BoxType is the [gti.Type] for [Box]
var BoxType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Box", IDName: "box", Doc: "Box is a simple base [Widget] that renders the Std Box model", Embeds: []gti.Field{{Name: "WidgetBase"}}, Instance: &Box{}})

// NewBox adds a new [Box] with the given name to the given parent:
// Box is a simple base [Widget] that renders the Std Box model
func NewBox(par ki.Ki, name ...string) *Box {
	return par.NewChild(BoxType, name...).(*Box)
}

// KiType returns the [*gti.Type] of [Box]
func (t *Box) KiType() *gti.Type { return BoxType }

// New returns a new [*Box] value
func (t *Box) New() ki.Ki { return &Box{} }

// SetTooltip sets the [Box.Tooltip]
func (t *Box) SetTooltip(v string) *Box { t.Tooltip = v; return t }

// ButtonType is the [gti.Type] for [Button]
var ButtonType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Button", IDName: "button", Doc: "Button is a pressable button with text, an icon, an indicator, a shortcut,\nand/or a menu. The standard behavior is to register a click event with OnClick(...).", Directives: []gti.Directive{{Tool: "goki", Directive: "embedder"}}, Embeds: []gti.Field{{Name: "Box"}}, Fields: []gti.Field{{Name: "Type", Doc: "the type of button"}, {Name: "Text", Doc: "Text is the label text for the button.\nIf it is blank, no label is shown."}, {Name: "Icon", Doc: "Icon is the icon for the button.\nIf it is \"\" or [icons.None], no icon is shown."}, {Name: "Indicator", Doc: "Indicator is the menu indicator icon to present.\nIf it is \"\" or [icons.None],, no indicator is shown.\nIt is automatically set to [icons.KeyboardArrowDown]\nwhen there is a Menu elements present unless it is\nset to [icons.None]."}, {Name: "Shortcut", Doc: "Shortcut is an optional shortcut keyboard chord to trigger this button,\nactive in window-wide scope. Avoid conflicts with other shortcuts\n(a log message will be emitted if so). Shortcuts are processed after\nall other processing of keyboard input. Use Command for\nControl / Meta (Mac Command key) per platform."}, {Name: "Menu", Doc: "Menu is a menu constructor function used to build and display\na menu whenever the button is clicked. There will be no menu\nif it is nil. The constructor function should add buttons\nto the Scene that it is passed."}, {Name: "Data", Doc: "Data is optional data that can be used for event handling"}}, Instance: &Button{}})

// NewButton adds a new [Button] with the given name to the given parent:
// Button is a pressable button with text, an icon, an indicator, a shortcut,
// and/or a menu. The standard behavior is to register a click event with OnClick(...).
func NewButton(par ki.Ki, name ...string) *Button {
	return par.NewChild(ButtonType, name...).(*Button)
}

// KiType returns the [*gti.Type] of [Button]
func (t *Button) KiType() *gti.Type { return ButtonType }

// New returns a new [*Button] value
func (t *Button) New() ki.Ki { return &Button{} }

// ButtonEmbedder is an interface that all types that embed Button satisfy
type ButtonEmbedder interface {
	AsButton() *Button
}

// AsButton returns the given value as a value of type Button if the type
// of the given value embeds Button, or nil otherwise
func AsButton(k ki.Ki) *Button {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(ButtonEmbedder); ok {
		return t.AsButton()
	}
	return nil
}

// AsButton satisfies the [ButtonEmbedder] interface
func (t *Button) AsButton() *Button { return t }

// SetType sets the [Button.Type]:
// the type of button
func (t *Button) SetType(v ButtonTypes) *Button { t.Type = v; return t }

// SetIcon sets the [Button.Icon]:
// Icon is the icon for the button.
// If it is "" or [icons.None], no icon is shown.
func (t *Button) SetIcon(v icons.Icon) *Button { t.Icon = v; return t }

// SetIndicator sets the [Button.Indicator]:
// Indicator is the menu indicator icon to present.
// If it is "" or [icons.None],, no indicator is shown.
// It is automatically set to [icons.KeyboardArrowDown]
// when there is a Menu elements present unless it is
// set to [icons.None].
func (t *Button) SetIndicator(v icons.Icon) *Button { t.Indicator = v; return t }

// SetShortcut sets the [Button.Shortcut]:
// Shortcut is an optional shortcut keyboard chord to trigger this button,
// active in window-wide scope. Avoid conflicts with other shortcuts
// (a log message will be emitted if so). Shortcuts are processed after
// all other processing of keyboard input. Use Command for
// Control / Meta (Mac Command key) per platform.
func (t *Button) SetShortcut(v key.Chord) *Button { t.Shortcut = v; return t }

// SetMenu sets the [Button.Menu]:
// Menu is a menu constructor function used to build and display
// a menu whenever the button is clicked. There will be no menu
// if it is nil. The constructor function should add buttons
// to the Scene that it is passed.
func (t *Button) SetMenu(v func(m *Scene)) *Button { t.Menu = v; return t }

// SetData sets the [Button.Data]:
// Data is optional data that can be used for event handling
func (t *Button) SetData(v any) *Button { t.Data = v; return t }

// SetTooltip sets the [Button.Tooltip]
func (t *Button) SetTooltip(v string) *Button { t.Tooltip = v; return t }

// CanvasType is the [gti.Type] for [Canvas]
var CanvasType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Canvas", IDName: "canvas", Doc: "Canvas is a widget that can be arbitrarily drawn to.", Embeds: []gti.Field{{Name: "WidgetBase"}}, Fields: []gti.Field{{Name: "Context", Doc: "Context is the paint context that we use for drawing."}}, Instance: &Canvas{}})

// NewCanvas adds a new [Canvas] with the given name to the given parent:
// Canvas is a widget that can be arbitrarily drawn to.
func NewCanvas(par ki.Ki, name ...string) *Canvas {
	return par.NewChild(CanvasType, name...).(*Canvas)
}

// KiType returns the [*gti.Type] of [Canvas]
func (t *Canvas) KiType() *gti.Type { return CanvasType }

// New returns a new [*Canvas] value
func (t *Canvas) New() ki.Ki { return &Canvas{} }

// SetTooltip sets the [Canvas.Tooltip]
func (t *Canvas) SetTooltip(v string) *Canvas { t.Tooltip = v; return t }

// ChooserType is the [gti.Type] for [Chooser]
var ChooserType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Chooser", IDName: "chooser", Doc: "Chooser is for selecting items from a dropdown list, with an optional\nedit TextField for typing directly.\nThe items can be of any type, including enum values -- they are converted\nto strings for the display.  If the items are of type [icons.Icon], then they\nare displayed using icons instead.", Embeds: []gti.Field{{Name: "Box"}}, Fields: []gti.Field{{Name: "Type", Doc: "the type of combo box"}, {Name: "Icon", Doc: "optional icon"}, {Name: "Indicator", Doc: "name of the indicator icon to present."}, {Name: "Editable", Doc: "provide a text field for editing the value, or just a button for selecting items?  Set the editable property"}, {Name: "AllowNew", Doc: "whether to allow the user to add new items to the combo box through the editable textfield (if Editable is set to true) and a button at the end of the combo box menu"}, {Name: "Items", Doc: "items available for selection"}, {Name: "Labels", Doc: "an optional list of labels displayed for Chooser items;\nthe indices for the labels correspond to those for the items"}, {Name: "Icons", Doc: "an optional list of icons displayed for Chooser items;\nthe indices for the icons correspond to those for the items"}, {Name: "Tooltips", Doc: "an optional list of tooltips displayed on hover for Chooser items;\nthe indices for the tooltips correspond to those for the items"}, {Name: "Placeholder", Doc: "if Editable is set to true, text that is displayed in the text field when it is empty, in a lower-contrast manner"}, {Name: "MaxLength", Doc: "maximum label length (in runes)"}, {Name: "ItemsFunc", Doc: "ItemsFunc, if non-nil, is a function to call before showing the items\nof the chooser, which is typically used to configure them (eg: if they\nare based on dynamic data)"}, {Name: "CurLabel", Doc: "CurLabel is the string label for the current value"}, {Name: "CurVal", Doc: "current selected value"}, {Name: "CurIndex", Doc: "current index in list of possible items"}}, Instance: &Chooser{}})

// NewChooser adds a new [Chooser] with the given name to the given parent:
// Chooser is for selecting items from a dropdown list, with an optional
// edit TextField for typing directly.
// The items can be of any type, including enum values -- they are converted
// to strings for the display.  If the items are of type [icons.Icon], then they
// are displayed using icons instead.
func NewChooser(par ki.Ki, name ...string) *Chooser {
	return par.NewChild(ChooserType, name...).(*Chooser)
}

// KiType returns the [*gti.Type] of [Chooser]
func (t *Chooser) KiType() *gti.Type { return ChooserType }

// New returns a new [*Chooser] value
func (t *Chooser) New() ki.Ki { return &Chooser{} }

// SetType sets the [Chooser.Type]:
// the type of combo box
func (t *Chooser) SetType(v ChooserTypes) *Chooser { t.Type = v; return t }

// SetIcon sets the [Chooser.Icon]:
// optional icon
func (t *Chooser) SetIcon(v icons.Icon) *Chooser { t.Icon = v; return t }

// SetIndicator sets the [Chooser.Indicator]:
// name of the indicator icon to present.
func (t *Chooser) SetIndicator(v icons.Icon) *Chooser { t.Indicator = v; return t }

// SetEditable sets the [Chooser.Editable]:
// provide a text field for editing the value, or just a button for selecting items?  Set the editable property
func (t *Chooser) SetEditable(v bool) *Chooser { t.Editable = v; return t }

// SetAllowNew sets the [Chooser.AllowNew]:
// whether to allow the user to add new items to the combo box through the editable textfield (if Editable is set to true) and a button at the end of the combo box menu
func (t *Chooser) SetAllowNew(v bool) *Chooser { t.AllowNew = v; return t }

// SetItems sets the [Chooser.Items]:
// items available for selection
func (t *Chooser) SetItems(v ...any) *Chooser { t.Items = v; return t }

// SetLabels sets the [Chooser.Labels]:
// an optional list of labels displayed for Chooser items;
// the indices for the labels correspond to those for the items
func (t *Chooser) SetLabels(v ...string) *Chooser { t.Labels = v; return t }

// SetIcons sets the [Chooser.Icons]:
// an optional list of icons displayed for Chooser items;
// the indices for the icons correspond to those for the items
func (t *Chooser) SetIcons(v ...icons.Icon) *Chooser { t.Icons = v; return t }

// SetTooltips sets the [Chooser.Tooltips]:
// an optional list of tooltips displayed on hover for Chooser items;
// the indices for the tooltips correspond to those for the items
func (t *Chooser) SetTooltips(v ...string) *Chooser { t.Tooltips = v; return t }

// SetMaxLength sets the [Chooser.MaxLength]:
// maximum label length (in runes)
func (t *Chooser) SetMaxLength(v int) *Chooser { t.MaxLength = v; return t }

// SetItemsFunc sets the [Chooser.ItemsFunc]:
// ItemsFunc, if non-nil, is a function to call before showing the items
// of the chooser, which is typically used to configure them (eg: if they
// are based on dynamic data)
func (t *Chooser) SetItemsFunc(v func()) *Chooser { t.ItemsFunc = v; return t }

// SetTooltip sets the [Chooser.Tooltip]
func (t *Chooser) SetTooltip(v string) *Chooser { t.Tooltip = v; return t }

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.Complete", IDName: "complete", Doc: "Complete holds the current completion data and functions to call for building\nthe list of possible completions and for editing text after a completion is selected.\nIt also holds the [PopupStage] associated with it.", Directives: []gti.Directive{{Tool: "gti", Directive: "add", Args: []string{"-setters"}}}, Fields: []gti.Field{{Name: "MatchFunc", Doc: "function to get the list of possible completions"}, {Name: "LookupFunc", Doc: "function to get the text to show for lookup"}, {Name: "EditFunc", Doc: "function to edit text using the selected completion"}, {Name: "Context", Doc: "the object that implements complete.Func"}, {Name: "SrcLn", Doc: "line number in source that completion is operating on, if relevant"}, {Name: "SrcCh", Doc: "character position in source that completion is operating on"}, {Name: "Completions", Doc: "the list of potential completions"}, {Name: "Seed", Doc: "current completion seed"}, {Name: "Completion", Doc: "the user's completion selection"}, {Name: "Listeners", Doc: "the event listeners for the completer (it sends Select events)"}, {Name: "Stage", Doc: "Stage is the [PopupStage] associated with the [Complete]"}, {Name: "DelayTimer"}, {Name: "DelayMu"}, {Name: "ShowMu"}}})

// SetMatchFunc sets the [Complete.MatchFunc]:
// function to get the list of possible completions
func (t *Complete) SetMatchFunc(v complete.MatchFunc) *Complete { t.MatchFunc = v; return t }

// SetLookupFunc sets the [Complete.LookupFunc]:
// function to get the text to show for lookup
func (t *Complete) SetLookupFunc(v complete.LookupFunc) *Complete { t.LookupFunc = v; return t }

// SetEditFunc sets the [Complete.EditFunc]:
// function to edit text using the selected completion
func (t *Complete) SetEditFunc(v complete.EditFunc) *Complete { t.EditFunc = v; return t }

// SetContext sets the [Complete.Context]:
// the object that implements complete.Func
func (t *Complete) SetContext(v any) *Complete { t.Context = v; return t }

// SetSrcLn sets the [Complete.SrcLn]:
// line number in source that completion is operating on, if relevant
func (t *Complete) SetSrcLn(v int) *Complete { t.SrcLn = v; return t }

// SetSrcCh sets the [Complete.SrcCh]:
// character position in source that completion is operating on
func (t *Complete) SetSrcCh(v int) *Complete { t.SrcCh = v; return t }

// SetCompletions sets the [Complete.Completions]:
// the list of potential completions
func (t *Complete) SetCompletions(v complete.Completions) *Complete { t.Completions = v; return t }

// SetSeed sets the [Complete.Seed]:
// current completion seed
func (t *Complete) SetSeed(v string) *Complete { t.Seed = v; return t }

// SetCompletion sets the [Complete.Completion]:
// the user's completion selection
func (t *Complete) SetCompletion(v string) *Complete { t.Completion = v; return t }

// SetStage sets the [Complete.Stage]:
// Stage is the [PopupStage] associated with the [Complete]
func (t *Complete) SetStage(v *Stage) *Complete { t.Stage = v; return t }

// FrameType is the [gti.Type] for [Frame]
var FrameType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Frame", IDName: "frame", Doc: "Frame is a Layout that renders a background according to the\nbackground-color style setting, and optional striping for grid layouts", Embeds: []gti.Field{{Name: "Layout"}}, Fields: []gti.Field{{Name: "Stripes", Doc: "options for striped backgrounds -- rendered as darker bands relative to background color"}}, Instance: &Frame{}})

// NewFrame adds a new [Frame] with the given name to the given parent:
// Frame is a Layout that renders a background according to the
// background-color style setting, and optional striping for grid layouts
func NewFrame(par ki.Ki, name ...string) *Frame {
	return par.NewChild(FrameType, name...).(*Frame)
}

// KiType returns the [*gti.Type] of [Frame]
func (t *Frame) KiType() *gti.Type { return FrameType }

// New returns a new [*Frame] value
func (t *Frame) New() ki.Ki { return &Frame{} }

// SetStripes sets the [Frame.Stripes]:
// options for striped backgrounds -- rendered as darker bands relative to background color
func (t *Frame) SetStripes(v Stripes) *Frame { t.Stripes = v; return t }

// SetTooltip sets the [Frame.Tooltip]
func (t *Frame) SetTooltip(v string) *Frame { t.Tooltip = v; return t }

// SetStackTop sets the [Frame.StackTop]
func (t *Frame) SetStackTop(v int) *Frame { t.StackTop = v; return t }

// HandleType is the [gti.Type] for [Handle]
var HandleType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Handle", IDName: "handle", Doc: "Handle represents a draggable handle that can be used to\ncontrol the size of an element. The [Handle.Styles.Direction]\ncontrols the direction in which the handle moves.", Embeds: []gti.Field{{Name: "Box"}}, Fields: []gti.Field{{Name: "Min", Doc: "Min is the minimum value that the handle can go to\n(typically the lower bound of the dialog/splits)"}, {Name: "Max", Doc: "Max is the maximum value that the handle can go to\n(typically the upper bound of the dialog/splits)"}, {Name: "Pos", Doc: "Pos is the current position of the handle on the\nscale of [Handle.Min] to [Handle.Max]"}}, Instance: &Handle{}})

// NewHandle adds a new [Handle] with the given name to the given parent:
// Handle represents a draggable handle that can be used to
// control the size of an element. The [Handle.Styles.Direction]
// controls the direction in which the handle moves.
func NewHandle(par ki.Ki, name ...string) *Handle {
	return par.NewChild(HandleType, name...).(*Handle)
}

// KiType returns the [*gti.Type] of [Handle]
func (t *Handle) KiType() *gti.Type { return HandleType }

// New returns a new [*Handle] value
func (t *Handle) New() ki.Ki { return &Handle{} }

// SetMin sets the [Handle.Min]:
// Min is the minimum value that the handle can go to
// (typically the lower bound of the dialog/splits)
func (t *Handle) SetMin(v float32) *Handle { t.Min = v; return t }

// SetMax sets the [Handle.Max]:
// Max is the maximum value that the handle can go to
// (typically the upper bound of the dialog/splits)
func (t *Handle) SetMax(v float32) *Handle { t.Max = v; return t }

// SetPos sets the [Handle.Pos]:
// Pos is the current position of the handle on the
// scale of [Handle.Min] to [Handle.Max]
func (t *Handle) SetPos(v float32) *Handle { t.Pos = v; return t }

// SetTooltip sets the [Handle.Tooltip]
func (t *Handle) SetTooltip(v string) *Handle { t.Tooltip = v; return t }

// IconType is the [gti.Type] for [Icon]
var IconType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Icon", IDName: "icon", Doc: "Icon contains a svg.SVG element.\nThe rendered version is cached for a given size.\nIcons do not render a background or border independent of their SVG object.", Embeds: []gti.Field{{Name: "WidgetBase"}}, Fields: []gti.Field{{Name: "Icon", Doc: "icon name that has been set."}, {Name: "Filename", Doc: "file name for the loaded icon, if loaded"}, {Name: "SVG", Doc: "SVG drawing of the icon"}}, Instance: &Icon{}})

// NewIcon adds a new [Icon] with the given name to the given parent:
// Icon contains a svg.SVG element.
// The rendered version is cached for a given size.
// Icons do not render a background or border independent of their SVG object.
func NewIcon(par ki.Ki, name ...string) *Icon {
	return par.NewChild(IconType, name...).(*Icon)
}

// KiType returns the [*gti.Type] of [Icon]
func (t *Icon) KiType() *gti.Type { return IconType }

// New returns a new [*Icon] value
func (t *Icon) New() ki.Ki { return &Icon{} }

// SetTooltip sets the [Icon.Tooltip]
func (t *Icon) SetTooltip(v string) *Icon { t.Tooltip = v; return t }

// ImageType is the [gti.Type] for [Image]
var ImageType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Image", IDName: "image", Doc: "Image is a Widget that renders a static bitmap image.\nSee [Styles.ObjectFits] for how to control the image rendering within\nthe allocated size.  The minimum requested size is the pixel size in\nDp units (1/160th of an inch).", Embeds: []gti.Field{{Name: "WidgetBase"}}, Fields: []gti.Field{{Name: "Filename", Doc: "file name of image loaded -- set by OpenImage"}, {Name: "Pixels", Doc: "the bitmap image"}, {Name: "PrevPixels", Doc: "cached last rendered image"}, {Name: "PrevObjectFit", Doc: "cached [styles.Style.ObjectFit] of the last rendered image"}, {Name: "PrevSize", Doc: "cached allocated size for the last rendered image"}}, Instance: &Image{}})

// NewImage adds a new [Image] with the given name to the given parent:
// Image is a Widget that renders a static bitmap image.
// See [Styles.ObjectFits] for how to control the image rendering within
// the allocated size.  The minimum requested size is the pixel size in
// Dp units (1/160th of an inch).
func NewImage(par ki.Ki, name ...string) *Image {
	return par.NewChild(ImageType, name...).(*Image)
}

// KiType returns the [*gti.Type] of [Image]
func (t *Image) KiType() *gti.Type { return ImageType }

// New returns a new [*Image] value
func (t *Image) New() ki.Ki { return &Image{} }

// SetTooltip sets the [Image.Tooltip]
func (t *Image) SetTooltip(v string) *Image { t.Tooltip = v; return t }

// LabelType is the [gti.Type] for [Label]
var LabelType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Label", IDName: "label", Doc: "Label is a widget for rendering text labels -- supports full widget model\nincluding box rendering, and full HTML styling, including links -- LinkSig\nemits link with data of URL -- opens default browser if nobody receiving\nsignal.  The default white-space option is 'pre' -- set to 'normal' or\nother options to get word-wrapping etc.", Directives: []gti.Directive{{Tool: "goki", Directive: "embedder"}}, Embeds: []gti.Field{{Name: "WidgetBase"}}, Fields: []gti.Field{{Name: "Text", Doc: "label to display"}, {Name: "Type", Doc: "the type of label"}, {Name: "TextRender", Doc: "render data for text label"}}, Instance: &Label{}})

// NewLabel adds a new [Label] with the given name to the given parent:
// Label is a widget for rendering text labels -- supports full widget model
// including box rendering, and full HTML styling, including links -- LinkSig
// emits link with data of URL -- opens default browser if nobody receiving
// signal.  The default white-space option is 'pre' -- set to 'normal' or
// other options to get word-wrapping etc.
func NewLabel(par ki.Ki, name ...string) *Label {
	return par.NewChild(LabelType, name...).(*Label)
}

// KiType returns the [*gti.Type] of [Label]
func (t *Label) KiType() *gti.Type { return LabelType }

// New returns a new [*Label] value
func (t *Label) New() ki.Ki { return &Label{} }

// LabelEmbedder is an interface that all types that embed Label satisfy
type LabelEmbedder interface {
	AsLabel() *Label
}

// AsLabel returns the given value as a value of type Label if the type
// of the given value embeds Label, or nil otherwise
func AsLabel(k ki.Ki) *Label {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(LabelEmbedder); ok {
		return t.AsLabel()
	}
	return nil
}

// AsLabel satisfies the [LabelEmbedder] interface
func (t *Label) AsLabel() *Label { return t }

// SetText sets the [Label.Text]:
// label to display
func (t *Label) SetText(v string) *Label { t.Text = v; return t }

// SetType sets the [Label.Type]:
// the type of label
func (t *Label) SetType(v LabelTypes) *Label { t.Type = v; return t }

// SetTooltip sets the [Label.Tooltip]
func (t *Label) SetTooltip(v string) *Label { t.Tooltip = v; return t }

// LabeledTextFieldType is the [gti.Type] for [LabeledTextField]
var LabeledTextFieldType = gti.AddType(&gti.Type{Name: "goki.dev/gi.LabeledTextField", IDName: "labeled-text-field", Doc: "LabeledTextField is a [Label] with optional associated label,\nhint, and error text.", Embeds: []gti.Field{{Name: "TextField"}}, Fields: []gti.Field{{Name: "Label", Doc: "Label is the label for the text field"}, {Name: "HintText", Doc: "HintText is the hint text for the text field"}, {Name: "ErrorText", Doc: "ErrorText is the error text for the text field.\nIf it is specified, it will be shown instead of\n[LabeledTextField.HintText]."}}, Instance: &LabeledTextField{}})

// NewLabeledTextField adds a new [LabeledTextField] with the given name to the given parent:
// LabeledTextField is a [Label] with optional associated label,
// hint, and error text.
func NewLabeledTextField(par ki.Ki, name ...string) *LabeledTextField {
	return par.NewChild(LabeledTextFieldType, name...).(*LabeledTextField)
}

// KiType returns the [*gti.Type] of [LabeledTextField]
func (t *LabeledTextField) KiType() *gti.Type { return LabeledTextFieldType }

// New returns a new [*LabeledTextField] value
func (t *LabeledTextField) New() ki.Ki { return &LabeledTextField{} }

// SetLabel sets the [LabeledTextField.Label]:
// Label is the label for the text field
func (t *LabeledTextField) SetLabel(v string) *LabeledTextField { t.Label = v; return t }

// SetHintText sets the [LabeledTextField.HintText]:
// HintText is the hint text for the text field
func (t *LabeledTextField) SetHintText(v string) *LabeledTextField { t.HintText = v; return t }

// SetErrorText sets the [LabeledTextField.ErrorText]:
// ErrorText is the error text for the text field.
// If it is specified, it will be shown instead of
// [LabeledTextField.HintText].
func (t *LabeledTextField) SetErrorText(v string) *LabeledTextField { t.ErrorText = v; return t }

// SetTooltip sets the [LabeledTextField.Tooltip]
func (t *LabeledTextField) SetTooltip(v string) *LabeledTextField { t.Tooltip = v; return t }

// SetPlaceholder sets the [LabeledTextField.Placeholder]
func (t *LabeledTextField) SetPlaceholder(v string) *LabeledTextField { t.Placeholder = v; return t }

// SetComplete sets the [LabeledTextField.Complete]
func (t *LabeledTextField) SetComplete(v *Complete) *LabeledTextField { t.Complete = v; return t }

// SetNoEcho sets the [LabeledTextField.NoEcho]
func (t *LabeledTextField) SetNoEcho(v bool) *LabeledTextField { t.NoEcho = v; return t }

// SetLeadingIconOnClick sets the [LabeledTextField.LeadingIconOnClick]
func (t *LabeledTextField) SetLeadingIconOnClick(v func(e events.Event)) *LabeledTextField {
	t.LeadingIconOnClick = v
	return t
}

// SetTrailingIconOnClick sets the [LabeledTextField.TrailingIconOnClick]
func (t *LabeledTextField) SetTrailingIconOnClick(v func(e events.Event)) *LabeledTextField {
	t.TrailingIconOnClick = v
	return t
}

// SetCursorWidth sets the [LabeledTextField.CursorWidth]
func (t *LabeledTextField) SetCursorWidth(v units.Value) *LabeledTextField {
	t.CursorWidth = v
	return t
}

// SetType sets the [LabeledTextField.Type]
func (t *LabeledTextField) SetType(v TextFieldTypes) *LabeledTextField { t.Type = v; return t }

// SetPlaceholderColor sets the [LabeledTextField.PlaceholderColor]
func (t *LabeledTextField) SetPlaceholderColor(v color.RGBA) *LabeledTextField {
	t.PlaceholderColor = v
	return t
}

// SetSelectColor sets the [LabeledTextField.SelectColor]
func (t *LabeledTextField) SetSelectColor(v image.Image) *LabeledTextField {
	t.SelectColor = v
	return t
}

// SetCursorColor sets the [LabeledTextField.CursorColor]
func (t *LabeledTextField) SetCursorColor(v image.Image) *LabeledTextField {
	t.CursorColor = v
	return t
}

// SetMaxWidthReq sets the [LabeledTextField.MaxWidthReq]
func (t *LabeledTextField) SetMaxWidthReq(v int) *LabeledTextField { t.MaxWidthReq = v; return t }

// SetSelectMode sets the [LabeledTextField.SelectMode]
func (t *LabeledTextField) SetSelectMode(v bool) *LabeledTextField { t.SelectMode = v; return t }

// LayoutType is the [gti.Type] for [Layout]
var LayoutType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Layout", IDName: "layout", Doc: "Layout is the primary node type responsible for organizing the sizes\nand positions of child widgets. It does not render, only organize,\nso properties like background color will have no effect.\nAll arbitrary collections of widgets should generally be contained\nwithin a layout -- otherwise the parent widget must take over\nresponsibility for positioning.\nLayouts can automatically add scrollbars depending on the Overflow\nlayout style.\nFor a Grid layout, the 'columns' property should generally be set\nto the desired number of columns, from which the number of rows\nis computed -- otherwise it uses the square root of number of\nelements.", Embeds: []gti.Field{{Name: "WidgetBase"}}, Fields: []gti.Field{{Name: "StackTop", Doc: "for Stacked layout, index of node to use as the top of the stack.\nOnly the node at this index is rendered -- if not a valid index, nothing is rendered."}, {Name: "LayImpl", Doc: "LayImpl contains implementational state info for doing layout"}, {Name: "HasScroll", Doc: "whether scrollbar is used for given dim"}, {Name: "Scrolls", Doc: "scroll bars -- we fully manage them as needed"}, {Name: "FocusName", Doc: "accumulated name to search for when keys are typed"}, {Name: "FocusNameTime", Doc: "time of last focus name event -- for timeout"}, {Name: "FocusNameLast", Doc: "last element focused on -- used as a starting point if name is the same"}}, Instance: &Layout{}})

// NewLayout adds a new [Layout] with the given name to the given parent:
// Layout is the primary node type responsible for organizing the sizes
// and positions of child widgets. It does not render, only organize,
// so properties like background color will have no effect.
// All arbitrary collections of widgets should generally be contained
// within a layout -- otherwise the parent widget must take over
// responsibility for positioning.
// Layouts can automatically add scrollbars depending on the Overflow
// layout style.
// For a Grid layout, the 'columns' property should generally be set
// to the desired number of columns, from which the number of rows
// is computed -- otherwise it uses the square root of number of
// elements.
func NewLayout(par ki.Ki, name ...string) *Layout {
	return par.NewChild(LayoutType, name...).(*Layout)
}

// KiType returns the [*gti.Type] of [Layout]
func (t *Layout) KiType() *gti.Type { return LayoutType }

// New returns a new [*Layout] value
func (t *Layout) New() ki.Ki { return &Layout{} }

// SetStackTop sets the [Layout.StackTop]:
// for Stacked layout, index of node to use as the top of the stack.
// Only the node at this index is rendered -- if not a valid index, nothing is rendered.
func (t *Layout) SetStackTop(v int) *Layout { t.StackTop = v; return t }

// SetTooltip sets the [Layout.Tooltip]
func (t *Layout) SetTooltip(v string) *Layout { t.Tooltip = v; return t }

// StretchType is the [gti.Type] for [Stretch]
var StretchType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Stretch", IDName: "stretch", Doc: "Stretch adds an infinitely stretchy element for spacing out layouts\n(max-size = -1) set the width / height property to determine how much it\ntakes relative to other stretchy elements", Embeds: []gti.Field{{Name: "WidgetBase"}}, Instance: &Stretch{}})

// NewStretch adds a new [Stretch] with the given name to the given parent:
// Stretch adds an infinitely stretchy element for spacing out layouts
// (max-size = -1) set the width / height property to determine how much it
// takes relative to other stretchy elements
func NewStretch(par ki.Ki, name ...string) *Stretch {
	return par.NewChild(StretchType, name...).(*Stretch)
}

// KiType returns the [*gti.Type] of [Stretch]
func (t *Stretch) KiType() *gti.Type { return StretchType }

// New returns a new [*Stretch] value
func (t *Stretch) New() ki.Ki { return &Stretch{} }

// SetTooltip sets the [Stretch.Tooltip]
func (t *Stretch) SetTooltip(v string) *Stretch { t.Tooltip = v; return t }

// SpaceType is the [gti.Type] for [Space]
var SpaceType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Space", IDName: "space", Doc: "Space adds a fixed sized (1 ch x 1 em by default) blank space to a layout.\nSet width / height property to change.", Embeds: []gti.Field{{Name: "WidgetBase"}}, Instance: &Space{}})

// NewSpace adds a new [Space] with the given name to the given parent:
// Space adds a fixed sized (1 ch x 1 em by default) blank space to a layout.
// Set width / height property to change.
func NewSpace(par ki.Ki, name ...string) *Space {
	return par.NewChild(SpaceType, name...).(*Space)
}

// KiType returns the [*gti.Type] of [Space]
func (t *Space) KiType() *gti.Type { return SpaceType }

// New returns a new [*Space] value
func (t *Space) New() ki.Ki { return &Space{} }

// SetTooltip sets the [Space.Tooltip]
func (t *Space) SetTooltip(v string) *Space { t.Tooltip = v; return t }

// MeterType is the [gti.Type] for [Meter]
var MeterType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Meter", IDName: "meter", Doc: "Meter is a widget that renders a current value on as a filled bar\nrelative to a minimum and maximum potential value.", Embeds: []gti.Field{{Name: "WidgetBase"}}, Fields: []gti.Field{{Name: "Value", Doc: "Value is the current value of the meter"}, {Name: "Min", Doc: "Min is the minimum possible value of the meter"}, {Name: "Max", Doc: "Max is the maximum possible value of the meter"}, {Name: "ValueColor", Doc: "ValueColor is the image color that will be used to\nrender the filled value bar. It should be set in Style."}}, Instance: &Meter{}})

// NewMeter adds a new [Meter] with the given name to the given parent:
// Meter is a widget that renders a current value on as a filled bar
// relative to a minimum and maximum potential value.
func NewMeter(par ki.Ki, name ...string) *Meter {
	return par.NewChild(MeterType, name...).(*Meter)
}

// KiType returns the [*gti.Type] of [Meter]
func (t *Meter) KiType() *gti.Type { return MeterType }

// New returns a new [*Meter] value
func (t *Meter) New() ki.Ki { return &Meter{} }

// SetValue sets the [Meter.Value]:
// Value is the current value of the meter
func (t *Meter) SetValue(v float32) *Meter { t.Value = v; return t }

// SetMin sets the [Meter.Min]:
// Min is the minimum possible value of the meter
func (t *Meter) SetMin(v float32) *Meter { t.Min = v; return t }

// SetMax sets the [Meter.Max]:
// Max is the maximum possible value of the meter
func (t *Meter) SetMax(v float32) *Meter { t.Max = v; return t }

// SetValueColor sets the [Meter.ValueColor]:
// ValueColor is the image color that will be used to
// render the filled value bar. It should be set in Style.
func (t *Meter) SetValueColor(v image.Image) *Meter { t.ValueColor = v; return t }

// SetTooltip sets the [Meter.Tooltip]
func (t *Meter) SetTooltip(v string) *Meter { t.Tooltip = v; return t }

// SceneType is the [gti.Type] for [Scene]
var SceneType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Scene", IDName: "scene", Doc: "Scene contains a Widget tree, rooted in an embedded Frame layout,\nwhich renders into its Pixels image.\nThe Scene is set in a Stage (pointer retained in Scene).\nStage has a StageMgr manager for controlling things like Popups\n(Menus and Dialogs, etc).\n\nEach Scene and Widget tree contains state specific to its particular usage\nwithin a given Stage and overall rendering context, representing the unit\nof rendering in the GoGi framework.", Directives: []gti.Directive{{Tool: "goki", Directive: "no-new"}, {Tool: "goki", Directive: "embedder"}}, Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "App", Doc: "App is the pointer to the application to which this scene belongs.\nThe first Main Window Scene must set this, and others will automatically\ngrab from there."}, {Name: "Bars", Doc: "Bars contains functions for constructing the control bars for this Scene,\nattached to different sides of a Scene (e.g., TopAppBar at Top,\nNavBar at Bottom, etc).  Functions are called in forward order\nso first added are called first."}, {Name: "BarsInherit", Doc: "BarsInherit determines which of the Bars side functions are inherited\nfrom the context widget, for FullWindow Dialogs"}, {Name: "AppBars", Doc: "AppBars contains functions for configuring a top-level App toolbar,\n(e.g., TopAppBar) for elements contained within this Scene,\nthat should be represented in any app-level toolbar constructed\nfor this Scene."}, {Name: "Body", Doc: "Body provides the main contents of scenes that use control Bars\nto allow the main window contents to be specified separately\nfrom that dynamic control content.  When constructing scenes using\na Body, you can operate directly on the [Body], which has wrappers\nfor most major Scene functions."}, {Name: "Data", Doc: "Data is the optional data value being represented by this scene.\nUsed e.g., for recycling views of a given item instead of creating new one."}, {Name: "SceneGeom", Doc: "Size and position relative to overall rendering context."}, {Name: "PaintContext", Doc: "paint context for rendering"}, {Name: "Pixels", Doc: "live pixels that we render into"}, {Name: "EventMgr", Doc: "event manager for this scene"}, {Name: "Stage", Doc: "current stage in which this Scene is set"}, {Name: "RenderBBoxHue", Doc: "RenderBBoxHue is current hue for rendering bounding box in ScRenderBBoxes mode"}, {Name: "SelectedWidget", Doc: "the currently selected widget through the inspect editor selection mode"}, {Name: "SelectedWidgetChan", Doc: "the channel on which the selected widget through the inspect editor\nselection mode is transmitted to the inspect editor after the user is done selecting"}, {Name: "LastRender", Doc: "LastRender captures key params from last render.\nIf different then a new ApplyStyleScene is needed."}, {Name: "StyleMu", Doc: "StyleMu is RW mutex protecting access to Style-related global vars"}, {Name: "ShowIter", Doc: "ShowIter counts up at start of showing a Scene\nto trigger Show event and other steps at start of first show"}, {Name: "ReRender", Doc: "ReRender items are re-rendered after the current pass"}}, Instance: &Scene{}})

// KiType returns the [*gti.Type] of [Scene]
func (t *Scene) KiType() *gti.Type { return SceneType }

// New returns a new [*Scene] value
func (t *Scene) New() ki.Ki { return &Scene{} }

// SceneEmbedder is an interface that all types that embed Scene satisfy
type SceneEmbedder interface {
	AsScene() *Scene
}

// AsScene returns the given value as a value of type Scene if the type
// of the given value embeds Scene, or nil otherwise
func AsScene(k ki.Ki) *Scene {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(SceneEmbedder); ok {
		return t.AsScene()
	}
	return nil
}

// AsScene satisfies the [SceneEmbedder] interface
func (t *Scene) AsScene() *Scene { return t }

// SetApp sets the [Scene.App]:
// App is the pointer to the application to which this scene belongs.
// The first Main Window Scene must set this, and others will automatically
// grab from there.
func (t *Scene) SetApp(v *App) *Scene { t.App = v; return t }

// SetBars sets the [Scene.Bars]:
// Bars contains functions for constructing the control bars for this Scene,
// attached to different sides of a Scene (e.g., TopAppBar at Top,
// NavBar at Bottom, etc).  Functions are called in forward order
// so first added are called first.
func (t *Scene) SetBars(v styles.Sides[BarFuncs]) *Scene { t.Bars = v; return t }

// SetBarsInherit sets the [Scene.BarsInherit]:
// BarsInherit determines which of the Bars side functions are inherited
// from the context widget, for FullWindow Dialogs
func (t *Scene) SetBarsInherit(v styles.Sides[bool]) *Scene { t.BarsInherit = v; return t }

// SetAppBars sets the [Scene.AppBars]:
// AppBars contains functions for configuring a top-level App toolbar,
// (e.g., TopAppBar) for elements contained within this Scene,
// that should be represented in any app-level toolbar constructed
// for this Scene.
func (t *Scene) SetAppBars(v ToolbarFuncs) *Scene { t.AppBars = v; return t }

// SetBody sets the [Scene.Body]:
// Body provides the main contents of scenes that use control Bars
// to allow the main window contents to be specified separately
// from that dynamic control content.  When constructing scenes using
// a Body, you can operate directly on the [Body], which has wrappers
// for most major Scene functions.
func (t *Scene) SetBody(v *Body) *Scene { t.Body = v; return t }

// SetData sets the [Scene.Data]:
// Data is the optional data value being represented by this scene.
// Used e.g., for recycling views of a given item instead of creating new one.
func (t *Scene) SetData(v any) *Scene { t.Data = v; return t }

// SetSelectedWidget sets the [Scene.SelectedWidget]:
// the currently selected widget through the inspect editor selection mode
func (t *Scene) SetSelectedWidget(v Widget) *Scene { t.SelectedWidget = v; return t }

// SetSelectedWidgetChan sets the [Scene.SelectedWidgetChan]:
// the channel on which the selected widget through the inspect editor
// selection mode is transmitted to the inspect editor after the user is done selecting
func (t *Scene) SetSelectedWidgetChan(v chan Widget) *Scene { t.SelectedWidgetChan = v; return t }

// SetReRender sets the [Scene.ReRender]:
// ReRender items are re-rendered after the current pass
func (t *Scene) SetReRender(v ...Widget) *Scene { t.ReRender = v; return t }

// SetTooltip sets the [Scene.Tooltip]
func (t *Scene) SetTooltip(v string) *Scene { t.Tooltip = v; return t }

// SetStackTop sets the [Scene.StackTop]
func (t *Scene) SetStackTop(v int) *Scene { t.StackTop = v; return t }

// SetStripes sets the [Scene.Stripes]
func (t *Scene) SetStripes(v Stripes) *Scene { t.Stripes = v; return t }

// SeparatorType is the [gti.Type] for [Separator]
var SeparatorType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Separator", IDName: "separator", Doc: "Separator draws a vertical or horizontal line", Embeds: []gti.Field{{Name: "Box"}}, Fields: []gti.Field{{Name: "Dim", Doc: "Dim is the dimension the separator goes along (X means it goes longer horizontally, etc)"}}, Instance: &Separator{}})

// NewSeparator adds a new [Separator] with the given name to the given parent:
// Separator draws a vertical or horizontal line
func NewSeparator(par ki.Ki, name ...string) *Separator {
	return par.NewChild(SeparatorType, name...).(*Separator)
}

// KiType returns the [*gti.Type] of [Separator]
func (t *Separator) KiType() *gti.Type { return SeparatorType }

// New returns a new [*Separator] value
func (t *Separator) New() ki.Ki { return &Separator{} }

// SetDim sets the [Separator.Dim]:
// Dim is the dimension the separator goes along (X means it goes longer horizontally, etc)
func (t *Separator) SetDim(v mat32.Dims) *Separator { t.Dim = v; return t }

// SetTooltip sets the [Separator.Tooltip]
func (t *Separator) SetTooltip(v string) *Separator { t.Tooltip = v; return t }

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.AppearanceSettingsData", IDName: "appearance-settings-data", Doc: "AppearanceSettingsData is the data type for the global Goki appearance settings.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Methods: []gti.Method{{Name: "Apply", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "SaveZoom", Doc: "SaveZoom saves the current LogicalDPI scaling, either as the overall\ndefault or specific to the current screen. If for current screen is true,\nit saves only for the current screen.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Args: []string{"forCurrentScreen"}}, {Name: "DeleteSavedWindowGeoms", Doc: "DeleteSavedWindowGeoms deletes the file that saves the position and size of\neach window, by screen, and clear current in-memory cache. You shouldn't generally\nneed to do this, but sometimes it is useful for testing or windows that are\nshowing up in bad places that you can't recover from.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}}, Embeds: []gti.Field{{Name: "SettingsBase"}}, Fields: []gti.Field{{Name: "Theme", Doc: "the color theme"}, {Name: "Color", Doc: "the primary color used to generate the color scheme"}, {Name: "Zoom", Doc: "overall zoom factor as a percentage of the default zoom"}, {Name: "Spacing", Doc: "the overall spacing factor as a percentage of the default amount of spacing\n(higher numbers lead to more space and lower numbers lead to higher density)"}, {Name: "FontSize", Doc: "the overall font size factor applied to all text as a percentage\nof the default font size (higher numbers lead to larger text)"}, {Name: "Screens", Doc: "screen-specific preferences, which will override overall defaults if set"}, {Name: "HiStyle", Doc: "text highlighting style / theme"}, {Name: "FontFamily", Doc: "default font family when otherwise not specified"}, {Name: "MonoFont", Doc: "default mono-spaced font family"}, {Name: "TBConfig", Doc: "toolbar configuration function -- set in giv -- allows use of FuncButton"}}})

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.DeviceSettingsData", IDName: "device-settings-data", Doc: "DeviceSettingsData is the data type for the device settings.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Embeds: []gti.Field{{Name: "SettingsBase"}}, Fields: []gti.Field{{Name: "KeyMap", Doc: "The keyboard shortcut map to use"}, {Name: "KeyMaps", Doc: "The keyboard shortcut maps available as options for Key map.\nIf you do not want to have custom key maps, you should leave\nthis unset so that you always have the latest standard key maps."}, {Name: "DoubleClickInterval", Doc: "The maximum time interval between button press events to count as a double-click"}, {Name: "ScrollWheelSpeed", Doc: "How fast the scroll wheel moves, which is typically pixels per wheel step\nbut units can be arbitrary. It is generally impossible to standardize speed\nand variable across devices, and we don't have access to the system settings,\nso unfortunately you have to set it here."}, {Name: "DragStartTime", Doc: "The amount of time to wait before initiating a slide/drag event\n(as opposed to a basic press event)"}, {Name: "DragStartDistance", Doc: "The number of pixels that must be moved before initiating a slide/drag\nevent (as opposed to a basic press event)"}, {Name: "LongHoverTime", Doc: "The amount of time to wait before initiating a long hover event (e.g., for opening a tooltip)"}, {Name: "LongHoverStopDistance", Doc: "The maximum number of pixels that mouse can move and still register a long hover event"}, {Name: "LongPressTime", Doc: "The amount of time to wait before initiating a long press event (e.g., for opening a tooltip)"}, {Name: "LongPressStopDistance", Doc: "The maximum number of pixels that mouse/finger can move and still register a long press event"}}})

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.ScreenSettings", IDName: "screen-settings", Doc: "ScreenSettings are the per-screen preferences -- see [goosi.App.Screen] for\ninfo on the different screens -- these prefs are indexed by the Screen.Name\n-- settings here override those in the global preferences.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Fields: []gti.Field{{Name: "Zoom", Doc: "overall zoom factor as a percentage of the default zoom"}}})

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.SystemSettingsData", IDName: "system-settings-data", Doc: "SystemSettingsData is the data type of the global Goki settings.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Methods: []gti.Method{{Name: "Apply", Doc: "Apply detailed preferences to all the relevant settings.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}}, Embeds: []gti.Field{{Name: "SettingsBase"}}, Fields: []gti.Field{{Name: "Behavior", Doc: "settings controlling app behavior"}, {Name: "Editor", Doc: "text editor settings"}, {Name: "Clock24", Doc: "whether to use a 24-hour clock (instead of AM and PM)"}, {Name: "FontPaths", Doc: "extra font paths, beyond system defaults -- searched first"}, {Name: "User", Doc: "user info -- partially filled-out automatically if empty / when prefs first created"}, {Name: "FavPaths", Doc: "favorite paths, shown in FileViewer and also editable there"}, {Name: "FileViewSort", Doc: "column to sort by in FileView, and :up or :down for direction -- updated automatically via FileView"}, {Name: "MenuMaxHeight", Doc: "the maximum height of any menu popup panel in units of font height;\nscroll bars are enforced beyond that size."}, {Name: "CompleteWaitDuration", Doc: "the amount of time to wait before offering completions"}, {Name: "CompleteMaxItems", Doc: "the maximum number of completions offered in popup"}, {Name: "CursorBlinkTime", Doc: "time interval for cursor blinking on and off -- set to 0 to disable blinking"}, {Name: "LayoutAutoScrollDelay", Doc: "The amount of time to wait before trying to autoscroll again"}, {Name: "LayoutPageSteps", Doc: "number of steps to take in PageUp / Down events in terms of number of items"}, {Name: "LayoutFocusNameTimeout", Doc: "the amount of time between keypresses to combine characters into name to search for within layout -- starts over after this delay"}, {Name: "LayoutFocusNameTabTime", Doc: "the amount of time since last focus name event to allow tab to focus on next element with same name."}, {Name: "MapInlineLength", Doc: "the number of map elements at or below which an inline representation\nof the map will be presented, which is more convenient for small #'s of props"}, {Name: "StructInlineLength", Doc: "the number of elemental struct fields at or below which an inline representation\nof the struct will be presented, which is more convenient for small structs"}, {Name: "SliceInlineLength", Doc: "the number of slice elements below which inline will be used"}}})

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.BehaviorSettings", IDName: "behavior-settings", Doc: "BehaviorSettings contains misc parameters controlling GUI behavior.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Fields: []gti.Field{{Name: "OnlyCloseActiveTab", Doc: "only support closing the currently selected active tab; if this is set to true, pressing the close button on other tabs will take you to that tab, from which you can close it"}, {Name: "ZebraStripeWeight", Doc: "the amount that alternating rows and columns are highlighted when showing tabular data (set to 0 to disable zebra striping)"}, {Name: "BigFileSize", Doc: "the limit of file size, above which user will be prompted before opening / copying, etc."}, {Name: "SavedPathsMax", Doc: "maximum number of saved paths to save in FileView"}}})

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.User", IDName: "user", Doc: "User basic user information that might be needed for different apps", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Embeds: []gti.Field{{Name: "User"}}, Fields: []gti.Field{{Name: "Email", Doc: "default email address -- e.g., for recording changes in a version control system"}}})

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.EditorSettings", IDName: "editor-settings", Doc: "EditorSettings contains text editor settings.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Fields: []gti.Field{{Name: "TabSize", Doc: "size of a tab, in chars -- also determines indent level for space indent"}, {Name: "SpaceIndent", Doc: "use spaces for indentation, otherwise tabs"}, {Name: "WordWrap", Doc: "wrap lines at word boundaries -- otherwise long lines scroll off the end"}, {Name: "LineNos", Doc: "show line numbers"}, {Name: "Completion", Doc: "use the completion system to suggest options while typing"}, {Name: "SpellCorrect", Doc: "suggest corrections for unknown words while typing"}, {Name: "AutoIndent", Doc: "automatically indent lines when enter, tab, }, etc pressed"}, {Name: "EmacsUndo", Doc: "use emacs-style undo, where after a non-undo command, all the current undo actions are added to the undo stack, such that a subsequent undo is actually a redo"}, {Name: "DepthColor", Doc: "colorize the background according to nesting depth"}}})

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.FavPathItem", IDName: "fav-path-item", Doc: "FavPathItem represents one item in a favorite path list, for display of\nfavorites.  Is an ordered list instead of a map because user can organize\nin order", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Fields: []gti.Field{{Name: "Ic", Doc: "icon for item"}, {Name: "Name", Doc: "name of the favorite item"}, {Name: "Path", Doc: "the path of the favorite item"}}})

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.DebugSettingsData", IDName: "debug-settings-data", Doc: "DebugSettingsData is the data type for debugging settings.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Embeds: []gti.Field{{Name: "SettingsBase"}}, Fields: []gti.Field{{Name: "UpdateTrace", Doc: "Print a trace of updates that trigger re-rendering"}, {Name: "RenderTrace", Doc: "Print a trace of the nodes rendering"}, {Name: "LayoutTrace", Doc: "Print a trace of all layouts"}, {Name: "LayoutTraceDetail", Doc: "Print more detailed info about the underlying layout computations"}, {Name: "WinEventTrace", Doc: "Print a trace of window events"}, {Name: "WinRenderTrace", Doc: "Print the stack trace leading up to win publish events\nwhich are expensive; wrap multiple updates in\nUpdateStart / End to prevent"}, {Name: "WinGeomTrace", Doc: "Print a trace of window geometry saving / loading functions"}, {Name: "KeyEventTrace", Doc: "Print a trace of keyboard events"}, {Name: "EventTrace", Doc: "Print a trace of event handling"}, {Name: "FocusTrace", Doc: "Print a trace of focus changes"}, {Name: "DNDTrace", Doc: "Print a trace of DND event handling"}, {Name: "GoCompleteTrace", Doc: "Print a trace of Go language completion and lookup process"}, {Name: "GoTypeTrace", Doc: "Print a trace of Go language type parsing and inference process"}}})

// SliderType is the [gti.Type] for [Slider]
var SliderType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Slider", IDName: "slider", Doc: "Slider is a slideable widget that provides slider functionality for two Types:\nSlider type provides a movable thumb that represents Value as the center of thumb\nPos position, with room reserved at ends for 1/2 of the thumb size.\nScrollbar has a VisiblePct factor that specifies the percent of the content\ncurrently visible, which determines the size of the thumb, and thus the range of motion\nremaining for the thumb Value (VisiblePct = 1 means thumb is full size, and no remaining\nrange of motion).\nThe Content size (inside the margin and padding) determines the outer bounds of\nthe rendered area.\nThe [styles.Style.Direction] determines the direction in which the slider slides.", Directives: []gti.Directive{{Tool: "goki", Directive: "embedder"}}, Embeds: []gti.Field{{Name: "WidgetBase"}}, Fields: []gti.Field{{Name: "Type", Doc: "the type of the slider, which determines the visual and functional properties"}, {Name: "Value", Doc: "Current value, represented by the position of the thumb."}, {Name: "Min", Doc: "minimum value in range"}, {Name: "Max", Doc: "maximum value in range"}, {Name: "Step", Doc: "smallest step size to increment"}, {Name: "PageStep", Doc: "larger PageUp / Dn step size"}, {Name: "VisiblePct", Doc: "For Scrollbar type only: proportion (1 max) of the full range of scrolled data\nthat is currently visible.  This determines the thumb size and range of motion:\nif 1, full slider is the thumb and no motion is possible."}, {Name: "ThumbSize", Doc: "Size of the thumb as a proportion of the slider thickness, which is\nContent size (inside the padding).  This is for actual X,Y dimensions,\nso must be sensitive to Dim dimension alignment."}, {Name: "TrackSize", Doc: "TrackSize is the proportion of slider thickness for the visible track\nfor the Slider type.  It is often thinner than the thumb, achieved by\nvalues < 1 (.5 default)"}, {Name: "Icon", Doc: "optional icon for the dragging knob"}, {Name: "InputThreshold", Doc: "threshold for amount of change in scroll value before emitting an input event"}, {Name: "Snap", Doc: "whether to snap the values to Step size increments"}, {Name: "Prec", Doc: "specifies the precision of decimal places (total, not after the decimal point)\nto use in representing the number. This helps to truncate small weird floating\npoint values in the nether regions."}, {Name: "ValueColor", Doc: "The background color that is used for styling the selected value section of the slider.\nIt should be set in the StyleFuncs, just like the main style object is.\nIf it is set to transparent, no value is rendered, so the value section of the slider\njust looks like the rest of the slider."}, {Name: "ThumbColor", Doc: "The background color that is used for styling the thumb (handle) of the slider.\nIt should be set in the StyleFuncs, just like the main style object is.\nIf it is set to transparent, no thumb is rendered, so the thumb section of the slider\njust looks like the rest of the slider."}, {Name: "StayInView", Doc: "If true, keep the slider (typically a Scrollbar) within the parent Scene\nbounding box, if the parent is in view.  This is the default behavior\nfor Layout scrollbars, and setting this flag replicates that behavior\nin other scrollbars."}, {Name: "Pos", Doc: "logical position of the slider relative to Size"}, {Name: "LastValue", Doc: "previous Change event emitted value - don't re-emit Change if it is the same"}, {Name: "PrevSlide", Doc: "previous sliding value - for computing the Input change"}, {Name: "Size", Doc: "Computed size of the slide box in the relevant dimension\nrange of motion, exclusive of spacing, based on layout allocation."}, {Name: "SlideStartPos", Doc: "underlying drag position of slider -- not subject to snapping"}}, Instance: &Slider{}})

// NewSlider adds a new [Slider] with the given name to the given parent:
// Slider is a slideable widget that provides slider functionality for two Types:
// Slider type provides a movable thumb that represents Value as the center of thumb
// Pos position, with room reserved at ends for 1/2 of the thumb size.
// Scrollbar has a VisiblePct factor that specifies the percent of the content
// currently visible, which determines the size of the thumb, and thus the range of motion
// remaining for the thumb Value (VisiblePct = 1 means thumb is full size, and no remaining
// range of motion).
// The Content size (inside the margin and padding) determines the outer bounds of
// the rendered area.
// The [styles.Style.Direction] determines the direction in which the slider slides.
func NewSlider(par ki.Ki, name ...string) *Slider {
	return par.NewChild(SliderType, name...).(*Slider)
}

// KiType returns the [*gti.Type] of [Slider]
func (t *Slider) KiType() *gti.Type { return SliderType }

// New returns a new [*Slider] value
func (t *Slider) New() ki.Ki { return &Slider{} }

// SliderEmbedder is an interface that all types that embed Slider satisfy
type SliderEmbedder interface {
	AsSlider() *Slider
}

// AsSlider returns the given value as a value of type Slider if the type
// of the given value embeds Slider, or nil otherwise
func AsSlider(k ki.Ki) *Slider {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(SliderEmbedder); ok {
		return t.AsSlider()
	}
	return nil
}

// AsSlider satisfies the [SliderEmbedder] interface
func (t *Slider) AsSlider() *Slider { return t }

// SetMin sets the [Slider.Min]:
// minimum value in range
func (t *Slider) SetMin(v float32) *Slider { t.Min = v; return t }

// SetMax sets the [Slider.Max]:
// maximum value in range
func (t *Slider) SetMax(v float32) *Slider { t.Max = v; return t }

// SetStep sets the [Slider.Step]:
// smallest step size to increment
func (t *Slider) SetStep(v float32) *Slider { t.Step = v; return t }

// SetPageStep sets the [Slider.PageStep]:
// larger PageUp / Dn step size
func (t *Slider) SetPageStep(v float32) *Slider { t.PageStep = v; return t }

// SetThumbSize sets the [Slider.ThumbSize]:
// Size of the thumb as a proportion of the slider thickness, which is
// Content size (inside the padding).  This is for actual X,Y dimensions,
// so must be sensitive to Dim dimension alignment.
func (t *Slider) SetThumbSize(v mat32.Vec2) *Slider { t.ThumbSize = v; return t }

// SetTrackSize sets the [Slider.TrackSize]:
// TrackSize is the proportion of slider thickness for the visible track
// for the Slider type.  It is often thinner than the thumb, achieved by
// values < 1 (.5 default)
func (t *Slider) SetTrackSize(v float32) *Slider { t.TrackSize = v; return t }

// SetIcon sets the [Slider.Icon]:
// optional icon for the dragging knob
func (t *Slider) SetIcon(v icons.Icon) *Slider { t.Icon = v; return t }

// SetInputThreshold sets the [Slider.InputThreshold]:
// threshold for amount of change in scroll value before emitting an input event
func (t *Slider) SetInputThreshold(v float32) *Slider { t.InputThreshold = v; return t }

// SetSnap sets the [Slider.Snap]:
// whether to snap the values to Step size increments
func (t *Slider) SetSnap(v bool) *Slider { t.Snap = v; return t }

// SetPrec sets the [Slider.Prec]:
// specifies the precision of decimal places (total, not after the decimal point)
// to use in representing the number. This helps to truncate small weird floating
// point values in the nether regions.
func (t *Slider) SetPrec(v int) *Slider { t.Prec = v; return t }

// SetValueColor sets the [Slider.ValueColor]:
// The background color that is used for styling the selected value section of the slider.
// It should be set in the StyleFuncs, just like the main style object is.
// If it is set to transparent, no value is rendered, so the value section of the slider
// just looks like the rest of the slider.
func (t *Slider) SetValueColor(v image.Image) *Slider { t.ValueColor = v; return t }

// SetThumbColor sets the [Slider.ThumbColor]:
// The background color that is used for styling the thumb (handle) of the slider.
// It should be set in the StyleFuncs, just like the main style object is.
// If it is set to transparent, no thumb is rendered, so the thumb section of the slider
// just looks like the rest of the slider.
func (t *Slider) SetThumbColor(v image.Image) *Slider { t.ThumbColor = v; return t }

// SetStayInView sets the [Slider.StayInView]:
// If true, keep the slider (typically a Scrollbar) within the parent Scene
// bounding box, if the parent is in view.  This is the default behavior
// for Layout scrollbars, and setting this flag replicates that behavior
// in other scrollbars.
func (t *Slider) SetStayInView(v bool) *Slider { t.StayInView = v; return t }

// SetTooltip sets the [Slider.Tooltip]
func (t *Slider) SetTooltip(v string) *Slider { t.Tooltip = v; return t }

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.Spell", IDName: "spell", Doc: "Spell", Directives: []gti.Directive{{Tool: "gti", Directive: "add", Args: []string{"-setters"}}}, Fields: []gti.Field{{Name: "SrcLn", Doc: "line number in source that spelling is operating on, if relevant"}, {Name: "SrcCh", Doc: "character position in source that spelling is operating on (start of word to be corrected)"}, {Name: "Suggest", Doc: "list of suggested corrections"}, {Name: "Word", Doc: "word being checked"}, {Name: "LastLearned", Doc: "last word learned -- can be undone -- stored in lowercase format"}, {Name: "Correction", Doc: "the user's correction selection"}, {Name: "Listeners", Doc: "the event listeners for the spell (it sends Select events)"}, {Name: "Stage", Doc: "Stage is the [PopupStage] associated with the [Spell]"}, {Name: "ShowMu"}}})

// SetSrcLn sets the [Spell.SrcLn]:
// line number in source that spelling is operating on, if relevant
func (t *Spell) SetSrcLn(v int) *Spell { t.SrcLn = v; return t }

// SetSrcCh sets the [Spell.SrcCh]:
// character position in source that spelling is operating on (start of word to be corrected)
func (t *Spell) SetSrcCh(v int) *Spell { t.SrcCh = v; return t }

// SetSuggest sets the [Spell.Suggest]:
// list of suggested corrections
func (t *Spell) SetSuggest(v ...string) *Spell { t.Suggest = v; return t }

// SetStage sets the [Spell.Stage]:
// Stage is the [PopupStage] associated with the [Spell]
func (t *Spell) SetStage(v *Stage) *Spell { t.Stage = v; return t }

// SpinnerType is the [gti.Type] for [Spinner]
var SpinnerType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Spinner", IDName: "spinner", Doc: "Spinner combines a TextField with up / down buttons for incrementing /\ndecrementing values -- all configured within the Parts of the widget", Directives: []gti.Directive{{Tool: "goki", Directive: "embedder"}}, Embeds: []gti.Field{{Name: "TextField"}}, Fields: []gti.Field{{Name: "Value", Doc: "Value is the current value"}, {Name: "HasMin", Doc: "HasMin is whether there is a minimum value to enforce"}, {Name: "Min", Doc: "If HasMin is true, Min is the the minimum value in range"}, {Name: "HasMax", Doc: "HaxMax is whether there is a maximum value to enforce"}, {Name: "Max", Doc: "If HasMax is true, Max is the maximum value in range"}, {Name: "Step", Doc: "Step is the smallest step size to increment"}, {Name: "PageStep", Doc: "PageStep is a larger step size used for PageUp and PageDown"}, {Name: "Prec", Doc: "Prec specifies the precision of decimal places\n(total, not after the decimal point) to use in\nrepresenting the number. This helps to truncate\nsmall weird floating point values."}, {Name: "Format", Doc: "Format is the format string to use for printing the value.\nIf it unset, %g is used. If it is decimal based\n(ends in d, b, c, o, O, q, x, X, or U) then the value is\nconverted to decimal prior to printing."}}, Instance: &Spinner{}})

// NewSpinner adds a new [Spinner] with the given name to the given parent:
// Spinner combines a TextField with up / down buttons for incrementing /
// decrementing values -- all configured within the Parts of the widget
func NewSpinner(par ki.Ki, name ...string) *Spinner {
	return par.NewChild(SpinnerType, name...).(*Spinner)
}

// KiType returns the [*gti.Type] of [Spinner]
func (t *Spinner) KiType() *gti.Type { return SpinnerType }

// New returns a new [*Spinner] value
func (t *Spinner) New() ki.Ki { return &Spinner{} }

// SpinnerEmbedder is an interface that all types that embed Spinner satisfy
type SpinnerEmbedder interface {
	AsSpinner() *Spinner
}

// AsSpinner returns the given value as a value of type Spinner if the type
// of the given value embeds Spinner, or nil otherwise
func AsSpinner(k ki.Ki) *Spinner {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(SpinnerEmbedder); ok {
		return t.AsSpinner()
	}
	return nil
}

// AsSpinner satisfies the [SpinnerEmbedder] interface
func (t *Spinner) AsSpinner() *Spinner { return t }

// SetStep sets the [Spinner.Step]:
// Step is the smallest step size to increment
func (t *Spinner) SetStep(v float32) *Spinner { t.Step = v; return t }

// SetPageStep sets the [Spinner.PageStep]:
// PageStep is a larger step size used for PageUp and PageDown
func (t *Spinner) SetPageStep(v float32) *Spinner { t.PageStep = v; return t }

// SetPrec sets the [Spinner.Prec]:
// Prec specifies the precision of decimal places
// (total, not after the decimal point) to use in
// representing the number. This helps to truncate
// small weird floating point values.
func (t *Spinner) SetPrec(v int) *Spinner { t.Prec = v; return t }

// SetFormat sets the [Spinner.Format]:
// Format is the format string to use for printing the value.
// If it unset, %g is used. If it is decimal based
// (ends in d, b, c, o, O, q, x, X, or U) then the value is
// converted to decimal prior to printing.
func (t *Spinner) SetFormat(v string) *Spinner { t.Format = v; return t }

// SetTooltip sets the [Spinner.Tooltip]
func (t *Spinner) SetTooltip(v string) *Spinner { t.Tooltip = v; return t }

// SetPlaceholder sets the [Spinner.Placeholder]
func (t *Spinner) SetPlaceholder(v string) *Spinner { t.Placeholder = v; return t }

// SetComplete sets the [Spinner.Complete]
func (t *Spinner) SetComplete(v *Complete) *Spinner { t.Complete = v; return t }

// SetNoEcho sets the [Spinner.NoEcho]
func (t *Spinner) SetNoEcho(v bool) *Spinner { t.NoEcho = v; return t }

// SetLeadingIconOnClick sets the [Spinner.LeadingIconOnClick]
func (t *Spinner) SetLeadingIconOnClick(v func(e events.Event)) *Spinner {
	t.LeadingIconOnClick = v
	return t
}

// SetTrailingIconOnClick sets the [Spinner.TrailingIconOnClick]
func (t *Spinner) SetTrailingIconOnClick(v func(e events.Event)) *Spinner {
	t.TrailingIconOnClick = v
	return t
}

// SetCursorWidth sets the [Spinner.CursorWidth]
func (t *Spinner) SetCursorWidth(v units.Value) *Spinner { t.CursorWidth = v; return t }

// SetType sets the [Spinner.Type]
func (t *Spinner) SetType(v TextFieldTypes) *Spinner { t.Type = v; return t }

// SetPlaceholderColor sets the [Spinner.PlaceholderColor]
func (t *Spinner) SetPlaceholderColor(v color.RGBA) *Spinner { t.PlaceholderColor = v; return t }

// SetSelectColor sets the [Spinner.SelectColor]
func (t *Spinner) SetSelectColor(v image.Image) *Spinner { t.SelectColor = v; return t }

// SetCursorColor sets the [Spinner.CursorColor]
func (t *Spinner) SetCursorColor(v image.Image) *Spinner { t.CursorColor = v; return t }

// SetMaxWidthReq sets the [Spinner.MaxWidthReq]
func (t *Spinner) SetMaxWidthReq(v int) *Spinner { t.MaxWidthReq = v; return t }

// SetSelectMode sets the [Spinner.SelectMode]
func (t *Spinner) SetSelectMode(v bool) *Spinner { t.SelectMode = v; return t }

// SplitsType is the [gti.Type] for [Splits]
var SplitsType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Splits", IDName: "splits", Doc: "Splits allocates a fixed proportion of space to each child, along given\ndimension.  It uses the Widget Parts to hold the Handle widgets\nseparately from the children that contain the rest of the scene to be\ndisplayed within each panel.", Directives: []gti.Directive{{Tool: "goki", Directive: "embedder"}}, Embeds: []gti.Field{{Name: "Layout"}}, Fields: []gti.Field{{Name: "Splits", Doc: "proportion (0-1 normalized, enforced) of space allocated to each element.\nEnter 0 to collapse a given element"}, {Name: "SavedSplits", Doc: "A saved version of the splits which can be restored.\nFor dynamic collapse / expand operations"}}, Instance: &Splits{}})

// NewSplits adds a new [Splits] with the given name to the given parent:
// Splits allocates a fixed proportion of space to each child, along given
// dimension.  It uses the Widget Parts to hold the Handle widgets
// separately from the children that contain the rest of the scene to be
// displayed within each panel.
func NewSplits(par ki.Ki, name ...string) *Splits {
	return par.NewChild(SplitsType, name...).(*Splits)
}

// KiType returns the [*gti.Type] of [Splits]
func (t *Splits) KiType() *gti.Type { return SplitsType }

// New returns a new [*Splits] value
func (t *Splits) New() ki.Ki { return &Splits{} }

// SplitsEmbedder is an interface that all types that embed Splits satisfy
type SplitsEmbedder interface {
	AsSplits() *Splits
}

// AsSplits returns the given value as a value of type Splits if the type
// of the given value embeds Splits, or nil otherwise
func AsSplits(k ki.Ki) *Splits {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(SplitsEmbedder); ok {
		return t.AsSplits()
	}
	return nil
}

// AsSplits satisfies the [SplitsEmbedder] interface
func (t *Splits) AsSplits() *Splits { return t }

// SetTooltip sets the [Splits.Tooltip]
func (t *Splits) SetTooltip(v string) *Splits { t.Tooltip = v; return t }

// SetStackTop sets the [Splits.StackTop]
func (t *Splits) SetStackTop(v int) *Splits { t.StackTop = v; return t }

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.Stage", IDName: "stage", Doc: "Stage is a container and manager for displaying a Scene\nin different functional ways, defined by StageTypes, in two categories:\nMain types (Window, Dialog, Sheet) and Popup types\n(Menu, Tooltip, Snackbar, Chooser).", Directives: []gti.Directive{{Tool: "gti", Directive: "add", Args: []string{"-setters"}}}, Fields: []gti.Field{{Name: "Type", Doc: "type of Stage: determines behavior and Styling"}, {Name: "Scene", Doc: "Scene contents of this Stage -- what it displays"}, {Name: "Context", Doc: "widget in another scene that requested this stage to be created\nand provides context (stage)"}, {Name: "Name", Doc: "name of the Stage -- generally auto-set based on Scene Name"}, {Name: "Title", Doc: "Title of the Stage -- generally auto-set based on Scene Title.\nUsed for title of Window and Dialog types."}, {Name: "Modal", Doc: "if true, blocks input to all other stages."}, {Name: "Scrim", Doc: "if true, places a darkening scrim over other stages, if not a full window"}, {Name: "ClickOff", Doc: "if true dismisses the Stage if user clicks anywhere off the Stage"}, {Name: "IgnoreEvents", Doc: "whether to send no events to the stage and just pass them down to lower stages"}, {Name: "NewWindow", Doc: "NewWindow: if true, opens a Window or Dialog in its own separate operating\nsystem window (RenderWin).  This is by default true for Window on Desktop, otherwise false."}, {Name: "FullWindow", Doc: "if NewWindow is false, then this makes Dialogs and Windows take up\nthe entire window they are created in."}, {Name: "Closeable", Doc: "for Dialogs: if true includes a close button for closing"}, {Name: "Movable", Doc: "for Dialogs: adds a handle titlebar Decor for moving"}, {Name: "Resizable", Doc: "for Dialogs: adds a resize handle Decor for resizing"}, {Name: "Pos", Doc: "Target position for Scene to be placed within RenderWin"}, {Name: "Side", Doc: "Side for Stages that can operate on different sides, e.g.,\nfor Sheets: which side does the sheet come out from"}, {Name: "Data", Doc: "Data is item represented by this main stage -- used for recycling windows"}, {Name: "Main", Doc: "If a Popup Stage, this is the Main Stage that owns it (via its PopupMgr)\nIf a Main Stage, it points to itself."}, {Name: "PopupMgr", Doc: "For Main stages, this is the manager for the popups within it (created\nspecifically for the main stage).\nFor Popups, this is the pointer to the PopupMgr within the\nMain Stage managing it."}, {Name: "MainMgr", Doc: "For all stages, this is the Main stage manager that lives in a RenderWin\nand manages the Main Scenes."}, {Name: "RenderCtx", Doc: "rendering context which has info about the RenderWin onto which we render.\nThis should be used instead of the RenderWin itself for all relevant\nrendering information.  This is only available once a Stage is Run,\nand must always be checked for nil."}, {Name: "Sprites", Doc: "sprites are named images that are rendered last overlaying everything else."}, {Name: "SpriteDragging", Doc: "name of sprite that is being dragged -- sprite event function is responsible for setting this."}, {Name: "Timeout", Doc: "if > 0, disappears after a timeout duration"}}})

// SetContext sets the [Stage.Context]:
// widget in another scene that requested this stage to be created
// and provides context (stage)
func (t *Stage) SetContext(v Widget) *Stage { t.Context = v; return t }

// SetName sets the [Stage.Name]:
// name of the Stage -- generally auto-set based on Scene Name
func (t *Stage) SetName(v string) *Stage { t.Name = v; return t }

// SetTitle sets the [Stage.Title]:
// Title of the Stage -- generally auto-set based on Scene Title.
// Used for title of Window and Dialog types.
func (t *Stage) SetTitle(v string) *Stage { t.Title = v; return t }

// SetModal sets the [Stage.Modal]:
// if true, blocks input to all other stages.
func (t *Stage) SetModal(v bool) *Stage { t.Modal = v; return t }

// SetScrim sets the [Stage.Scrim]:
// if true, places a darkening scrim over other stages, if not a full window
func (t *Stage) SetScrim(v bool) *Stage { t.Scrim = v; return t }

// SetClickOff sets the [Stage.ClickOff]:
// if true dismisses the Stage if user clicks anywhere off the Stage
func (t *Stage) SetClickOff(v bool) *Stage { t.ClickOff = v; return t }

// SetIgnoreEvents sets the [Stage.IgnoreEvents]:
// whether to send no events to the stage and just pass them down to lower stages
func (t *Stage) SetIgnoreEvents(v bool) *Stage { t.IgnoreEvents = v; return t }

// SetNewWindow sets the [Stage.NewWindow]:
// NewWindow: if true, opens a Window or Dialog in its own separate operating
// system window (RenderWin).  This is by default true for Window on Desktop, otherwise false.
func (t *Stage) SetNewWindow(v bool) *Stage { t.NewWindow = v; return t }

// SetFullWindow sets the [Stage.FullWindow]:
// if NewWindow is false, then this makes Dialogs and Windows take up
// the entire window they are created in.
func (t *Stage) SetFullWindow(v bool) *Stage { t.FullWindow = v; return t }

// SetCloseable sets the [Stage.Closeable]:
// for Dialogs: if true includes a close button for closing
func (t *Stage) SetCloseable(v bool) *Stage { t.Closeable = v; return t }

// SetMovable sets the [Stage.Movable]:
// for Dialogs: adds a handle titlebar Decor for moving
func (t *Stage) SetMovable(v bool) *Stage { t.Movable = v; return t }

// SetResizable sets the [Stage.Resizable]:
// for Dialogs: adds a resize handle Decor for resizing
func (t *Stage) SetResizable(v bool) *Stage { t.Resizable = v; return t }

// SetPos sets the [Stage.Pos]:
// Target position for Scene to be placed within RenderWin
func (t *Stage) SetPos(v image.Point) *Stage { t.Pos = v; return t }

// SetSide sets the [Stage.Side]:
// Side for Stages that can operate on different sides, e.g.,
// for Sheets: which side does the sheet come out from
func (t *Stage) SetSide(v StageSides) *Stage { t.Side = v; return t }

// SetData sets the [Stage.Data]:
// Data is item represented by this main stage -- used for recycling windows
func (t *Stage) SetData(v any) *Stage { t.Data = v; return t }

// SetMain sets the [Stage.Main]:
// If a Popup Stage, this is the Main Stage that owns it (via its PopupMgr)
// If a Main Stage, it points to itself.
func (t *Stage) SetMain(v *Stage) *Stage { t.Main = v; return t }

// SetRenderCtx sets the [Stage.RenderCtx]:
// rendering context which has info about the RenderWin onto which we render.
// This should be used instead of the RenderWin itself for all relevant
// rendering information.  This is only available once a Stage is Run,
// and must always be checked for nil.
func (t *Stage) SetRenderCtx(v *RenderContext) *Stage { t.RenderCtx = v; return t }

// SetSprites sets the [Stage.Sprites]:
// sprites are named images that are rendered last overlaying everything else.
func (t *Stage) SetSprites(v Sprites) *Stage { t.Sprites = v; return t }

// SetSpriteDragging sets the [Stage.SpriteDragging]:
// name of sprite that is being dragged -- sprite event function is responsible for setting this.
func (t *Stage) SetSpriteDragging(v string) *Stage { t.SpriteDragging = v; return t }

// SetTimeout sets the [Stage.Timeout]:
// if > 0, disappears after a timeout duration
func (t *Stage) SetTimeout(v time.Duration) *Stage { t.Timeout = v; return t }

var _ = gti.AddType(&gti.Type{Name: "goki.dev/gi.StageMgr", IDName: "stage-mgr", Doc: "StageMgr manages a stack of Stage elements", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Fields: []gti.Field{{Name: "Stack", Doc: "stack of stages managed by this stage manager."}, {Name: "Modified", Doc: "Modified is set to true whenever the stack has been modified.\nThis is cleared by the RenderWin each render cycle."}, {Name: "RenderCtx", Doc: "rendering context provides key rendering information and locking\nfor the RenderWin in which the stages are running.\nthe MainStageMgr within the RenderWin"}, {Name: "RenderWin", Doc: "render window to which we are rendering.\nrely on the RenderCtx wherever possible."}, {Name: "History", Doc: "growing stack of viewing history of all stages."}, {Name: "Main", Doc: "Main is the Main Stage that owns this StageMgr, only set for Popup stages"}, {Name: "Mu", Doc: "mutex protecting reading / updating of the Stack.\nDestructive stack updating gets a Write lock, else Read."}}})

// SVGType is the [gti.Type] for [SVG]
var SVGType = gti.AddType(&gti.Type{Name: "goki.dev/gi.SVG", IDName: "svg", Doc: "SVG is a Widget that renders an [svg.SVG] object.\nIf it is not [states.ReadOnly], the user can pan and zoom the display.\nSVGs do not render a background or border independent of their SVG object.", Methods: []gti.Method{{Name: "OpenSVG", Doc: "OpenSVG opens an XML-formatted SVG file", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "SaveSVG", Doc: "SaveSVG saves the current SVG to an XML-encoded standard SVG file", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "SavePNG", Doc: "SavePNG saves the current rendered SVG image to an PNG image file", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}}, Embeds: []gti.Field{{Name: "WidgetBase"}}, Fields: []gti.Field{{Name: "SVG", Doc: "SVG is the SVG object associated with the element."}}, Instance: &SVG{}})

// NewSVG adds a new [SVG] with the given name to the given parent:
// SVG is a Widget that renders an [svg.SVG] object.
// If it is not [states.ReadOnly], the user can pan and zoom the display.
// SVGs do not render a background or border independent of their SVG object.
func NewSVG(par ki.Ki, name ...string) *SVG {
	return par.NewChild(SVGType, name...).(*SVG)
}

// KiType returns the [*gti.Type] of [SVG]
func (t *SVG) KiType() *gti.Type { return SVGType }

// New returns a new [*SVG] value
func (t *SVG) New() ki.Ki { return &SVG{} }

// SetTooltip sets the [SVG.Tooltip]
func (t *SVG) SetTooltip(v string) *SVG { t.Tooltip = v; return t }

// SwitchType is the [gti.Type] for [Switch]
var SwitchType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Switch", IDName: "switch", Doc: "Switch is a widget that can toggle between an on and off state.\nIt can be displayed as a switch, checkbox, or radio button.", Embeds: []gti.Field{{Name: "Box"}}, Fields: []gti.Field{{Name: "Type", Doc: "the type of switch that this is"}, {Name: "Text", Doc: "the label text for the switch"}, {Name: "IconOn", Doc: "icon to use for the on, checked state of the switch"}, {Name: "IconOff", Doc: "icon to use for the off, unchecked state of the switch"}, {Name: "IconUnk", Doc: "icon to use for the indeterminate (unknown) state"}}, Instance: &Switch{}})

// NewSwitch adds a new [Switch] with the given name to the given parent:
// Switch is a widget that can toggle between an on and off state.
// It can be displayed as a switch, checkbox, or radio button.
func NewSwitch(par ki.Ki, name ...string) *Switch {
	return par.NewChild(SwitchType, name...).(*Switch)
}

// KiType returns the [*gti.Type] of [Switch]
func (t *Switch) KiType() *gti.Type { return SwitchType }

// New returns a new [*Switch] value
func (t *Switch) New() ki.Ki { return &Switch{} }

// SetText sets the [Switch.Text]:
// the label text for the switch
func (t *Switch) SetText(v string) *Switch { t.Text = v; return t }

// SetIconOn sets the [Switch.IconOn]:
// icon to use for the on, checked state of the switch
func (t *Switch) SetIconOn(v icons.Icon) *Switch { t.IconOn = v; return t }

// SetIconOff sets the [Switch.IconOff]:
// icon to use for the off, unchecked state of the switch
func (t *Switch) SetIconOff(v icons.Icon) *Switch { t.IconOff = v; return t }

// SetIconUnk sets the [Switch.IconUnk]:
// icon to use for the indeterminate (unknown) state
func (t *Switch) SetIconUnk(v icons.Icon) *Switch { t.IconUnk = v; return t }

// SetTooltip sets the [Switch.Tooltip]
func (t *Switch) SetTooltip(v string) *Switch { t.Tooltip = v; return t }

// SwitchesType is the [gti.Type] for [Switches]
var SwitchesType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Switches", IDName: "switches", Doc: "Switches is a widget for containing a set of switches.\nIt can optionally enforce mutual exclusivity (i.e., Radio Buttons).\nThe buttons are all in the Parts of the widget and the Parts layout\ndetermines how they are displayed.", Directives: []gti.Directive{{Tool: "goki", Directive: "embedder"}}, Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "Type", Doc: "the type of switches that will be made"}, {Name: "Items", Doc: "the list of items (switch labels)"}, {Name: "Tooltips", Doc: "an optional list of tooltips displayed on hover for checkbox items; the indices for tooltips correspond to those for items"}, {Name: "Mutex", Doc: "whether to make the items mutually exclusive (checking one turns off all the others)"}}, Instance: &Switches{}})

// NewSwitches adds a new [Switches] with the given name to the given parent:
// Switches is a widget for containing a set of switches.
// It can optionally enforce mutual exclusivity (i.e., Radio Buttons).
// The buttons are all in the Parts of the widget and the Parts layout
// determines how they are displayed.
func NewSwitches(par ki.Ki, name ...string) *Switches {
	return par.NewChild(SwitchesType, name...).(*Switches)
}

// KiType returns the [*gti.Type] of [Switches]
func (t *Switches) KiType() *gti.Type { return SwitchesType }

// New returns a new [*Switches] value
func (t *Switches) New() ki.Ki { return &Switches{} }

// SwitchesEmbedder is an interface that all types that embed Switches satisfy
type SwitchesEmbedder interface {
	AsSwitches() *Switches
}

// AsSwitches returns the given value as a value of type Switches if the type
// of the given value embeds Switches, or nil otherwise
func AsSwitches(k ki.Ki) *Switches {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(SwitchesEmbedder); ok {
		return t.AsSwitches()
	}
	return nil
}

// AsSwitches satisfies the [SwitchesEmbedder] interface
func (t *Switches) AsSwitches() *Switches { return t }

// SetType sets the [Switches.Type]:
// the type of switches that will be made
func (t *Switches) SetType(v SwitchTypes) *Switches { t.Type = v; return t }

// SetItems sets the [Switches.Items]:
// the list of items (switch labels)
func (t *Switches) SetItems(v ...string) *Switches { t.Items = v; return t }

// SetTooltips sets the [Switches.Tooltips]:
// an optional list of tooltips displayed on hover for checkbox items; the indices for tooltips correspond to those for items
func (t *Switches) SetTooltips(v ...string) *Switches { t.Tooltips = v; return t }

// SetMutex sets the [Switches.Mutex]:
// whether to make the items mutually exclusive (checking one turns off all the others)
func (t *Switches) SetMutex(v bool) *Switches { t.Mutex = v; return t }

// SetTooltip sets the [Switches.Tooltip]
func (t *Switches) SetTooltip(v string) *Switches { t.Tooltip = v; return t }

// SetStackTop sets the [Switches.StackTop]
func (t *Switches) SetStackTop(v int) *Switches { t.StackTop = v; return t }

// SetStripes sets the [Switches.Stripes]
func (t *Switches) SetStripes(v Stripes) *Switches { t.Stripes = v; return t }

// TabsType is the [gti.Type] for [Tabs]
var TabsType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Tabs", IDName: "tabs", Doc: "Tabs switches among child widgets via tabs.  The selected widget gets\nthe full allocated space avail after the tabs are accounted for.  The\nTabs is just a Vertical layout that manages two child widgets: a\nHorizFlow Layout for the tabs (which can flow across multiple rows as\nneeded) and a Stacked Frame that actually contains all the children, and\nprovides scrollbars as needed to any content within.  Typically should have\nmax stretch and a set preferred size, so it expands.", Directives: []gti.Directive{{Tool: "goki", Directive: "embedder"}}, Embeds: []gti.Field{{Name: "Layout"}}, Fields: []gti.Field{{Name: "Type", Doc: "Type is the styling type of the tabs. It must be set\nbefore the tabs are first configured."}, {Name: "MaxChars", Doc: "Maximum number of characters to include in tab label.\nElides labels that are longer than that"}, {Name: "NewTabButton", Doc: "show a new tab button at right of list of tabs"}, {Name: "CloseIcon", Doc: "CloseIcon is the icon used for tab close buttons.\nIf it is \"\" or [icons.None], the tab is not closeable.\nThe default value is [icons.Close].\nOnly [FunctionalTabs] can be closed; all other types of\ntabs will not render a close button and can not be closed."}, {Name: "Mu", Doc: "mutex protecting updates to tabs.\nTabs can be driven programmatically and via user input so need extra protection"}}, Instance: &Tabs{}})

// NewTabs adds a new [Tabs] with the given name to the given parent:
// Tabs switches among child widgets via tabs.  The selected widget gets
// the full allocated space avail after the tabs are accounted for.  The
// Tabs is just a Vertical layout that manages two child widgets: a
// HorizFlow Layout for the tabs (which can flow across multiple rows as
// needed) and a Stacked Frame that actually contains all the children, and
// provides scrollbars as needed to any content within.  Typically should have
// max stretch and a set preferred size, so it expands.
func NewTabs(par ki.Ki, name ...string) *Tabs {
	return par.NewChild(TabsType, name...).(*Tabs)
}

// KiType returns the [*gti.Type] of [Tabs]
func (t *Tabs) KiType() *gti.Type { return TabsType }

// New returns a new [*Tabs] value
func (t *Tabs) New() ki.Ki { return &Tabs{} }

// TabsEmbedder is an interface that all types that embed Tabs satisfy
type TabsEmbedder interface {
	AsTabs() *Tabs
}

// AsTabs returns the given value as a value of type Tabs if the type
// of the given value embeds Tabs, or nil otherwise
func AsTabs(k ki.Ki) *Tabs {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(TabsEmbedder); ok {
		return t.AsTabs()
	}
	return nil
}

// AsTabs satisfies the [TabsEmbedder] interface
func (t *Tabs) AsTabs() *Tabs { return t }

// SetType sets the [Tabs.Type]:
// Type is the styling type of the tabs. It must be set
// before the tabs are first configured.
func (t *Tabs) SetType(v TabTypes) *Tabs { t.Type = v; return t }

// SetMaxChars sets the [Tabs.MaxChars]:
// Maximum number of characters to include in tab label.
// Elides labels that are longer than that
func (t *Tabs) SetMaxChars(v int) *Tabs { t.MaxChars = v; return t }

// SetNewTabButton sets the [Tabs.NewTabButton]:
// show a new tab button at right of list of tabs
func (t *Tabs) SetNewTabButton(v bool) *Tabs { t.NewTabButton = v; return t }

// SetCloseIcon sets the [Tabs.CloseIcon]:
// CloseIcon is the icon used for tab close buttons.
// If it is "" or [icons.None], the tab is not closeable.
// The default value is [icons.Close].
// Only [FunctionalTabs] can be closed; all other types of
// tabs will not render a close button and can not be closed.
func (t *Tabs) SetCloseIcon(v icons.Icon) *Tabs { t.CloseIcon = v; return t }

// SetTooltip sets the [Tabs.Tooltip]
func (t *Tabs) SetTooltip(v string) *Tabs { t.Tooltip = v; return t }

// SetStackTop sets the [Tabs.StackTop]
func (t *Tabs) SetStackTop(v int) *Tabs { t.StackTop = v; return t }

// TabType is the [gti.Type] for [Tab]
var TabType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Tab", IDName: "tab", Doc: "Tab is a tab button that contains any, all, or none of a label, an icon,\nand a close icon. Tabs should be made using the [Tabs.NewTab] function.", Directives: []gti.Directive{{Tool: "goki", Directive: "no-new"}}, Embeds: []gti.Field{{Name: "Box"}}, Fields: []gti.Field{{Name: "Type", Doc: "Type is the styling type of the tab. This property\nmust be set on the parent [Tabs] for it to work correctly."}, {Name: "Text", Doc: "Text is the label text for the tab.\nIf it is nil, no label is shown.\nLabels are never shown for [NavigationRail] tabs."}, {Name: "Icon", Doc: "Icon is the icon for the tab.\nIf it is \"\" or [icons.None], no icon is shown."}, {Name: "CloseIcon", Doc: "CloseIcon is the icon used as a close button for the tab.\nIf it is \"\" or [icons.None], the tab is not closeable.\nThe default value is [icons.Close].\nOnly [FunctionalTabs] can be closed; all other types of\ntabs will not render a close button and can not be closed."}, {Name: "MaxChars", Doc: "Maximum number of characters to include in tab label.\nElides labels that are longer than that"}}, Instance: &Tab{}})

// KiType returns the [*gti.Type] of [Tab]
func (t *Tab) KiType() *gti.Type { return TabType }

// New returns a new [*Tab] value
func (t *Tab) New() ki.Ki { return &Tab{} }

// SetType sets the [Tab.Type]:
// Type is the styling type of the tab. This property
// must be set on the parent [Tabs] for it to work correctly.
func (t *Tab) SetType(v TabTypes) *Tab { t.Type = v; return t }

// SetText sets the [Tab.Text]:
// Text is the label text for the tab.
// If it is nil, no label is shown.
// Labels are never shown for [NavigationRail] tabs.
func (t *Tab) SetText(v string) *Tab { t.Text = v; return t }

// SetIcon sets the [Tab.Icon]:
// Icon is the icon for the tab.
// If it is "" or [icons.None], no icon is shown.
func (t *Tab) SetIcon(v icons.Icon) *Tab { t.Icon = v; return t }

// SetCloseIcon sets the [Tab.CloseIcon]:
// CloseIcon is the icon used as a close button for the tab.
// If it is "" or [icons.None], the tab is not closeable.
// The default value is [icons.Close].
// Only [FunctionalTabs] can be closed; all other types of
// tabs will not render a close button and can not be closed.
func (t *Tab) SetCloseIcon(v icons.Icon) *Tab { t.CloseIcon = v; return t }

// SetMaxChars sets the [Tab.MaxChars]:
// Maximum number of characters to include in tab label.
// Elides labels that are longer than that
func (t *Tab) SetMaxChars(v int) *Tab { t.MaxChars = v; return t }

// SetTooltip sets the [Tab.Tooltip]
func (t *Tab) SetTooltip(v string) *Tab { t.Tooltip = v; return t }

// TextFieldType is the [gti.Type] for [TextField]
var TextFieldType = gti.AddType(&gti.Type{Name: "goki.dev/gi.TextField", IDName: "text-field", Doc: "TextField is a widget for editing a line of text", Directives: []gti.Directive{{Tool: "goki", Directive: "embedder"}}, Embeds: []gti.Field{{Name: "WidgetBase"}}, Fields: []gti.Field{{Name: "Txt", Doc: "the last saved value of the text string being edited"}, {Name: "Placeholder", Doc: "text that is displayed when the field is empty, in a lower-contrast manner"}, {Name: "Complete", Doc: "functions and data for textfield completion"}, {Name: "NoEcho", Doc: "replace displayed characters with bullets to conceal text"}, {Name: "LeadingIcon", Doc: "if specified, a button will be added at the start of the text field with this icon"}, {Name: "LeadingIconOnClick", Doc: "if LeadingIcon is specified, the function to call when the leading icon is clicked"}, {Name: "TrailingIcon", Doc: "if specified, a button will be added at the end of the text field with this icon"}, {Name: "TrailingIconOnClick", Doc: "if TrailingIcon is specified, the function to call when the trailing icon is clicked"}, {Name: "CursorWidth", Doc: "width of cursor -- set from cursor-width property (inherited)"}, {Name: "Type", Doc: "the type of the text field"}, {Name: "PlaceholderColor", Doc: "the color used for the placeholder text; this should be set in Stylers like all other style properties; it is typically a highlighted version of the normal text color"}, {Name: "SelectColor", Doc: "the color used for the text selection background color on active text fields; this should be set in Stylers like all other style properties"}, {Name: "CursorColor", Doc: "the color used for the text field cursor (caret); this should be set in Stylers like all other style properties"}, {Name: "Edited", Doc: "true if the text has been edited relative to the original"}, {Name: "EditTxt", Doc: "the live text string being edited, with latest modifications -- encoded as runes"}, {Name: "MaxWidthReq", Doc: "maximum width that field will request, in characters, during GetSize process -- if 0 then is 50 -- ensures that large strings don't request super large values -- standard max-width can override"}, {Name: "EffPos", Doc: "effective position with any leading icon space added"}, {Name: "EffSize", Doc: "effective size, subtracting any leading and trailing icon space"}, {Name: "StartPos", Doc: "starting display position in the string"}, {Name: "EndPos", Doc: "ending display position in the string"}, {Name: "CursorPos", Doc: "current cursor position"}, {Name: "CharWidth", Doc: "approximate number of chars that can be displayed at any time -- computed from font size etc"}, {Name: "SelectStart", Doc: "starting position of selection in the string"}, {Name: "SelectEnd", Doc: "ending position of selection in the string"}, {Name: "SelectInit", Doc: "initial selection position -- where it started"}, {Name: "SelectMode", Doc: "if true, select text as cursor moves"}, {Name: "RenderAll", Doc: "render version of entire text, for sizing"}, {Name: "RenderVis", Doc: "render version of just visible text"}, {Name: "FontHeight", Doc: "font height, cached during styling"}, {Name: "BlinkOn", Doc: "oscillates between on and off for blinking"}, {Name: "CursorMu", Doc: "mutex for updating cursor between blinker and field"}}, Instance: &TextField{}})

// NewTextField adds a new [TextField] with the given name to the given parent:
// TextField is a widget for editing a line of text
func NewTextField(par ki.Ki, name ...string) *TextField {
	return par.NewChild(TextFieldType, name...).(*TextField)
}

// KiType returns the [*gti.Type] of [TextField]
func (t *TextField) KiType() *gti.Type { return TextFieldType }

// New returns a new [*TextField] value
func (t *TextField) New() ki.Ki { return &TextField{} }

// TextFieldEmbedder is an interface that all types that embed TextField satisfy
type TextFieldEmbedder interface {
	AsTextField() *TextField
}

// AsTextField returns the given value as a value of type TextField if the type
// of the given value embeds TextField, or nil otherwise
func AsTextField(k ki.Ki) *TextField {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(TextFieldEmbedder); ok {
		return t.AsTextField()
	}
	return nil
}

// AsTextField satisfies the [TextFieldEmbedder] interface
func (t *TextField) AsTextField() *TextField { return t }

// SetPlaceholder sets the [TextField.Placeholder]:
// text that is displayed when the field is empty, in a lower-contrast manner
func (t *TextField) SetPlaceholder(v string) *TextField { t.Placeholder = v; return t }

// SetComplete sets the [TextField.Complete]:
// functions and data for textfield completion
func (t *TextField) SetComplete(v *Complete) *TextField { t.Complete = v; return t }

// SetNoEcho sets the [TextField.NoEcho]:
// replace displayed characters with bullets to conceal text
func (t *TextField) SetNoEcho(v bool) *TextField { t.NoEcho = v; return t }

// SetLeadingIconOnClick sets the [TextField.LeadingIconOnClick]:
// if LeadingIcon is specified, the function to call when the leading icon is clicked
func (t *TextField) SetLeadingIconOnClick(v func(e events.Event)) *TextField {
	t.LeadingIconOnClick = v
	return t
}

// SetTrailingIconOnClick sets the [TextField.TrailingIconOnClick]:
// if TrailingIcon is specified, the function to call when the trailing icon is clicked
func (t *TextField) SetTrailingIconOnClick(v func(e events.Event)) *TextField {
	t.TrailingIconOnClick = v
	return t
}

// SetCursorWidth sets the [TextField.CursorWidth]:
// width of cursor -- set from cursor-width property (inherited)
func (t *TextField) SetCursorWidth(v units.Value) *TextField { t.CursorWidth = v; return t }

// SetType sets the [TextField.Type]:
// the type of the text field
func (t *TextField) SetType(v TextFieldTypes) *TextField { t.Type = v; return t }

// SetPlaceholderColor sets the [TextField.PlaceholderColor]:
// the color used for the placeholder text; this should be set in Stylers like all other style properties; it is typically a highlighted version of the normal text color
func (t *TextField) SetPlaceholderColor(v color.RGBA) *TextField { t.PlaceholderColor = v; return t }

// SetSelectColor sets the [TextField.SelectColor]:
// the color used for the text selection background color on active text fields; this should be set in Stylers like all other style properties
func (t *TextField) SetSelectColor(v image.Image) *TextField { t.SelectColor = v; return t }

// SetCursorColor sets the [TextField.CursorColor]:
// the color used for the text field cursor (caret); this should be set in Stylers like all other style properties
func (t *TextField) SetCursorColor(v image.Image) *TextField { t.CursorColor = v; return t }

// SetMaxWidthReq sets the [TextField.MaxWidthReq]:
// maximum width that field will request, in characters, during GetSize process -- if 0 then is 50 -- ensures that large strings don't request super large values -- standard max-width can override
func (t *TextField) SetMaxWidthReq(v int) *TextField { t.MaxWidthReq = v; return t }

// SetSelectMode sets the [TextField.SelectMode]:
// if true, select text as cursor moves
func (t *TextField) SetSelectMode(v bool) *TextField { t.SelectMode = v; return t }

// SetTooltip sets the [TextField.Tooltip]
func (t *TextField) SetTooltip(v string) *TextField { t.Tooltip = v; return t }

// ToolbarType is the [gti.Type] for [Toolbar]
var ToolbarType = gti.AddType(&gti.Type{Name: "goki.dev/gi.Toolbar", IDName: "toolbar", Doc: "Toolbar is a [Frame] that is useful for holding [Button]s that do things.\nIt automatically moves items that do not fit into an overflow menu, and\nmanages additional items that are always placed onto this overflow menu.\nIn general it should be possible to use a single toolbar + overflow to\nmanage all an app's functionality, in a way that is portable across\nmobile and desktop environments.\nSee [Widget.ConfigToolbar] for the standard toolbar config method for\nany given widget, and [Scene.AppBars] for [ToolbarFuncs] for [Scene]\nelements who should be represented in the main AppBar (e.g., TopAppBar).", Directives: []gti.Directive{{Tool: "goki", Directive: "embedder"}}, Methods: []gti.Method{{Name: "StdOverflowMenu", Doc: "StdOverflowMenu adds standard overflow menu items.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Args: []string{"m"}}}, Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "OverflowItems", Doc: "items moved from the main toolbar, will be shown in the overflow menu"}, {Name: "OverflowMenus", Doc: "functions for overflow menu: use AddOverflowMenu to add.\nThese are processed in _reverse_ order (last in, first called)\nso that the default items are added last."}, {Name: "ToolbarFuncs", Doc: "ToolbarFuncs contains functions for configuring this toolbar,\ncalled on Config"}, {Name: "OverflowButton", Doc: "This is the overflow button"}}, Instance: &Toolbar{}})

// NewToolbar adds a new [Toolbar] with the given name to the given parent:
// Toolbar is a [Frame] that is useful for holding [Button]s that do things.
// It automatically moves items that do not fit into an overflow menu, and
// manages additional items that are always placed onto this overflow menu.
// In general it should be possible to use a single toolbar + overflow to
// manage all an app's functionality, in a way that is portable across
// mobile and desktop environments.
// See [Widget.ConfigToolbar] for the standard toolbar config method for
// any given widget, and [Scene.AppBars] for [ToolbarFuncs] for [Scene]
// elements who should be represented in the main AppBar (e.g., TopAppBar).
func NewToolbar(par ki.Ki, name ...string) *Toolbar {
	return par.NewChild(ToolbarType, name...).(*Toolbar)
}

// KiType returns the [*gti.Type] of [Toolbar]
func (t *Toolbar) KiType() *gti.Type { return ToolbarType }

// New returns a new [*Toolbar] value
func (t *Toolbar) New() ki.Ki { return &Toolbar{} }

// ToolbarEmbedder is an interface that all types that embed Toolbar satisfy
type ToolbarEmbedder interface {
	AsToolbar() *Toolbar
}

// AsToolbar returns the given value as a value of type Toolbar if the type
// of the given value embeds Toolbar, or nil otherwise
func AsToolbar(k ki.Ki) *Toolbar {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(ToolbarEmbedder); ok {
		return t.AsToolbar()
	}
	return nil
}

// AsToolbar satisfies the [ToolbarEmbedder] interface
func (t *Toolbar) AsToolbar() *Toolbar { return t }

// SetToolbarFuncs sets the [Toolbar.ToolbarFuncs]:
// ToolbarFuncs contains functions for configuring this toolbar,
// called on Config
func (t *Toolbar) SetToolbarFuncs(v ToolbarFuncs) *Toolbar { t.ToolbarFuncs = v; return t }

// SetOverflowButton sets the [Toolbar.OverflowButton]:
// This is the overflow button
func (t *Toolbar) SetOverflowButton(v *Button) *Toolbar { t.OverflowButton = v; return t }

// SetTooltip sets the [Toolbar.Tooltip]
func (t *Toolbar) SetTooltip(v string) *Toolbar { t.Tooltip = v; return t }

// SetStackTop sets the [Toolbar.StackTop]
func (t *Toolbar) SetStackTop(v int) *Toolbar { t.StackTop = v; return t }

// SetStripes sets the [Toolbar.Stripes]
func (t *Toolbar) SetStripes(v Stripes) *Toolbar { t.Stripes = v; return t }

// BasicBarType is the [gti.Type] for [BasicBar]
var BasicBarType = gti.AddType(&gti.Type{Name: "goki.dev/gi.BasicBar", IDName: "basic-bar", Doc: "BasicBar is just a styled Frame layout for holding buttons\nand other widgets.  Use this when the more advanced features\nof the Toolbar are not needed.", Embeds: []gti.Field{{Name: "Frame"}}, Instance: &BasicBar{}})

// NewBasicBar adds a new [BasicBar] with the given name to the given parent:
// BasicBar is just a styled Frame layout for holding buttons
// and other widgets.  Use this when the more advanced features
// of the Toolbar are not needed.
func NewBasicBar(par ki.Ki, name ...string) *BasicBar {
	return par.NewChild(BasicBarType, name...).(*BasicBar)
}

// KiType returns the [*gti.Type] of [BasicBar]
func (t *BasicBar) KiType() *gti.Type { return BasicBarType }

// New returns a new [*BasicBar] value
func (t *BasicBar) New() ki.Ki { return &BasicBar{} }

// SetTooltip sets the [BasicBar.Tooltip]
func (t *BasicBar) SetTooltip(v string) *BasicBar { t.Tooltip = v; return t }

// SetStackTop sets the [BasicBar.StackTop]
func (t *BasicBar) SetStackTop(v int) *BasicBar { t.StackTop = v; return t }

// SetStripes sets the [BasicBar.Stripes]
func (t *BasicBar) SetStripes(v Stripes) *BasicBar { t.Stripes = v; return t }

// WidgetBaseType is the [gti.Type] for [WidgetBase]
var WidgetBaseType = gti.AddType(&gti.Type{Name: "goki.dev/gi.WidgetBase", IDName: "widget-base", Doc: "WidgetBase is the base type for all Widget Widget elements, which are\nmanaged by a containing Layout, and use all 5 rendering passes.  All\nelemental widgets must support the ReadOnly and Selected states in a\nreasonable way (Selected only essential when also ReadOnly), so they can\nfunction appropriately in a chooser (e.g., SliceView or TableView) -- this\nincludes toggling selection on left mouse press.", Methods: []gti.Method{{Name: "Update", Doc: "Update calls Config and then ApplyStyle\non every Widget in the tree from me.\nThis should be used after any structural changes\nto currently-displayed widgets.\nIt wraps everything in UpdateStart / UpdateEndRender\nso node will render on next pass.\nCall SetNeedsLayout to also trigger a layout where needed.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}}, Embeds: []gti.Field{{Name: "Node"}}, Fields: []gti.Field{{Name: "Tooltip", Doc: "Tooltip is the text for the tooltip for this widget,\nwhich can use HTML formatting."}, {Name: "Parts", Doc: "Parts are a separate tree of sub-widgets that implement discrete parts\nof a widget.  Positions are relative to the parent widget.\nThese are fully managed by the parent widget"}, {Name: "Geom", Doc: "Geom has the full layout geometry for size and position of this Widget"}, {Name: "OverrideStyle", Doc: "If true, Override the computed styles and allow directly editing Style"}, {Name: "Styles", Doc: "Styles are styling settings for this widget.\nThese are set in SetApplyStyle which should be called after any Config\nchange (e.g., as done by the Update method).  See Stylers for functions\nthat set all of the styles, ordered from initial base defaults to later\nadded overrides."}, {Name: "Stylers", Doc: "Stylers are a slice of functions that are called in sequential\nascending order (so the last added styler is called last and\nthus overrides all other functions) to style the element.\nThese should be set using Style function, which can be called\nby end-user and internal code. FirstStylers and FinalStylers\nare called before and after these stylers, respectively."}, {Name: "FirstStylers", Doc: "FirstStylers are a slice of functions that are called in sequential\nascending order (so the last added styler is called last and\nthus overrides all other functions) to style the element.\nThese should be set using StyleFirst function, which can be called\nby end-user and internal code. These stylers are called before\nStylers and FinalStylers."}, {Name: "FinalStylers", Doc: "FinalStylers are a slice of functions that are called in sequential\nascending order (so the last added styler is called last and\nthus overrides all other functions) to style the element.\nThese should be set using StyleFinal function, which can be called\nby end-user and internal code. These stylers are called after\nFirstStylers and Stylers."}, {Name: "OnWidgetAdders", Doc: "A slice of functions to call on all widgets that are added as children\nto this widget or its children.  These functions are called in sequential\nascending order, so the last added one is called last and thus can\noverride anything set by the other ones. These should be set using\nOnWidgetAdded, which can be called by both end-user and internal code."}, {Name: "Listeners", Doc: "Listeners are event listener functions for processing events on this widget.\ntype specific Listeners are added in OnInit when the widget is initialized."}, {Name: "PriorityEvents", Doc: "PriorityEvents has event type(s) that this widget gets sent first.\nEvents are sent in depth-first order, so this enables outer container\nwidgets to get first access to these events."}, {Name: "ContextMenus", Doc: "ContextMenus is a slice of menu functions to call to construct\nthe widget's context menu on an [events.ContextMenu]. The\nfunctions are called in reverse order such that the elements\nadded in the last function are the first in the menu.\nContext menus should be added through [Widget.AddContextMenu].\nSeparators will be added between each context menu function."}, {Name: "Sc", Doc: "Sc is the overall Scene to which we belong. It is automatically\nby widgets whenever they are added to another widget parent.\nIt is passed to most Config, Layout, and Render functions as\na convenience."}, {Name: "StyMu", Doc: "mutex protecting the Style field"}, {Name: "BBoxMu", Doc: "mutex protecting the BBox fields"}}, Instance: &WidgetBase{}})

// NewWidgetBase adds a new [WidgetBase] with the given name to the given parent:
// WidgetBase is the base type for all Widget Widget elements, which are
// managed by a containing Layout, and use all 5 rendering passes.  All
// elemental widgets must support the ReadOnly and Selected states in a
// reasonable way (Selected only essential when also ReadOnly), so they can
// function appropriately in a chooser (e.g., SliceView or TableView) -- this
// includes toggling selection on left mouse press.
func NewWidgetBase(par ki.Ki, name ...string) *WidgetBase {
	return par.NewChild(WidgetBaseType, name...).(*WidgetBase)
}

// KiType returns the [*gti.Type] of [WidgetBase]
func (t *WidgetBase) KiType() *gti.Type { return WidgetBaseType }

// New returns a new [*WidgetBase] value
func (t *WidgetBase) New() ki.Ki { return &WidgetBase{} }

// SetTooltip sets the [WidgetBase.Tooltip]:
// Tooltip is the text for the tooltip for this widget,
// which can use HTML formatting.
func (t *WidgetBase) SetTooltip(v string) *WidgetBase { t.Tooltip = v; return t }

var _ = gti.AddFunc(&gti.Func{Name: "goki.dev/gi.UpdateAll", Doc: "UpdateAll updates all windows and triggers a full render rebuild.\nIt is typically called when user settings are changed.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}})
