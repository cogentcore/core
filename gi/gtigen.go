// Code generated by "goki generate"; DO NOT EDIT.

package gi

import (
	"goki.dev/gti"
	"goki.dev/ki/v2"
	"goki.dev/ordmap"
)

// ActionType is the [gti.Type] for [Action]
var ActionType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Action",
	Doc:        "Action is a button widget that can display a text label and / or an icon\nand / or a keyboard shortcut -- this is what is put in menus, menubars, and\ntoolbars, and also for any standalone simple action.  The default styling\ndiffers depending on whether it is in a Menu versus a MenuBar or ToolBar --\nthis is controlled by the Class which is automatically set to\nmenu, menubar, or toolbar",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Data", &gti.Field{Name: "Data", Type: "any", Doc: "[view: -] optional data that is sent with the ActionSig when it is emitted", Directives: gti.Directives{}}},
		{"ActionSig", &gti.Field{Name: "ActionSig", Type: "ki.Signal", Doc: "[view: -] signal for action -- does not have a signal type, as there is only one type: Action triggered -- data is Data of this action", Directives: gti.Directives{}}},
		{"UpdateFunc", &gti.Field{Name: "UpdateFunc", Type: "func(act *Action)", Doc: "[view: -] optional function that is called to update state of action (typically updating Active state) -- called automatically for menus prior to showing", Directives: gti.Directives{}}},
		{"Type", &gti.Field{Name: "Type", Type: "ActionTypes", Doc: "the type of action", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ButtonBase", &gti.Field{Name: "ButtonBase", Type: "ButtonBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Action{},
})

// NewAction adds a new [Action] with
// the given name to the given parent.
func NewAction(par ki.Ki, name string) *Action {
	return par.NewChild(ActionType, name).(*Action)
}

// KiType returns the [*gti.Type] of [Action]
func (t *Action) KiType() *gti.Type {
	return ActionType
}

// New returns a new [*Action] value
func (t *Action) New() ki.Ki {
	return &Action{}
}

// MenuBarType is the [gti.Type] for [MenuBar]
var MenuBarType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.MenuBar",
	Doc:        "MenuBar is a Layout (typically LayoutHoriz) that renders a gradient\nbackground and has convenience methods for adding menus.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MainMenu", &gti.Field{Name: "MainMenu", Type: "bool", Doc: "is this the main menu bar for a window?  controls whether displayed on macOS", Directives: gti.Directives{}}},
		{"OSMainMenus", &gti.Field{Name: "OSMainMenus", Type: "map[string]*Action", Doc: "map of main menu items for callback from OS main menu (MacOS specific)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &MenuBar{},
})

// NewMenuBar adds a new [MenuBar] with
// the given name to the given parent.
func NewMenuBar(par ki.Ki, name string) *MenuBar {
	return par.NewChild(MenuBarType, name).(*MenuBar)
}

// KiType returns the [*gti.Type] of [MenuBar]
func (t *MenuBar) KiType() *gti.Type {
	return MenuBarType
}

// New returns a new [*MenuBar] value
func (t *MenuBar) New() ki.Ki {
	return &MenuBar{}
}

// ToolBarType is the [gti.Type] for [ToolBar]
var ToolBarType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.ToolBar",
	Doc:        "ToolBar is a Layout (typically LayoutHoriz) that renders a gradient\nbackground and is useful for holding Actions that do things",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ToolBar{},
})

// NewToolBar adds a new [ToolBar] with
// the given name to the given parent.
func NewToolBar(par ki.Ki, name string) *ToolBar {
	return par.NewChild(ToolBarType, name).(*ToolBar)
}

// KiType returns the [*gti.Type] of [ToolBar]
func (t *ToolBar) KiType() *gti.Type {
	return ToolBarType
}

// New returns a new [*ToolBar] value
func (t *ToolBar) New() ki.Ki {
	return &ToolBar{}
}

// BitmapType is the [gti.Type] for [Bitmap]
var BitmapType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Bitmap",
	Doc:        "Bitmap is a Widget that is optimized to render a static bitmap image --\nit expects to be a terminal node and does NOT call rendering etc on its\nchildren.  It is particularly useful for overlays in drag-n-drop uses --\ncan grab the image of another vp and show that",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Filename", &gti.Field{Name: "Filename", Type: "FileName", Doc: "file name of image loaded -- set by OpenImage", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "image.Point", Doc: "size of the image", Directives: gti.Directives{}}},
		{"Pixels", &gti.Field{Name: "Pixels", Type: "*image.RGBA", Doc: "[view: -] the bitmap image", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Bitmap{},
})

// NewBitmap adds a new [Bitmap] with
// the given name to the given parent.
func NewBitmap(par ki.Ki, name string) *Bitmap {
	return par.NewChild(BitmapType, name).(*Bitmap)
}

// KiType returns the [*gti.Type] of [Bitmap]
func (t *Bitmap) KiType() *gti.Type {
	return BitmapType
}

// New returns a new [*Bitmap] value
func (t *Bitmap) New() ki.Ki {
	return &Bitmap{}
}

// ButtonBoxType is the [gti.Type] for [ButtonBox]
var ButtonBoxType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.ButtonBox",
	Doc:        "ButtonBox is a widget for containing a set of CheckBox buttons.\nIt can optionally enforce mutual excusivity (i.e., Radio Buttons).\nThe buttons are all in the Parts of the widget and the Parts layout\ndetermines how they are displayed.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Items", &gti.Field{Name: "Items", Type: "[]string", Doc: "the list of items (checbox button labels)", Directives: gti.Directives{}}},
		{"Tooltips", &gti.Field{Name: "Tooltips", Type: "[]string", Doc: "an optional list of tooltips displayed on hover for checkbox items; the indices for tooltips correspond to those for items", Directives: gti.Directives{}}},
		{"Mutex", &gti.Field{Name: "Mutex", Type: "bool", Doc: "make the items mutually exclusive -- checking one turns off all the others", Directives: gti.Directives{}}},
		{"ButtonSig", &gti.Field{Name: "ButtonSig", Type: "ki.Signal", Doc: "[view: -] signal for button box, when any button is updated -- the signal type is the index of the selected item, and the data is the label", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ButtonBox{},
})

// NewButtonBox adds a new [ButtonBox] with
// the given name to the given parent.
func NewButtonBox(par ki.Ki, name string) *ButtonBox {
	return par.NewChild(ButtonBoxType, name).(*ButtonBox)
}

// KiType returns the [*gti.Type] of [ButtonBox]
func (t *ButtonBox) KiType() *gti.Type {
	return ButtonBoxType
}

// New returns a new [*ButtonBox] value
func (t *ButtonBox) New() ki.Ki {
	return &ButtonBox{}
}

// ButtonBaseType is the [gti.Type] for [ButtonBase]
var ButtonBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.ButtonBase",
	Doc:        "ButtonBase has common button functionality for all buttons, including\nButton, Action, MenuButton, CheckBox, etc",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Text", &gti.Field{Name: "Text", Type: "string", Doc: "label for the button -- if blank then no label is presented", Directives: gti.Directives{}}},
		{"Icon", &gti.Field{Name: "Icon", Type: "icons.Icon", Doc: "[view: show-name] optional icon for the button -- different buttons can configure this in different ways relative to the text if both are present", Directives: gti.Directives{}}},
		{"Indicator", &gti.Field{Name: "Indicator", Type: "icons.Icon", Doc: "[view: show-name] name of the menu indicator icon to present, or blank or 'nil' or 'none' -- shown automatically when there are Menu elements present unless 'none' is set", Directives: gti.Directives{}}},
		{"Shortcut", &gti.Field{Name: "Shortcut", Type: "key.Chord", Doc: "optional shortcut keyboard chord to trigger this action -- always window-wide in scope, and should generally not conflict other shortcuts (a log message will be emitted if so).  Shortcuts are processed after all other processing of keyboard input.  Use Command for Control / Meta (Mac Command key) per platform.  These are only set automatically for Menu items, NOT for items in ToolBar or buttons somewhere, but the tooltip for buttons will show the shortcut if set.", Directives: gti.Directives{}}},
		{"WasPressed", &gti.Field{Name: "WasPressed", Type: "bool", Doc: "whether the button has been pressed (typically accessed in an ButtonRelease event)", Directives: gti.Directives{}}},
		{"ButtonSig", &gti.Field{Name: "ButtonSig", Type: "ki.Signal", Doc: "[view: -] signal for button -- see ButtonSignals for the types", Directives: gti.Directives{}}},
		{"Menu", &gti.Field{Name: "Menu", Type: "MenuActions", Doc: "the menu items for this menu -- typically add Action elements for menus, along with separators", Directives: gti.Directives{}}},
		{"MakeMenuFunc", &gti.Field{Name: "MakeMenuFunc", Type: "MakeMenuFunc", Doc: "[view: -] set this to make a menu on demand -- if set then this button acts like a menu button", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ButtonBase{},
})

// NewButtonBase adds a new [ButtonBase] with
// the given name to the given parent.
func NewButtonBase(par ki.Ki, name string) *ButtonBase {
	return par.NewChild(ButtonBaseType, name).(*ButtonBase)
}

// KiType returns the [*gti.Type] of [ButtonBase]
func (t *ButtonBase) KiType() *gti.Type {
	return ButtonBaseType
}

// New returns a new [*ButtonBase] value
func (t *ButtonBase) New() ki.Ki {
	return &ButtonBase{}
}

// ButtonType is the [gti.Type] for [Button]
var ButtonType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Button",
	Doc:        "Button is a standard command button -- PushButton in Qt Widgets, and Button\nin Qt Quick -- by default it puts the icon to the left and the text to the\nright",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Type", &gti.Field{Name: "Type", Type: "ButtonTypes", Doc: "the type of button (default, primary, secondary, etc)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ButtonBase", &gti.Field{Name: "ButtonBase", Type: "ButtonBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Button{},
})

// NewButton adds a new [Button] with
// the given name to the given parent.
func NewButton(par ki.Ki, name string) *Button {
	return par.NewChild(ButtonType, name).(*Button)
}

// KiType returns the [*gti.Type] of [Button]
func (t *Button) KiType() *gti.Type {
	return ButtonType
}

// New returns a new [*Button] value
func (t *Button) New() ki.Ki {
	return &Button{}
}

// CheckBoxType is the [gti.Type] for [CheckBox]
var CheckBoxType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.CheckBox",
	Doc:        "CheckBox toggles between a checked and unchecked state",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"IconOff", &gti.Field{Name: "IconOff", Type: "icons.Icon", Doc: "[view: show-name] icon to use for the off, unchecked state of the icon -- plain Icon holds the On state -- can be set with icon-off property", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ButtonBase", &gti.Field{Name: "ButtonBase", Type: "ButtonBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &CheckBox{},
})

// NewCheckBox adds a new [CheckBox] with
// the given name to the given parent.
func NewCheckBox(par ki.Ki, name string) *CheckBox {
	return par.NewChild(CheckBoxType, name).(*CheckBox)
}

// KiType returns the [*gti.Type] of [CheckBox]
func (t *CheckBox) KiType() *gti.Type {
	return CheckBoxType
}

// New returns a new [*CheckBox] value
func (t *CheckBox) New() ki.Ki {
	return &CheckBox{}
}

// ComboBoxType is the [gti.Type] for [ComboBox]
var ComboBoxType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.ComboBox",
	Doc:        "ComboBox is for selecting items from a dropdown list, with an optional\nedit TextField for typing directly.\nThe items can be of any type, including enum values -- they are converted\nto strings for the display.  If the items are [icons.Icon] type, then they\nare displayed using icons instead.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Editable", &gti.Field{Name: "Editable", Type: "bool", Doc: "provide a text field for editing the value, or just a button for selecting items?  Set the editable property", Directives: gti.Directives{}}},
		{"CurVal", &gti.Field{Name: "CurVal", Type: "any", Doc: "current selected value", Directives: gti.Directives{}}},
		{"CurIndex", &gti.Field{Name: "CurIndex", Type: "int", Doc: "current index in list of possible items", Directives: gti.Directives{}}},
		{"Items", &gti.Field{Name: "Items", Type: "[]any", Doc: "items available for selection", Directives: gti.Directives{}}},
		{"Tooltips", &gti.Field{Name: "Tooltips", Type: "[]string", Doc: "an optional list of tooltips displayed on hover for combobox items; the indices for tooltips correspond to those for items", Directives: gti.Directives{}}},
		{"Placeholder", &gti.Field{Name: "Placeholder", Type: "string", Doc: "if Editable is set to true, text that is displayed in the text field when it is empty, in a lower-contrast manner", Directives: gti.Directives{}}},
		{"ItemsMenu", &gti.Field{Name: "ItemsMenu", Type: "MenuActions", Doc: "the menu of actions for selecting items -- automatically generated from Items", Directives: gti.Directives{}}},
		{"Type", &gti.Field{Name: "Type", Type: "ComboBoxTypes", Doc: "the type of combo box", Directives: gti.Directives{}}},
		{"ComboSig", &gti.Field{Name: "ComboSig", Type: "ki.Signal", Doc: "[view: -] signal for combo box, when a new value has been selected -- the signal type is the index of the selected item, and the data is the value", Directives: gti.Directives{}}},
		{"MaxLength", &gti.Field{Name: "MaxLength", Type: "int", Doc: "maximum label length (in runes)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ButtonBase", &gti.Field{Name: "ButtonBase", Type: "ButtonBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ComboBox{},
})

// NewComboBox adds a new [ComboBox] with
// the given name to the given parent.
func NewComboBox(par ki.Ki, name string) *ComboBox {
	return par.NewChild(ComboBoxType, name).(*ComboBox)
}

// KiType returns the [*gti.Type] of [ComboBox]
func (t *ComboBox) KiType() *gti.Type {
	return ComboBoxType
}

// New returns a new [*ComboBox] value
func (t *ComboBox) New() ki.Ki {
	return &ComboBox{}
}

// CompleteType is the [gti.Type] for [Complete]
var CompleteType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Complete",
	Doc:        "Complete holds the current completion data and functions to call for building\nthe list of possible completions and for editing text after a completion is selected",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MatchFunc", &gti.Field{Name: "MatchFunc", Type: "complete.MatchFunc", Doc: "function to get the list of possible completions", Directives: gti.Directives{}}},
		{"LookupFunc", &gti.Field{Name: "LookupFunc", Type: "complete.LookupFunc", Doc: "function to get the text to show for lookup", Directives: gti.Directives{}}},
		{"EditFunc", &gti.Field{Name: "EditFunc", Type: "complete.EditFunc", Doc: "function to edit text using the selected completion", Directives: gti.Directives{}}},
		{"Context", &gti.Field{Name: "Context", Type: "any", Doc: "the object that implements complete.Func", Directives: gti.Directives{}}},
		{"SrcLn", &gti.Field{Name: "SrcLn", Type: "int", Doc: "line number in source that completion is operating on, if relevant", Directives: gti.Directives{}}},
		{"SrcCh", &gti.Field{Name: "SrcCh", Type: "int", Doc: "character position in source that completion is operating on", Directives: gti.Directives{}}},
		{"Completions", &gti.Field{Name: "Completions", Type: "complete.Completions", Doc: "the list of potential completions", Directives: gti.Directives{}}},
		{"Seed", &gti.Field{Name: "Seed", Type: "string", Doc: "current completion seed", Directives: gti.Directives{}}},
		{"CompleteSig", &gti.Field{Name: "CompleteSig", Type: "ki.Signal", Doc: "[view: -] signal for complete -- see CompleteSignals for the types", Directives: gti.Directives{}}},
		{"Completion", &gti.Field{Name: "Completion", Type: "string", Doc: "the user's completion selection'", Directives: gti.Directives{}}},
		{"Sc", &gti.Field{Name: "Sc", Type: "*Scene", Doc: "the scene where the current popup menu is presented", Directives: gti.Directives{}}},
		{"DelayTimer", &gti.Field{Name: "DelayTimer", Type: "*time.Timer", Doc: "", Directives: gti.Directives{}}},
		{"DelayMu", &gti.Field{Name: "DelayMu", Type: "sync.Mutex", Doc: "", Directives: gti.Directives{}}},
		{"ShowMu", &gti.Field{Name: "ShowMu", Type: "sync.Mutex", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Complete{},
})

// NewComplete adds a new [Complete] with
// the given name to the given parent.
func NewComplete(par ki.Ki, name string) *Complete {
	return par.NewChild(CompleteType, name).(*Complete)
}

// KiType returns the [*gti.Type] of [Complete]
func (t *Complete) KiType() *gti.Type {
	return CompleteType
}

// New returns a new [*Complete] value
func (t *Complete) New() ki.Ki {
	return &Complete{}
}

// StyleSheetType is the [gti.Type] for [StyleSheet]
var StyleSheetType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.StyleSheet",
	Doc:        "StyleSheet is a Node2D node that contains a stylesheet -- property values\ncontained in this sheet can be transformed into ki.Props and set in CSS\nfield of appropriate node",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Sheet", &gti.Field{Name: "Sheet", Type: "*css.Stylesheet", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &StyleSheet{},
})

// NewStyleSheet adds a new [StyleSheet] with
// the given name to the given parent.
func NewStyleSheet(par ki.Ki, name string) *StyleSheet {
	return par.NewChild(StyleSheetType, name).(*StyleSheet)
}

// KiType returns the [*gti.Type] of [StyleSheet]
func (t *StyleSheet) KiType() *gti.Type {
	return StyleSheetType
}

// New returns a new [*StyleSheet] value
func (t *StyleSheet) New() ki.Ki {
	return &StyleSheet{}
}

// FrameType is the [gti.Type] for [Frame]
var FrameType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Frame",
	Doc:        "Frame is a Layout that renders a background according to the\nbackground-color style setting, and optional striping for grid layouts",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Stripes", &gti.Field{Name: "Stripes", Type: "Stripes", Doc: "options for striped backgrounds -- rendered as darker bands relative to background color", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Frame{},
})

// NewFrame adds a new [Frame] with
// the given name to the given parent.
func NewFrame(par ki.Ki, name string) *Frame {
	return par.NewChild(FrameType, name).(*Frame)
}

// KiType returns the [*gti.Type] of [Frame]
func (t *Frame) KiType() *gti.Type {
	return FrameType
}

// New returns a new [*Frame] value
func (t *Frame) New() ki.Ki {
	return &Frame{}
}

// IconType is the [gti.Type] for [Icon]
var IconType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Icon",
	Doc:        "Icon contains a svg.SVG element.\nThe rendered version is cached for a given size.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"IconNm", &gti.Field{Name: "IconNm", Type: "icons.Icon", Doc: "icon name that has been set -- optimizes to prevent reloading of icon", Directives: gti.Directives{}}},
		{"Filename", &gti.Field{Name: "Filename", Type: "string", Doc: "file name for the loaded icon, if loaded", Directives: gti.Directives{}}},
		{"SVG", &gti.Field{Name: "SVG", Type: "svg.SVG", Doc: "SVG drawing", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Icon{},
})

// NewIcon adds a new [Icon] with
// the given name to the given parent.
func NewIcon(par ki.Ki, name string) *Icon {
	return par.NewChild(IconType, name).(*Icon)
}

// KiType returns the [*gti.Type] of [Icon]
func (t *Icon) KiType() *gti.Type {
	return IconType
}

// New returns a new [*Icon] value
func (t *Icon) New() ki.Ki {
	return &Icon{}
}

// LabelType is the [gti.Type] for [Label]
var LabelType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Label",
	Doc:        "Label is a widget for rendering text labels -- supports full widget model\nincluding box rendering, and full HTML styling, including links -- LinkSig\nemits link with data of URL -- opens default browser if nobody receiving\nsignal.  The default white-space option is 'pre' -- set to 'normal' or\nother options to get word-wrapping etc.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Text", &gti.Field{Name: "Text", Type: "string", Doc: "label to display", Directives: gti.Directives{}}},
		{"Selectable", &gti.Field{Name: "Selectable", Type: "bool", Doc: "is this label selectable? if so, it will change background color in response to selection events and update selection state on mouse clicks", Directives: gti.Directives{}}},
		{"Redrawable", &gti.Field{Name: "Redrawable", Type: "bool", Doc: "is this label going to be redrawn frequently without an overall full re-render?  if so, you need to set this flag to avoid weird overlapping rendering results from antialiasing.  Also, if the label will change dynamically, this must be set to true, otherwise labels will illegibly overlay on top of each other.", Directives: gti.Directives{}}},
		{"Type", &gti.Field{Name: "Type", Type: "LabelTypes", Doc: "the type of label", Directives: gti.Directives{}}},
		{"LinkSig", &gti.Field{Name: "LinkSig", Type: "ki.Signal", Doc: "[view: -] signal for clicking on a link -- data is a string of the URL -- if nobody receiving this signal, calls TextLinkHandler then URLHandler", Directives: gti.Directives{}}},
		{"TextRender", &gti.Field{Name: "TextRender", Type: "girl.Text", Doc: "render data for text label", Directives: gti.Directives{}}},
		{"RenderPos", &gti.Field{Name: "RenderPos", Type: "mat32.Vec2", Doc: "position offset of start of text rendering, from last render -- AllocPos plus alignment factors for center, right etc.", Directives: gti.Directives{}}},
		{"CurBackgroundColor", &gti.Field{Name: "CurBackgroundColor", Type: "color.RGBA", Doc: "current background color -- grabbed when rendering for first time, and used when toggling off of selected mode, or for redrawable, to wipe out bg", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Label{},
})

// NewLabel adds a new [Label] with
// the given name to the given parent.
func NewLabel(par ki.Ki, name string) *Label {
	return par.NewChild(LabelType, name).(*Label)
}

// KiType returns the [*gti.Type] of [Label]
func (t *Label) KiType() *gti.Type {
	return LabelType
}

// New returns a new [*Label] value
func (t *Label) New() ki.Ki {
	return &Label{}
}

// LayoutType is the [gti.Type] for [Layout]
var LayoutType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Layout",
	Doc:        "Layout is the primary node type responsible for organizing the sizes\nand positions of child widgets. It does not render, only organize,\nso properties like background color will have no effect.\nAll arbitrary collections of widgets should generally be contained\nwithin a layout -- otherwise the parent widget must take over\nresponsibility for positioning.\nThe alignment is NOT inherited by default so must be specified per\nchild, except that the parent alignment is used within the relevant\ndimension (e.g., horizontal-align for a LayoutHoriz layout,\nto determine left, right, center, justified).\nLayouts can automatically add scrollbars depending on the Overflow\nlayout style.\nFor a Grid layout, the 'columns' property should generally be set\nto the desired number of columns, from which the number of rows\nis computed -- otherwise it uses the square root of number of\nelements.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Lay", &gti.Field{Name: "Lay", Type: "Layouts", Doc: "type of layout to use", Directives: gti.Directives{}}},
		{"Spacing", &gti.Field{Name: "Spacing", Type: "units.Value", Doc: "extra space to add between elements in the layout", Directives: gti.Directives{}}},
		{"StackTop", &gti.Field{Name: "StackTop", Type: "int", Doc: "for Stacked layout, index of node to use as the top of the stack -- only node at this index is rendered -- if not a valid index, nothing is rendered", Directives: gti.Directives{}}},
		{"StackTopOnly", &gti.Field{Name: "StackTopOnly", Type: "bool", Doc: "for stacked layout, only layout the top widget -- this is appropriate for e.g., tab layout, which does a full redraw on stack changes, but not for e.g., check boxes which don't", Directives: gti.Directives{}}},
		{"ChildSize", &gti.Field{Name: "ChildSize", Type: "mat32.Vec2", Doc: "total max size of children as laid out", Directives: gti.Directives{}}},
		{"ExtraSize", &gti.Field{Name: "ExtraSize", Type: "mat32.Vec2", Doc: "extra size in each dim due to scrollbars we add", Directives: gti.Directives{}}},
		{"HasScroll", &gti.Field{Name: "HasScroll", Type: "[2]bool", Doc: "whether scrollbar is used for given dim", Directives: gti.Directives{}}},
		{"Scrolls", &gti.Field{Name: "Scrolls", Type: "[2]*ScrollBar", Doc: "scroll bars -- we fully manage them as needed", Directives: gti.Directives{}}},
		{"GridSize", &gti.Field{Name: "GridSize", Type: "image.Point", Doc: "computed size of a grid layout based on all the constraints -- computed during GetSize pass", Directives: gti.Directives{}}},
		{"GridData", &gti.Field{Name: "GridData", Type: "[RowColN][]GridData", Doc: "grid data for rows in [0] and cols in [1]", Directives: gti.Directives{}}},
		{"FlowBreaks", &gti.Field{Name: "FlowBreaks", Type: "[]int", Doc: "line breaks for flow layout", Directives: gti.Directives{}}},
		{"NeedsRedo", &gti.Field{Name: "NeedsRedo", Type: "bool", Doc: "true if this layout got a redo = true on previous iteration -- otherwise it just skips any re-layout on subsequent iteration", Directives: gti.Directives{}}},
		{"FocusName", &gti.Field{Name: "FocusName", Type: "string", Doc: "accumulated name to search for when keys are typed", Directives: gti.Directives{}}},
		{"FocusNameTime", &gti.Field{Name: "FocusNameTime", Type: "time.Time", Doc: "time of last focus name event -- for timeout", Directives: gti.Directives{}}},
		{"FocusNameLast", &gti.Field{Name: "FocusNameLast", Type: "ki.Ki", Doc: "last element focused on -- used as a starting point if name is the same", Directives: gti.Directives{}}},
		{"ScrollsOff", &gti.Field{Name: "ScrollsOff", Type: "bool", Doc: "scrollbars have been manually turned off due to layout being invisible -- must be reactivated when re-visible", Directives: gti.Directives{}}},
		{"ScrollSig", &gti.Field{Name: "ScrollSig", Type: "ki.Signal", Doc: "[view: -] signal for layout scrolling -- sends signal whenever layout is scrolled due to user input -- signal type is dimension (mat32.X or Y) and data is new position (not delta)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Layout{},
})

// NewLayout adds a new [Layout] with
// the given name to the given parent.
func NewLayout(par ki.Ki, name string) *Layout {
	return par.NewChild(LayoutType, name).(*Layout)
}

// KiType returns the [*gti.Type] of [Layout]
func (t *Layout) KiType() *gti.Type {
	return LayoutType
}

// New returns a new [*Layout] value
func (t *Layout) New() ki.Ki {
	return &Layout{}
}

// StretchType is the [gti.Type] for [Stretch]
var StretchType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Stretch",
	Doc:        "Stretch adds an infinitely stretchy element for spacing out layouts\n(max-size = -1) set the width / height property to determine how much it\ntakes relative to other stretchy elements",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Stretch{},
})

// NewStretch adds a new [Stretch] with
// the given name to the given parent.
func NewStretch(par ki.Ki, name string) *Stretch {
	return par.NewChild(StretchType, name).(*Stretch)
}

// KiType returns the [*gti.Type] of [Stretch]
func (t *Stretch) KiType() *gti.Type {
	return StretchType
}

// New returns a new [*Stretch] value
func (t *Stretch) New() ki.Ki {
	return &Stretch{}
}

// SpaceType is the [gti.Type] for [Space]
var SpaceType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Space",
	Doc:        "Space adds a fixed sized (1 ch x 1 em by default) blank space to a layout -- set\nwidth / height property to change",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Space{},
})

// NewSpace adds a new [Space] with
// the given name to the given parent.
func NewSpace(par ki.Ki, name string) *Space {
	return par.NewChild(SpaceType, name).(*Space)
}

// KiType returns the [*gti.Type] of [Space]
func (t *Space) KiType() *gti.Type {
	return SpaceType
}

// New returns a new [*Space] value
func (t *Space) New() ki.Ki {
	return &Space{}
}

// SeparatorType is the [gti.Type] for [Separator]
var SeparatorType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Separator",
	Doc:        "Separator draws a vertical or horizontal line",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Horiz", &gti.Field{Name: "Horiz", Type: "bool", Doc: "is this a horizontal separator -- otherwise vertical", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Separator{},
})

// NewSeparator adds a new [Separator] with
// the given name to the given parent.
func NewSeparator(par ki.Ki, name string) *Separator {
	return par.NewChild(SeparatorType, name).(*Separator)
}

// KiType returns the [*gti.Type] of [Separator]
func (t *Separator) KiType() *gti.Type {
	return SeparatorType
}

// New returns a new [*Separator] value
func (t *Separator) New() ki.Ki {
	return &Separator{}
}

var _ = gti.AddType(&gti.Type{
	Name: "goki.dev/gi/v2/gi.ColorPrefs",
	Doc:  "ColorPrefs specify colors for all major categories of GUI elements, and are\nused in the default styles.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"HiStyle", &gti.Field{Name: "HiStyle", Type: "HiStyleName", Doc: "text highilighting style / theme", Directives: gti.Directives{}}},
		{"Font", &gti.Field{Name: "Font", Type: "color.RGBA", Doc: "default font / pen color", Directives: gti.Directives{}}},
		{"Background", &gti.Field{Name: "Background", Type: "color.RGBA", Doc: "default background color", Directives: gti.Directives{}}},
		{"Shadow", &gti.Field{Name: "Shadow", Type: "color.RGBA", Doc: "color for shadows -- should generally be a darker shade of the background color", Directives: gti.Directives{}}},
		{"Border", &gti.Field{Name: "Border", Type: "color.RGBA", Doc: "default border color, for button, frame borders, etc", Directives: gti.Directives{}}},
		{"Control", &gti.Field{Name: "Control", Type: "color.RGBA", Doc: "default main color for controls: buttons, etc", Directives: gti.Directives{}}},
		{"Icon", &gti.Field{Name: "Icon", Type: "color.RGBA", Doc: "color for icons or other solidly-colored, small elements", Directives: gti.Directives{}}},
		{"Select", &gti.Field{Name: "Select", Type: "color.RGBA", Doc: "color for selected elements", Directives: gti.Directives{}}},
		{"Highlight", &gti.Field{Name: "Highlight", Type: "color.RGBA", Doc: "color for highlight background", Directives: gti.Directives{}}},
		{"Link", &gti.Field{Name: "Link", Type: "color.RGBA", Doc: "color for links in text etc", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name: "goki.dev/gi/v2/gi.EditorPrefs",
	Doc:  "EditorPrefs contains editor preferences.  It can also be set\nfrom ki.Props style properties.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"TabSize", &gti.Field{Name: "TabSize", Type: "int", Doc: "size of a tab, in chars -- also determines indent level for space indent", Directives: gti.Directives{}}},
		{"SpaceIndent", &gti.Field{Name: "SpaceIndent", Type: "bool", Doc: "use spaces for indentation, otherwise tabs", Directives: gti.Directives{}}},
		{"WordWrap", &gti.Field{Name: "WordWrap", Type: "bool", Doc: "wrap lines at word boundaries -- otherwise long lines scroll off the end", Directives: gti.Directives{}}},
		{"LineNos", &gti.Field{Name: "LineNos", Type: "bool", Doc: "show line numbers", Directives: gti.Directives{}}},
		{"Completion", &gti.Field{Name: "Completion", Type: "bool", Doc: "use the completion system to suggest options while typing", Directives: gti.Directives{}}},
		{"SpellCorrect", &gti.Field{Name: "SpellCorrect", Type: "bool", Doc: "suggest corrections for unknown words while typing", Directives: gti.Directives{}}},
		{"AutoIndent", &gti.Field{Name: "AutoIndent", Type: "bool", Doc: "automatically indent lines when enter, tab, }, etc pressed", Directives: gti.Directives{}}},
		{"EmacsUndo", &gti.Field{Name: "EmacsUndo", Type: "bool", Doc: "use emacs-style undo, where after a non-undo command, all the current undo actions are added to the undo stack, such that a subsequent undo is actually a redo", Directives: gti.Directives{}}},
		{"DepthColor", &gti.Field{Name: "DepthColor", Type: "bool", Doc: "colorize the background according to nesting depth", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name: "goki.dev/gi/v2/gi.FavPathItem",
	Doc:  "FavPathItem represents one item in a favorite path list, for display of\nfavorites.  Is an ordered list instead of a map because user can organize\nin order",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Ic", &gti.Field{Name: "Ic", Type: "icons.Icon", Doc: "icon for item", Directives: gti.Directives{}}},
		{"Name", &gti.Field{Name: "Name", Type: "string", Doc: "name of the favorite item", Directives: gti.Directives{}}},
		{"Path", &gti.Field{Name: "Path", Type: "string", Doc: "[tableview: -select]", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SliderBaseType is the [gti.Type] for [SliderBase]
var SliderBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.SliderBase",
	Doc:        "SliderBase has common slider functionality -- two major modes: ValThumb =\nfalse is a slider with a fixed-size thumb knob, while = true has a thumb\nthat represents a value, as in a scrollbar, and the scrolling range is size\n- thumbsize",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Value", &gti.Field{Name: "Value", Type: "float32", Doc: "current value", Directives: gti.Directives{}}},
		{"EmitValue", &gti.Field{Name: "EmitValue", Type: "float32", Doc: "previous emitted value - don't re-emit if it is the same", Directives: gti.Directives{}}},
		{"Min", &gti.Field{Name: "Min", Type: "float32", Doc: "minimum value in range", Directives: gti.Directives{}}},
		{"Max", &gti.Field{Name: "Max", Type: "float32", Doc: "maximum value in range", Directives: gti.Directives{}}},
		{"Step", &gti.Field{Name: "Step", Type: "float32", Doc: "smallest step size to increment", Directives: gti.Directives{}}},
		{"PageStep", &gti.Field{Name: "PageStep", Type: "float32", Doc: "larger PageUp / Dn step size", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "float32", Doc: "size of the slide box in the relevant dimension -- range of motion -- exclusive of spacing", Directives: gti.Directives{}}},
		{"ThSize", &gti.Field{Name: "ThSize", Type: "float32", Doc: "computed size of the thumb -- if ValThumb then this is auto-sized based on ThumbVal and is subtracted from Size in computing Value -- this is the display size version subject to SliderMinThumbSize", Directives: gti.Directives{}}},
		{"ThSizeReal", &gti.Field{Name: "ThSizeReal", Type: "float32", Doc: "computed size of the thumb, without any SliderMinThumbSize limitation -- use this for more accurate calculations of true value", Directives: gti.Directives{}}},
		{"ThumbSize", &gti.Field{Name: "ThumbSize", Type: "units.Value", Doc: "styled fixed size of the thumb", Directives: gti.Directives{}}},
		{"Prec", &gti.Field{Name: "Prec", Type: "int", Doc: "specifies the precision of decimal places (total, not after the decimal point) to use in representing the number -- this helps to truncate small weird floating point values in the nether regions", Directives: gti.Directives{}}},
		{"Icon", &gti.Field{Name: "Icon", Type: "icons.Icon", Doc: "[view: show-name] optional icon for the dragging knob", Directives: gti.Directives{}}},
		{"ValThumb", &gti.Field{Name: "ValThumb", Type: "bool", Doc: "if true, has a proportionally-sized thumb knob reflecting another value -- e.g., the amount visible in a scrollbar, and thumb is completely inside Size -- otherwise ThumbSize affects Size so that full Size range can be traversed", Directives: gti.Directives{}}},
		{"ThumbVal", &gti.Field{Name: "ThumbVal", Type: "float32", Doc: "value that the thumb represents, in the same units", Directives: gti.Directives{}}},
		{"Pos", &gti.Field{Name: "Pos", Type: "float32", Doc: "logical position of the slider relative to Size", Directives: gti.Directives{}}},
		{"DragPos", &gti.Field{Name: "DragPos", Type: "float32", Doc: "underlying drag position of slider -- not subject to snapping", Directives: gti.Directives{}}},
		{"Dim", &gti.Field{Name: "Dim", Type: "mat32.Dims", Doc: "dimension along which the slider slides", Directives: gti.Directives{}}},
		{"Tracking", &gti.Field{Name: "Tracking", Type: "bool", Doc: "if true, will send continuous updates of value changes as user moves the slider -- otherwise only at the end -- see TrackThr for a threshold on amount of change", Directives: gti.Directives{}}},
		{"TrackThr", &gti.Field{Name: "TrackThr", Type: "float32", Doc: "threshold for amount of change in scroll value before emitting a signal in Tracking mode", Directives: gti.Directives{}}},
		{"Snap", &gti.Field{Name: "Snap", Type: "bool", Doc: "snap the values to Step size increments", Directives: gti.Directives{}}},
		{"Off", &gti.Field{Name: "Off", Type: "bool", Doc: "can turn off e.g., scrollbar rendering with this flag -- just prevents rendering", Directives: gti.Directives{}}},
		{"StyleBox", &gti.Field{Name: "StyleBox", Type: "gist.Style", Doc: "an additional style object that is used for styling the overall box around the slider; it should be set in the StyleFuncs, just the like the main style object is; it typically has no border and a white/black background; it needs a background to allow local re-rendering", Directives: gti.Directives{}}},
		{"ValueColor", &gti.Field{Name: "ValueColor", Type: "gist.ColorSpec", Doc: "the background color that is used for styling the selected value section of the slider; it should be set in the StyleFuncs, just like the main style object is", Directives: gti.Directives{}}},
		{"ThumbColor", &gti.Field{Name: "ThumbColor", Type: "gist.ColorSpec", Doc: "the background color that is used for styling the thumb (handle) of the slider; it should be set in the StyleFuncs, just like the main style object is", Directives: gti.Directives{}}},
		{"State", &gti.Field{Name: "State", Type: "SliderStates", Doc: "state of slider", Directives: gti.Directives{}}},
		{"StateStyles", &gti.Field{Name: "StateStyles", Type: "[SliderStatesN]gist.Style", Doc: "styles for different states of the slider, one for each state -- everything inherits from the base Style which is styled first according to the user-set styles, and then subsequent style settings can override that", Directives: gti.Directives{}}},
		{"SliderSig", &gti.Field{Name: "SliderSig", Type: "ki.Signal", Doc: "[view: -] signal for slider -- see SliderSignals for the types", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SliderBase{},
})

// NewSliderBase adds a new [SliderBase] with
// the given name to the given parent.
func NewSliderBase(par ki.Ki, name string) *SliderBase {
	return par.NewChild(SliderBaseType, name).(*SliderBase)
}

// KiType returns the [*gti.Type] of [SliderBase]
func (t *SliderBase) KiType() *gti.Type {
	return SliderBaseType
}

// New returns a new [*SliderBase] value
func (t *SliderBase) New() ki.Ki {
	return &SliderBase{}
}

// SliderType is the [gti.Type] for [Slider]
var SliderType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Slider",
	Doc:        "Slider is a standard value slider with a fixed-sized thumb knob -- if an\nIcon is set, it is used for the knob of the slider",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SliderBase", &gti.Field{Name: "SliderBase", Type: "SliderBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Slider{},
})

// NewSlider adds a new [Slider] with
// the given name to the given parent.
func NewSlider(par ki.Ki, name string) *Slider {
	return par.NewChild(SliderType, name).(*Slider)
}

// KiType returns the [*gti.Type] of [Slider]
func (t *Slider) KiType() *gti.Type {
	return SliderType
}

// New returns a new [*Slider] value
func (t *Slider) New() ki.Ki {
	return &Slider{}
}

// ScrollBarType is the [gti.Type] for [ScrollBar]
var ScrollBarType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.ScrollBar",
	Doc:        "ScrollBar has a proportional thumb size reflecting amount of content visible",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SliderBase", &gti.Field{Name: "SliderBase", Type: "SliderBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ScrollBar{},
})

// NewScrollBar adds a new [ScrollBar] with
// the given name to the given parent.
func NewScrollBar(par ki.Ki, name string) *ScrollBar {
	return par.NewChild(ScrollBarType, name).(*ScrollBar)
}

// KiType returns the [*gti.Type] of [ScrollBar]
func (t *ScrollBar) KiType() *gti.Type {
	return ScrollBarType
}

// New returns a new [*ScrollBar] value
func (t *ScrollBar) New() ki.Ki {
	return &ScrollBar{}
}

// ProgressBarType is the [gti.Type] for [ProgressBar]
var ProgressBarType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.ProgressBar",
	Doc:        "ProgressBar is a progress bar that fills up bar as progress continues.\nCall Start with a maximum value to work toward, and ProgStep each time\na progress step has been accomplished -- increments the ProgCur by one\nand display is updated every ProgInc such steps.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ProgMax", &gti.Field{Name: "ProgMax", Type: "int", Doc: "maximum amount of progress to be achieved", Directives: gti.Directives{}}},
		{"ProgInc", &gti.Field{Name: "ProgInc", Type: "int", Doc: "progress increment when display is updated -- automatically computed from ProgMax at Start but can be overwritten", Directives: gti.Directives{}}},
		{"ProgCur", &gti.Field{Name: "ProgCur", Type: "int", Doc: "current progress level", Directives: gti.Directives{}}},
		{"ProgMu", &gti.Field{Name: "ProgMu", Type: "sync.Mutex", Doc: "mutex for updating progress", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ScrollBar", &gti.Field{Name: "ScrollBar", Type: "ScrollBar", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ProgressBar{},
})

// NewProgressBar adds a new [ProgressBar] with
// the given name to the given parent.
func NewProgressBar(par ki.Ki, name string) *ProgressBar {
	return par.NewChild(ProgressBarType, name).(*ProgressBar)
}

// KiType returns the [*gti.Type] of [ProgressBar]
func (t *ProgressBar) KiType() *gti.Type {
	return ProgressBarType
}

// New returns a new [*ProgressBar] value
func (t *ProgressBar) New() ki.Ki {
	return &ProgressBar{}
}

// SpellType is the [gti.Type] for [Spell]
var SpellType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Spell",
	Doc:        "Spell",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SrcLn", &gti.Field{Name: "SrcLn", Type: "int", Doc: "line number in source that spelling is operating on, if relevant", Directives: gti.Directives{}}},
		{"SrcCh", &gti.Field{Name: "SrcCh", Type: "int", Doc: "character position in source that spelling is operating on (start of word to be corrected)", Directives: gti.Directives{}}},
		{"Suggest", &gti.Field{Name: "Suggest", Type: "[]string", Doc: "list of suggested corrections", Directives: gti.Directives{}}},
		{"Word", &gti.Field{Name: "Word", Type: "string", Doc: "word being checked", Directives: gti.Directives{}}},
		{"LastLearned", &gti.Field{Name: "LastLearned", Type: "string", Doc: "last word learned -- can be undone -- stored in lowercase format", Directives: gti.Directives{}}},
		{"SpellSig", &gti.Field{Name: "SpellSig", Type: "ki.Signal", Doc: "[view: -] signal for Spell -- see SpellSignals for the types", Directives: gti.Directives{}}},
		{"Correction", &gti.Field{Name: "Correction", Type: "string", Doc: "the user's correction selection'", Directives: gti.Directives{}}},
		{"Sc", &gti.Field{Name: "Sc", Type: "*Scene", Doc: "the scene where the current popup menu is presented", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Spell{},
})

// NewSpell adds a new [Spell] with
// the given name to the given parent.
func NewSpell(par ki.Ki, name string) *Spell {
	return par.NewChild(SpellType, name).(*Spell)
}

// KiType returns the [*gti.Type] of [Spell]
func (t *Spell) KiType() *gti.Type {
	return SpellType
}

// New returns a new [*Spell] value
func (t *Spell) New() ki.Ki {
	return &Spell{}
}

// SpinBoxType is the [gti.Type] for [SpinBox]
var SpinBoxType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.SpinBox",
	Doc:        "SpinBox combines a TextField with up / down buttons for incrementing /\ndecrementing values -- all configured within the Parts of the widget",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Value", &gti.Field{Name: "Value", Type: "float32", Doc: "current value", Directives: gti.Directives{}}},
		{"HasMin", &gti.Field{Name: "HasMin", Type: "bool", Doc: "is there a minimum value to enforce", Directives: gti.Directives{}}},
		{"Min", &gti.Field{Name: "Min", Type: "float32", Doc: "minimum value in range", Directives: gti.Directives{}}},
		{"HasMax", &gti.Field{Name: "HasMax", Type: "bool", Doc: "is there a maximumvalue to enforce", Directives: gti.Directives{}}},
		{"Max", &gti.Field{Name: "Max", Type: "float32", Doc: "maximum value in range", Directives: gti.Directives{}}},
		{"Step", &gti.Field{Name: "Step", Type: "float32", Doc: "smallest step size to increment", Directives: gti.Directives{}}},
		{"PageStep", &gti.Field{Name: "PageStep", Type: "float32", Doc: "larger PageUp / Dn step size", Directives: gti.Directives{}}},
		{"Prec", &gti.Field{Name: "Prec", Type: "int", Doc: "specifies the precision of decimal places (total, not after the decimal point) to use in representing the number -- this helps to truncate small weird floating point values in the nether regions", Directives: gti.Directives{}}},
		{"Format", &gti.Field{Name: "Format", Type: "string", Doc: "prop = format -- format string for printing the value -- blank defaults to %g.  If decimal based (ends in d, b, c, o, O, q, x, X, or U) then value is converted to decimal prior to printing", Directives: gti.Directives{}}},
		{"UpIcon", &gti.Field{Name: "UpIcon", Type: "icons.Icon", Doc: "[view: show-name] icon to use for up button -- defaults to icons.KeyboardArrowUp", Directives: gti.Directives{}}},
		{"DownIcon", &gti.Field{Name: "DownIcon", Type: "icons.Icon", Doc: "[view: show-name] icon to use for down button -- defaults to icons.KeyboardArrowDown", Directives: gti.Directives{}}},
		{"SpinBoxSig", &gti.Field{Name: "SpinBoxSig", Type: "ki.Signal", Doc: "[view: -] signal for spin box -- has no signal types, just emitted when the value changes", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SpinBox{},
})

// NewSpinBox adds a new [SpinBox] with
// the given name to the given parent.
func NewSpinBox(par ki.Ki, name string) *SpinBox {
	return par.NewChild(SpinBoxType, name).(*SpinBox)
}

// KiType returns the [*gti.Type] of [SpinBox]
func (t *SpinBox) KiType() *gti.Type {
	return SpinBoxType
}

// New returns a new [*SpinBox] value
func (t *SpinBox) New() ki.Ki {
	return &SpinBox{}
}

// SplitViewType is the [gti.Type] for [SplitView]
var SplitViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.SplitView",
	Doc:        "SplitView allocates a fixed proportion of space to each child, along given\ndimension, always using only the available space given to it by its parent\n(i.e., it will force its children, which should be layouts (typically\nFrame's), to have their own scroll bars as necessary).  It should\ngenerally be used as a main outer-level structure within a window,\nproviding a framework for inner elements -- it allows individual child\nelements to update independently and thus is important for speeding update\nperformance.  It uses the Widget Parts to hold the splitter widgets\nseparately from the children that contain the rest of the scenegraph to be\ndisplayed within each region.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"HandleSize", &gti.Field{Name: "HandleSize", Type: "units.Value", Doc: "size of the handle region in the middle of each split region, where the splitter can be dragged -- other-dimension size is 2x of this", Directives: gti.Directives{}}},
		{"Splits", &gti.Field{Name: "Splits", Type: "[]float32", Doc: "proportion (0-1 normalized, enforced) of space allocated to each element -- can enter 0 to collapse a given element", Directives: gti.Directives{}}},
		{"SavedSplits", &gti.Field{Name: "SavedSplits", Type: "[]float32", Doc: "A saved version of the splits which can be restored -- for dynamic collapse / expand operations", Directives: gti.Directives{}}},
		{"Dim", &gti.Field{Name: "Dim", Type: "mat32.Dims", Doc: "dimension along which to split the space", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SplitView{},
})

// NewSplitView adds a new [SplitView] with
// the given name to the given parent.
func NewSplitView(par ki.Ki, name string) *SplitView {
	return par.NewChild(SplitViewType, name).(*SplitView)
}

// KiType returns the [*gti.Type] of [SplitView]
func (t *SplitView) KiType() *gti.Type {
	return SplitViewType
}

// New returns a new [*SplitView] value
func (t *SplitView) New() ki.Ki {
	return &SplitView{}
}

// SplitterType is the [gti.Type] for [Splitter]
var SplitterType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Splitter",
	Doc:        "Splitter provides the splitter handle and line separating two elements in a\nSplitView, with draggable resizing of the splitter -- parent is Parts\nlayout of the SplitView -- based on SliderBase",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SplitterNo", &gti.Field{Name: "SplitterNo", Type: "int", Doc: "splitter number this one is", Directives: gti.Directives{}}},
		{"OrigWinBBox", &gti.Field{Name: "OrigWinBBox", Type: "image.Rectangle", Doc: "copy of the win bbox, used for translating mouse events when the bbox is restricted to the slider itself", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SliderBase", &gti.Field{Name: "SliderBase", Type: "SliderBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Splitter{},
})

// NewSplitter adds a new [Splitter] with
// the given name to the given parent.
func NewSplitter(par ki.Ki, name string) *Splitter {
	return par.NewChild(SplitterType, name).(*Splitter)
}

// KiType returns the [*gti.Type] of [Splitter]
func (t *Splitter) KiType() *gti.Type {
	return SplitterType
}

// New returns a new [*Splitter] value
func (t *Splitter) New() ki.Ki {
	return &Splitter{}
}

// TabViewType is the [gti.Type] for [TabView]
var TabViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.TabView",
	Doc:        "TabView switches among child widgets via tabs.  The selected widget gets\nthe full allocated space avail after the tabs are accounted for.  The\nTabView is just a Vertical layout that manages two child widgets: a\nHorizFlow Layout for the tabs (which can flow across multiple rows as\nneeded) and a Stacked Frame that actually contains all the children, and\nprovides scrollbars as needed to any content within.  Typically should have\nmax stretch and a set preferred size, so it expands.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MaxChars", &gti.Field{Name: "MaxChars", Type: "int", Doc: "maximum number of characters to include in tab label -- elides labels that are longer than that", Directives: gti.Directives{}}},
		{"TabViewSig", &gti.Field{Name: "TabViewSig", Type: "ki.Signal", Doc: "signal for tab widget -- see TabViewSignals for the types", Directives: gti.Directives{}}},
		{"NewTabButton", &gti.Field{Name: "NewTabButton", Type: "bool", Doc: "show a new tab button at right of list of tabs", Directives: gti.Directives{}}},
		{"NoDeleteTabs", &gti.Field{Name: "NoDeleteTabs", Type: "bool", Doc: "if true, tabs are not user-deleteable", Directives: gti.Directives{}}},
		{"NewTabType", &gti.Field{Name: "NewTabType", Type: "*gti.Type", Doc: "type of widget to create in a new tab via new tab button -- Frame by default", Directives: gti.Directives{}}},
		{"Mu", &gti.Field{Name: "Mu", Type: "sync.Mutex", Doc: "[view: -] mutex protecting updates to tabs -- tabs can be driven programmatically and via user input so need extra protection", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TabView{},
})

// NewTabView adds a new [TabView] with
// the given name to the given parent.
func NewTabView(par ki.Ki, name string) *TabView {
	return par.NewChild(TabViewType, name).(*TabView)
}

// KiType returns the [*gti.Type] of [TabView]
func (t *TabView) KiType() *gti.Type {
	return TabViewType
}

// New returns a new [*TabView] value
func (t *TabView) New() ki.Ki {
	return &TabView{}
}

// TabButtonType is the [gti.Type] for [TabButton]
var TabButtonType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.TabButton",
	Doc:        "TabButton is a larger select action and a small close action. Indicator\nicon is used for close icon.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NoDelete", &gti.Field{Name: "NoDelete", Type: "bool", Doc: "if true, this tab does not have the delete button avail", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Action", &gti.Field{Name: "Action", Type: "Action", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TabButton{},
})

// NewTabButton adds a new [TabButton] with
// the given name to the given parent.
func NewTabButton(par ki.Ki, name string) *TabButton {
	return par.NewChild(TabButtonType, name).(*TabButton)
}

// KiType returns the [*gti.Type] of [TabButton]
func (t *TabButton) KiType() *gti.Type {
	return TabButtonType
}

// New returns a new [*TabButton] value
func (t *TabButton) New() ki.Ki {
	return &TabButton{}
}

// TextFieldType is the [gti.Type] for [TextField]
var TextFieldType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.TextField",
	Doc:        "TextField is a widget for editing a line of text",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Txt", &gti.Field{Name: "Txt", Type: "string", Doc: "the last saved value of the text string being edited", Directives: gti.Directives{}}},
		{"Placeholder", &gti.Field{Name: "Placeholder", Type: "string", Doc: "text that is displayed when the field is empty, in a lower-contrast manner", Directives: gti.Directives{}}},
		{"LeadingIcon", &gti.Field{Name: "LeadingIcon", Type: "icons.Icon", Doc: "if specified, an action will be added at the start of the text field with this icon; its signal is exposed through LeadingIconSig", Directives: gti.Directives{}}},
		{"LeadingIconSig", &gti.Field{Name: "LeadingIconSig", Type: "ki.Signal", Doc: "[view: -] if LeadingIcon is set, this is the signal of the leading icon; see [Action.ActionSig] for information on this signal", Directives: gti.Directives{}}},
		{"TrailingIcon", &gti.Field{Name: "TrailingIcon", Type: "icons.Icon", Doc: "if specified, an action will be added at the end of the text field with this icon; its signal is exposed through TrailingIconSig", Directives: gti.Directives{}}},
		{"TrailingIconSig", &gti.Field{Name: "TrailingIconSig", Type: "ki.Signal", Doc: "[view: -] if TrailingIcon is set, this is the signal of the trailing icon; see [Action.ActionSig] for information on this signal", Directives: gti.Directives{}}},
		{"CursorWidth", &gti.Field{Name: "CursorWidth", Type: "units.Value", Doc: "width of cursor -- set from cursor-width property (inherited)", Directives: gti.Directives{}}},
		{"Type", &gti.Field{Name: "Type", Type: "TextFieldTypes", Doc: "the type of the text field", Directives: gti.Directives{}}},
		{"PlaceholderColor", &gti.Field{Name: "PlaceholderColor", Type: "color.RGBA", Doc: "the color used for the placeholder text; this should be set in Stylers like all other style properties; it is typically a highlighted version of the normal text color", Directives: gti.Directives{}}},
		{"SelectColor", &gti.Field{Name: "SelectColor", Type: "gist.ColorSpec", Doc: "the color used for the text selection background color on active text fields; this should be set in Stylers like all other style properties", Directives: gti.Directives{}}},
		{"CursorColor", &gti.Field{Name: "CursorColor", Type: "gist.ColorSpec", Doc: "the color used for the text field cursor (caret); this should be set in Stylers like all other style properties", Directives: gti.Directives{}}},
		{"Edited", &gti.Field{Name: "Edited", Type: "bool", Doc: "true if the text has been edited relative to the original", Directives: gti.Directives{}}},
		{"EditTxt", &gti.Field{Name: "EditTxt", Type: "[]rune", Doc: "the live text string being edited, with latest modifications -- encoded as runes", Directives: gti.Directives{}}},
		{"MaxWidthReq", &gti.Field{Name: "MaxWidthReq", Type: "int", Doc: "maximum width that field will request, in characters, during GetSize process -- if 0 then is 50 -- ensures that large strings don't request super large values -- standard max-width can override", Directives: gti.Directives{}}},
		{"EffPos", &gti.Field{Name: "EffPos", Type: "mat32.Vec2", Doc: "effective position with any leading icon space added", Directives: gti.Directives{}}},
		{"EffSize", &gti.Field{Name: "EffSize", Type: "mat32.Vec2", Doc: "effective size, subtracting any leading and trailing icon space", Directives: gti.Directives{}}},
		{"StartPos", &gti.Field{Name: "StartPos", Type: "int", Doc: "starting display position in the string", Directives: gti.Directives{}}},
		{"EndPos", &gti.Field{Name: "EndPos", Type: "int", Doc: "ending display position in the string", Directives: gti.Directives{}}},
		{"CursorPos", &gti.Field{Name: "CursorPos", Type: "int", Doc: "current cursor position", Directives: gti.Directives{}}},
		{"CharWidth", &gti.Field{Name: "CharWidth", Type: "int", Doc: "approximate number of chars that can be displayed at any time -- computed from font size etc", Directives: gti.Directives{}}},
		{"SelectStart", &gti.Field{Name: "SelectStart", Type: "int", Doc: "starting position of selection in the string", Directives: gti.Directives{}}},
		{"SelectEnd", &gti.Field{Name: "SelectEnd", Type: "int", Doc: "ending position of selection in the string", Directives: gti.Directives{}}},
		{"SelectInit", &gti.Field{Name: "SelectInit", Type: "int", Doc: "initial selection position -- where it started", Directives: gti.Directives{}}},
		{"SelectMode", &gti.Field{Name: "SelectMode", Type: "bool", Doc: "if true, select text as cursor moves", Directives: gti.Directives{}}},
		{"TextFieldSig", &gti.Field{Name: "TextFieldSig", Type: "ki.Signal", Doc: "[view: -] signal for line edit -- see TextFieldSignals for the types", Directives: gti.Directives{}}},
		{"RenderAll", &gti.Field{Name: "RenderAll", Type: "girl.Text", Doc: "render version of entire text, for sizing", Directives: gti.Directives{}}},
		{"RenderVis", &gti.Field{Name: "RenderVis", Type: "girl.Text", Doc: "render version of just visible text", Directives: gti.Directives{}}},
		{"FontHeight", &gti.Field{Name: "FontHeight", Type: "float32", Doc: "font height, cached during styling", Directives: gti.Directives{}}},
		{"BlinkOn", &gti.Field{Name: "BlinkOn", Type: "bool", Doc: "oscillates between on and off for blinking", Directives: gti.Directives{}}},
		{"CursorMu", &gti.Field{Name: "CursorMu", Type: "sync.Mutex", Doc: "[view: -] mutex for updating cursor between blinker and field", Directives: gti.Directives{}}},
		{"Complete", &gti.Field{Name: "Complete", Type: "*Complete", Doc: "functions and data for textfield completion", Directives: gti.Directives{}}},
		{"NoEcho", &gti.Field{Name: "NoEcho", Type: "bool", Doc: "replace displayed characters with bullets to conceal text", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TextField{},
})

// NewTextField adds a new [TextField] with
// the given name to the given parent.
func NewTextField(par ki.Ki, name string) *TextField {
	return par.NewChild(TextFieldType, name).(*TextField)
}

// KiType returns the [*gti.Type] of [TextField]
func (t *TextField) KiType() *gti.Type {
	return TextFieldType
}

// New returns a new [*TextField] value
func (t *TextField) New() ki.Ki {
	return &TextField{}
}

// WidgetBaseType is the [gti.Type] for [WidgetBase]
var WidgetBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.WidgetBase",
	Doc:        "WidgetBase is the base type for all Widget Node2D elements, which are\nmanaged by a containing Layout, and use all 5 rendering passes.  All\nelemental widgets must support the Inactive and Selected states in a\nreasonable way (Selected only essential when also Inactive), so they can\nfunction appropriately in a chooser (e.g., SliceView or TableView) -- this\nincludes toggling selection on left mouse press.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Class", &gti.Field{Name: "Class", Type: "string", Doc: "user-defined class name(s) used primarily for attaching CSS styles to different display elements -- multiple class names can be used to combine properties: use spaces to separate per css standard", Directives: gti.Directives{}}},
		{"CSS", &gti.Field{Name: "CSS", Type: "ki.Props", Doc: "cascading style sheet at this level -- these styles apply here and to everything below, until superceded -- use .class and #name Props elements to apply entire styles to given elements, and type for element type", Directives: gti.Directives{}}},
		{"CSSAgg", &gti.Field{Name: "CSSAgg", Type: "ki.Props", Doc: "[view: no-inline] aggregated css properties from all higher nodes down to me", Directives: gti.Directives{}}},
		{"BBox", &gti.Field{Name: "BBox", Type: "image.Rectangle", Doc: "raw original bounding box for the widget within its parent Scene -- used for computing ScBBox.  This is not updated by Move2D, whereas ScBBox is", Directives: gti.Directives{}}},
		{"ObjBBox", &gti.Field{Name: "ObjBBox", Type: "image.Rectangle", Doc: "full object bbox -- this is BBox + Move2D delta, but NOT intersected with parent's parBBox -- used for computing color gradients or other object-specific geometry computations", Directives: gti.Directives{}}},
		{"ScBBox", &gti.Field{Name: "ScBBox", Type: "image.Rectangle", Doc: "2D bounding box for region occupied within immediate parent Scene object that we render onto -- these are the pixels we draw into, filtered through parent bounding boxes -- used for render Bounds clipping", Directives: gti.Directives{}}},
		{"Tooltip", &gti.Field{Name: "Tooltip", Type: "string", Doc: "text for tooltip for this widget -- can use HTML formatting", Directives: gti.Directives{}}},
		{"Stylers", &gti.Field{Name: "Stylers", Type: "[]Styler", Doc: "a slice of stylers that are called in sequential descending order (so the first added styler is called last and thus overrides all other functions) to style the element; these should be set using AddStyler, which can be called by end-user and internal code", Directives: gti.Directives{}}},
		{"OverrideStyle", &gti.Field{Name: "OverrideStyle", Type: "bool", Doc: "override the computed styles and allow directly editing Style", Directives: gti.Directives{}}},
		{"Style", &gti.Field{Name: "Style", Type: "gist.Style", Doc: "styling settings for this widget -- set in SetSetStyle during an initialization step, and when the structure changes; they are determined by, in increasing priority order, the default values, the ki node properties, and the StyleFunc (the recommended way to set styles is through the StyleFunc -- setting this field directly outside of that will have no effect unless OverrideStyle is on)", Directives: gti.Directives{}}},
		{"Parts", &gti.Field{Name: "Parts", Type: "*Layout", Doc: "a separate tree of sub-widgets that implement discrete parts of a widget -- positions are always relative to the parent widget -- fully managed by the widget and not saved", Directives: gti.Directives{}}},
		{"Events", &gti.Field{Name: "Events", Type: "WidgetEvents", Doc: "filter and map of event processing functions that determine which events and how they are processed for this widget", Directives: gti.Directives{}}},
		{"LayState", &gti.Field{Name: "LayState", Type: "LayoutState", Doc: "all the layout state information for this widget", Directives: gti.Directives{}}},
		{"WidgetSig", &gti.Field{Name: "WidgetSig", Type: "ki.Signal", Doc: "[view: -] general widget signals supported by all widgets, including select, focus, and context menu (right mouse button) events, which can be used by views and other compound widgets", Directives: gti.Directives{}}},
		{"CtxtMenuFunc", &gti.Field{Name: "CtxtMenuFunc", Type: "CtxtMenuFunc", Doc: "[view: -] optional context menu function called by MakeContextMenu AFTER any native items are added -- this function can decide where to insert new elements -- typically add a separator to disambiguate", Directives: gti.Directives{}}},
		{"Sc", &gti.Field{Name: "Sc", Type: "*Scene", Doc: "parent scene.  Only for use as a last resort when arg is not available -- otherwise always use the arg.  Set during Config.", Directives: gti.Directives{}}},
		{"StyMu", &gti.Field{Name: "StyMu", Type: "sync.RWMutex", Doc: "[view: -] mutex protecting the Style field", Directives: gti.Directives{}}},
		{"BBoxMu", &gti.Field{Name: "BBoxMu", Type: "sync.RWMutex", Doc: "[view: -] mutex protecting the BBox fields", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &WidgetBase{},
})

// NewWidgetBase adds a new [WidgetBase] with
// the given name to the given parent.
func NewWidgetBase(par ki.Ki, name string) *WidgetBase {
	return par.NewChild(WidgetBaseType, name).(*WidgetBase)
}

// KiType returns the [*gti.Type] of [WidgetBase]
func (t *WidgetBase) KiType() *gti.Type {
	return WidgetBaseType
}

// New returns a new [*WidgetBase] value
func (t *WidgetBase) New() ki.Ki {
	return &WidgetBase{}
}
