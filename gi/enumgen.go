// Code generated by "goki generate"; DO NOT EDIT.

package gi

import (
	"errors"
	"strconv"
	"strings"
	"sync/atomic"

	"goki.dev/enums"
	"goki.dev/ki/v2"
)

var _ActionTypesValues = []ActionTypes{0, 1, 2, 3, 4}

// ActionTypesN is the highest valid value
// for type ActionTypes, plus one.
const ActionTypesN ActionTypes = 5

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ActionTypesNoOp() {
	var x [1]struct{}
	_ = x[ActionStandalone-(0)]
	_ = x[ActionParts-(1)]
	_ = x[ActionMenu-(2)]
	_ = x[ActionMenuBar-(3)]
	_ = x[ActionToolBar-(4)]
}

var _ActionTypesNameToValueMap = map[string]ActionTypes{
	`ActionStandalone`: 0,
	`actionstandalone`: 0,
	`ActionParts`:      1,
	`actionparts`:      1,
	`ActionMenu`:       2,
	`actionmenu`:       2,
	`ActionMenuBar`:    3,
	`actionmenubar`:    3,
	`ActionToolBar`:    4,
	`actiontoolbar`:    4,
}

var _ActionTypesDescMap = map[ActionTypes]string{
	0: `ActionStandalone is a default, standalone action that is not part of a menu, menubar, toolbar, or other element`,
	1: `ActionParts is an action that is part of another element (like a clear button in a textfield)`,
	2: `ActionMenu is an action contained within a popup menu`,
	3: `ActionMenuBar is an action contained within a menu bar`,
	4: `ActionToolBar is an action contained within a toolbar`,
}

var _ActionTypesMap = map[ActionTypes]string{
	0: `ActionStandalone`,
	1: `ActionParts`,
	2: `ActionMenu`,
	3: `ActionMenuBar`,
	4: `ActionToolBar`,
}

// String returns the string representation
// of this ActionTypes value.
func (i ActionTypes) String() string {
	if str, ok := _ActionTypesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the ActionTypes value from its
// string representation, and returns an
// error if the string is invalid.
func (i *ActionTypes) SetString(s string) error {
	if val, ok := _ActionTypesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _ActionTypesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type ActionTypes")
}

// Int64 returns the ActionTypes value as an int64.
func (i ActionTypes) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the ActionTypes value from an int64.
func (i *ActionTypes) SetInt64(in int64) {
	*i = ActionTypes(in)
}

// Desc returns the description of the ActionTypes value.
func (i ActionTypes) Desc() string {
	if str, ok := _ActionTypesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// ActionTypesValues returns all possible values
// for the type ActionTypes.
func ActionTypesValues() []ActionTypes {
	return _ActionTypesValues
}

// Values returns all possible values
// for the type ActionTypes.
func (i ActionTypes) Values() []enums.Enum {
	res := make([]enums.Enum, len(_ActionTypesValues))
	for i, d := range _ActionTypesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type ActionTypes.
func (i ActionTypes) IsValid() bool {
	_, ok := _ActionTypesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ActionTypes) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ActionTypes) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _ButtonFlagsValues = []ButtonFlags{23, 24, 25}

// ButtonFlagsN is the highest valid value
// for type ButtonFlags, plus one.
const ButtonFlagsN ButtonFlags = 26

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ButtonFlagsNoOp() {
	var x [1]struct{}
	_ = x[ButtonFlagCheckable-(23)]
	_ = x[ButtonFlagChecked-(24)]
	_ = x[ButtonFlagMenu-(25)]
}

var _ButtonFlagsNameToValueMap = map[string]ButtonFlags{
	`ButtonFlagCheckable`: 23,
	`buttonflagcheckable`: 23,
	`ButtonFlagChecked`:   24,
	`buttonflagchecked`:   24,
	`ButtonFlagMenu`:      25,
	`buttonflagmenu`:      25,
}

var _ButtonFlagsDescMap = map[ButtonFlags]string{
	23: `button is checkable -- enables display of check control`,
	24: `button is checked`,
	25: `Menu flag means that the button is a menu item`,
}

var _ButtonFlagsMap = map[ButtonFlags]string{
	23: `ButtonFlagCheckable`,
	24: `ButtonFlagChecked`,
	25: `ButtonFlagMenu`,
}

// String returns the string representation
// of this ButtonFlags value.
func (i ButtonFlags) String() string {
	str := ""
	for _, ie := range WidgetFlagsValues() {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	for _, ie := range _ButtonFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this ButtonFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i ButtonFlags) BitIndexString() string {
	if str, ok := _ButtonFlagsMap[i]; ok {
		return str
	}
	return WidgetFlags(i).BitIndexString()
}

// SetString sets the ButtonFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *ButtonFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the ButtonFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *ButtonFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _ButtonFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _ButtonFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			err := (*WidgetFlags)(i).SetStringOr(flg)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Int64 returns the ButtonFlags value as an int64.
func (i ButtonFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the ButtonFlags value from an int64.
func (i *ButtonFlags) SetInt64(in int64) {
	*i = ButtonFlags(in)
}

// Desc returns the description of the ButtonFlags value.
func (i ButtonFlags) Desc() string {
	if str, ok := _ButtonFlagsDescMap[i]; ok {
		return str
	}
	return WidgetFlags(i).Desc()
}

// ButtonFlagsValues returns all possible values
// for the type ButtonFlags.
func ButtonFlagsValues() []ButtonFlags {
	es := WidgetFlagsValues()
	res := make([]ButtonFlags, len(es))
	for i, e := range es {
		res[i] = ButtonFlags(e)
	}
	res = append(res, _ButtonFlagsValues...)
	return res
}

// Values returns all possible values
// for the type ButtonFlags.
func (i ButtonFlags) Values() []enums.Enum {
	es := WidgetFlagsValues()
	les := len(es)
	res := make([]enums.Enum, les+len(_ButtonFlagsValues))
	for i, d := range es {
		res[i] = d
	}
	for i, d := range _ButtonFlagsValues {
		res[i+les] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type ButtonFlags.
func (i ButtonFlags) IsValid() bool {
	_, ok := _ButtonFlagsMap[i]
	if !ok {
		return WidgetFlags(i).IsValid()
	}
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i ButtonFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *ButtonFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ButtonFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ButtonFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _ButtonSignalsValues = []ButtonSignals{0, 1, 2, 3}

// ButtonSignalsN is the highest valid value
// for type ButtonSignals, plus one.
const ButtonSignalsN ButtonSignals = 4

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ButtonSignalsNoOp() {
	var x [1]struct{}
	_ = x[ButtonClicked-(0)]
	_ = x[ButtonPressed-(1)]
	_ = x[ButtonReleased-(2)]
	_ = x[ButtonToggled-(3)]
}

var _ButtonSignalsNameToValueMap = map[string]ButtonSignals{
	`ButtonClicked`:  0,
	`buttonclicked`:  0,
	`ButtonPressed`:  1,
	`buttonpressed`:  1,
	`ButtonReleased`: 2,
	`buttonreleased`: 2,
	`ButtonToggled`:  3,
	`buttontoggled`:  3,
}

var _ButtonSignalsDescMap = map[ButtonSignals]string{
	0: `ButtonClicked is the main signal to check for normal button activation -- button pressed down and up`,
	1: `Pressed means button pushed down but not yet up`,
	2: `Released means mouse button was released - typically look at ButtonClicked instead of this one`,
	3: `Toggled means the checked / unchecked state was toggled -- only sent for buttons with Checkable flag set`,
}

var _ButtonSignalsMap = map[ButtonSignals]string{
	0: `ButtonClicked`,
	1: `ButtonPressed`,
	2: `ButtonReleased`,
	3: `ButtonToggled`,
}

// String returns the string representation
// of this ButtonSignals value.
func (i ButtonSignals) String() string {
	if str, ok := _ButtonSignalsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the ButtonSignals value from its
// string representation, and returns an
// error if the string is invalid.
func (i *ButtonSignals) SetString(s string) error {
	if val, ok := _ButtonSignalsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _ButtonSignalsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type ButtonSignals")
}

// Int64 returns the ButtonSignals value as an int64.
func (i ButtonSignals) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the ButtonSignals value from an int64.
func (i *ButtonSignals) SetInt64(in int64) {
	*i = ButtonSignals(in)
}

// Desc returns the description of the ButtonSignals value.
func (i ButtonSignals) Desc() string {
	if str, ok := _ButtonSignalsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// ButtonSignalsValues returns all possible values
// for the type ButtonSignals.
func ButtonSignalsValues() []ButtonSignals {
	return _ButtonSignalsValues
}

// Values returns all possible values
// for the type ButtonSignals.
func (i ButtonSignals) Values() []enums.Enum {
	res := make([]enums.Enum, len(_ButtonSignalsValues))
	for i, d := range _ButtonSignalsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type ButtonSignals.
func (i ButtonSignals) IsValid() bool {
	_, ok := _ButtonSignalsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ButtonSignals) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ButtonSignals) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _ButtonTypesValues = []ButtonTypes{0, 1, 2, 3, 4}

// ButtonTypesN is the highest valid value
// for type ButtonTypes, plus one.
const ButtonTypesN ButtonTypes = 5

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ButtonTypesNoOp() {
	var x [1]struct{}
	_ = x[ButtonFilled-(0)]
	_ = x[ButtonTonal-(1)]
	_ = x[ButtonElevated-(2)]
	_ = x[ButtonOutlined-(3)]
	_ = x[ButtonText-(4)]
}

var _ButtonTypesNameToValueMap = map[string]ButtonTypes{
	`ButtonFilled`:   0,
	`buttonfilled`:   0,
	`ButtonTonal`:    1,
	`buttontonal`:    1,
	`ButtonElevated`: 2,
	`buttonelevated`: 2,
	`ButtonOutlined`: 3,
	`buttonoutlined`: 3,
	`ButtonText`:     4,
	`buttontext`:     4,
}

var _ButtonTypesDescMap = map[ButtonTypes]string{
	0: `ButtonFilled is a filled button with a contrasting background color. It should be used for prominent actions, typically those that are the final in a sequence. It is equivalent to Material Design&#39;s filled button.`,
	1: `ButtonTonal is a filled button, similar to [ButtonFilled]. It is used for the same purposes, but it has a lighter background color and less emphasis. It is equivalent to Material Design&#39;s filled tonal button.`,
	2: `ButtonElevated is an elevated button with a light background color and a shadow. It is equivalent to Material Design&#39;s elevated button.`,
	3: `ButtonOutlined is an outlined button that is used for secondary actions that are still important. It is equivalent to Material Design&#39;s outlined button.`,
	4: `ButtonText is a low-importance button with only text and/or an icon and no border, background color, or shadow. They should only be used for low emphasis actions, and you must ensure they stand out from the surrounding context sufficiently. It is equivalent to Material Design&#39;s text and icon buttons.`,
}

var _ButtonTypesMap = map[ButtonTypes]string{
	0: `ButtonFilled`,
	1: `ButtonTonal`,
	2: `ButtonElevated`,
	3: `ButtonOutlined`,
	4: `ButtonText`,
}

// String returns the string representation
// of this ButtonTypes value.
func (i ButtonTypes) String() string {
	if str, ok := _ButtonTypesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the ButtonTypes value from its
// string representation, and returns an
// error if the string is invalid.
func (i *ButtonTypes) SetString(s string) error {
	if val, ok := _ButtonTypesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _ButtonTypesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type ButtonTypes")
}

// Int64 returns the ButtonTypes value as an int64.
func (i ButtonTypes) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the ButtonTypes value from an int64.
func (i *ButtonTypes) SetInt64(in int64) {
	*i = ButtonTypes(in)
}

// Desc returns the description of the ButtonTypes value.
func (i ButtonTypes) Desc() string {
	if str, ok := _ButtonTypesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// ButtonTypesValues returns all possible values
// for the type ButtonTypes.
func ButtonTypesValues() []ButtonTypes {
	return _ButtonTypesValues
}

// Values returns all possible values
// for the type ButtonTypes.
func (i ButtonTypes) Values() []enums.Enum {
	res := make([]enums.Enum, len(_ButtonTypesValues))
	for i, d := range _ButtonTypesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type ButtonTypes.
func (i ButtonTypes) IsValid() bool {
	_, ok := _ButtonTypesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ButtonTypes) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ButtonTypes) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _ComboBoxTypesValues = []ComboBoxTypes{0, 1}

// ComboBoxTypesN is the highest valid value
// for type ComboBoxTypes, plus one.
const ComboBoxTypesN ComboBoxTypes = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ComboBoxTypesNoOp() {
	var x [1]struct{}
	_ = x[ComboBoxFilled-(0)]
	_ = x[ComboBoxOutlined-(1)]
}

var _ComboBoxTypesNameToValueMap = map[string]ComboBoxTypes{
	`ComboBoxFilled`:   0,
	`comboboxfilled`:   0,
	`ComboBoxOutlined`: 1,
	`comboboxoutlined`: 1,
}

var _ComboBoxTypesDescMap = map[ComboBoxTypes]string{
	0: `ComboBoxFilled represents a filled ComboBox with a background color and a bottom border`,
	1: `ComboBoxOutlined represents an outlined ComboBox with a border on all sides and no background color`,
}

var _ComboBoxTypesMap = map[ComboBoxTypes]string{
	0: `ComboBoxFilled`,
	1: `ComboBoxOutlined`,
}

// String returns the string representation
// of this ComboBoxTypes value.
func (i ComboBoxTypes) String() string {
	if str, ok := _ComboBoxTypesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the ComboBoxTypes value from its
// string representation, and returns an
// error if the string is invalid.
func (i *ComboBoxTypes) SetString(s string) error {
	if val, ok := _ComboBoxTypesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _ComboBoxTypesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type ComboBoxTypes")
}

// Int64 returns the ComboBoxTypes value as an int64.
func (i ComboBoxTypes) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the ComboBoxTypes value from an int64.
func (i *ComboBoxTypes) SetInt64(in int64) {
	*i = ComboBoxTypes(in)
}

// Desc returns the description of the ComboBoxTypes value.
func (i ComboBoxTypes) Desc() string {
	if str, ok := _ComboBoxTypesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// ComboBoxTypesValues returns all possible values
// for the type ComboBoxTypes.
func ComboBoxTypesValues() []ComboBoxTypes {
	return _ComboBoxTypesValues
}

// Values returns all possible values
// for the type ComboBoxTypes.
func (i ComboBoxTypes) Values() []enums.Enum {
	res := make([]enums.Enum, len(_ComboBoxTypesValues))
	for i, d := range _ComboBoxTypesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type ComboBoxTypes.
func (i ComboBoxTypes) IsValid() bool {
	_, ok := _ComboBoxTypesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ComboBoxTypes) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ComboBoxTypes) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _CompleteSignalsValues = []CompleteSignals{0, 1}

// CompleteSignalsN is the highest valid value
// for type CompleteSignals, plus one.
const CompleteSignalsN CompleteSignals = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _CompleteSignalsNoOp() {
	var x [1]struct{}
	_ = x[CompleteSelect-(0)]
	_ = x[CompleteExtend-(1)]
}

var _CompleteSignalsNameToValueMap = map[string]CompleteSignals{
	`CompleteSelect`: 0,
	`completeselect`: 0,
	`CompleteExtend`: 1,
	`completeextend`: 1,
}

var _CompleteSignalsDescMap = map[CompleteSignals]string{
	0: `CompleteSelect means the user chose one of the possible completions`,
	1: `CompleteExtend means user has requested that the seed extend if all completions have a common prefix longer than current seed`,
}

var _CompleteSignalsMap = map[CompleteSignals]string{
	0: `CompleteSelect`,
	1: `CompleteExtend`,
}

// String returns the string representation
// of this CompleteSignals value.
func (i CompleteSignals) String() string {
	if str, ok := _CompleteSignalsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the CompleteSignals value from its
// string representation, and returns an
// error if the string is invalid.
func (i *CompleteSignals) SetString(s string) error {
	if val, ok := _CompleteSignalsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _CompleteSignalsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type CompleteSignals")
}

// Int64 returns the CompleteSignals value as an int64.
func (i CompleteSignals) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the CompleteSignals value from an int64.
func (i *CompleteSignals) SetInt64(in int64) {
	*i = CompleteSignals(in)
}

// Desc returns the description of the CompleteSignals value.
func (i CompleteSignals) Desc() string {
	if str, ok := _CompleteSignalsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// CompleteSignalsValues returns all possible values
// for the type CompleteSignals.
func CompleteSignalsValues() []CompleteSignals {
	return _CompleteSignalsValues
}

// Values returns all possible values
// for the type CompleteSignals.
func (i CompleteSignals) Values() []enums.Enum {
	res := make([]enums.Enum, len(_CompleteSignalsValues))
	for i, d := range _CompleteSignalsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type CompleteSignals.
func (i CompleteSignals) IsValid() bool {
	_, ok := _CompleteSignalsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i CompleteSignals) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *CompleteSignals) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _WidgetFlagsValues = []WidgetFlags{9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22}

// WidgetFlagsN is the highest valid value
// for type WidgetFlags, plus one.
const WidgetFlagsN WidgetFlags = 23

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _WidgetFlagsNoOp() {
	var x [1]struct{}
	_ = x[NeedsRender-(9)]
	_ = x[EventsConnected-(10)]
	_ = x[CanFocus-(11)]
	_ = x[HasFocus-(12)]
	_ = x[ReRenderAnchor-(13)]
	_ = x[Invisible-(14)]
	_ = x[Disabled-(15)]
	_ = x[Selected-(16)]
	_ = x[Hovered-(17)]
	_ = x[Active-(18)]
	_ = x[MouseHasEntered-(19)]
	_ = x[DNDHasEntered-(20)]
	_ = x[NodeDragging-(21)]
	_ = x[InstaDrag-(22)]
}

var _WidgetFlagsNameToValueMap = map[string]WidgetFlags{
	`NeedsRender`:     9,
	`needsrender`:     9,
	`EventsConnected`: 10,
	`eventsconnected`: 10,
	`CanFocus`:        11,
	`canfocus`:        11,
	`HasFocus`:        12,
	`hasfocus`:        12,
	`ReRenderAnchor`:  13,
	`rerenderanchor`:  13,
	`Invisible`:       14,
	`invisible`:       14,
	`Disabled`:        15,
	`disabled`:        15,
	`Selected`:        16,
	`selected`:        16,
	`Hovered`:         17,
	`hovered`:         17,
	`Active`:          18,
	`active`:          18,
	`MouseHasEntered`: 19,
	`mousehasentered`: 19,
	`DNDHasEntered`:   20,
	`dndhasentered`:   20,
	`NodeDragging`:    21,
	`nodedragging`:    21,
	`InstaDrag`:       22,
	`instadrag`:       22,
}

var _WidgetFlagsDescMap = map[WidgetFlags]string{
	9:  `NeedsRender needs to be rendered on next render itration`,
	10: `EventsConnected: this node has been connected to receive events from the window -- to optimize event processing, connections are typically only established for visible nodes during render, and disconnected when not visible`,
	11: `CanFocus: can this node accept focus to receive keyboard input events -- set by default for typical nodes that do so, but can be overridden, including by the style &#39;can-focus&#39; property`,
	12: `HasFocus: does this node currently have the focus for keyboard input events? use tab / alt tab and clicking events to update focus -- see interface on RenderWin`,
	13: `ReRenderAnchor: this node has a static size, and repaints its background -- any children under it that need to dynamically resize on a ReRender (Update) can refer the update up to rerendering this node, instead of going further up the tree -- e.g., true of Frame&#39;s within a SplitView`,
	14: `Invisible means that the node has been marked as invisible by a parent that has switch-like powers (e.g., layout stacked / tabview or splitter panel that has been collapsed). This flag is propagated down to all child nodes, and rendering or other interaction / update routines should not run when this flag is set (PushBounds does this for most cases). However, it IS a good idea to have styling, layout etc all take place as normal, so that when the flag is cleared, rendering can proceed directly.`,
	15: `Disabled disables all interaction with the user or other nodes; nodes should indicate this disabled state in an appropriate way, and each node should interpret events appropriately based on this state`,
	16: `Selected indicates that this node has been selected by the user -- widely supported across different nodes`,
	17: `Hovered indicates that the node is being hovered over by a mouse cursor or has been long-pressed on mobile`,
	18: `Active indicates that this node is currently being interacted with (typically pressed down) by the user`,
	19: `MouseHasEntered indicates that the MouseFocusEvent Enter was previously registered on this node`,
	20: `DNDHasEntered indicates that the DNDFocusEvent Enter was previously registered on this node`,
	21: `NodeDragging indicates this node is currently dragging -- win.Dragging set to this node`,
	22: `InstaDrag indicates this node should start dragging immediately when clicked -- otherwise there is a time-and-distance threshold to the start of dragging -- use this for controls that are small and are primarily about dragging (e.g., the Splitter handle)`,
}

var _WidgetFlagsMap = map[WidgetFlags]string{
	9:  `NeedsRender`,
	10: `EventsConnected`,
	11: `CanFocus`,
	12: `HasFocus`,
	13: `ReRenderAnchor`,
	14: `Invisible`,
	15: `Disabled`,
	16: `Selected`,
	17: `Hovered`,
	18: `Active`,
	19: `MouseHasEntered`,
	20: `DNDHasEntered`,
	21: `NodeDragging`,
	22: `InstaDrag`,
}

// String returns the string representation
// of this WidgetFlags value.
func (i WidgetFlags) String() string {
	str := ""
	for _, ie := range ki.FlagsValues() {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	for _, ie := range _WidgetFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this WidgetFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i WidgetFlags) BitIndexString() string {
	if str, ok := _WidgetFlagsMap[i]; ok {
		return str
	}
	return ki.Flags(i).BitIndexString()
}

// SetString sets the WidgetFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *WidgetFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the WidgetFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *WidgetFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _WidgetFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _WidgetFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			err := (*ki.Flags)(i).SetStringOr(flg)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Int64 returns the WidgetFlags value as an int64.
func (i WidgetFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the WidgetFlags value from an int64.
func (i *WidgetFlags) SetInt64(in int64) {
	*i = WidgetFlags(in)
}

// Desc returns the description of the WidgetFlags value.
func (i WidgetFlags) Desc() string {
	if str, ok := _WidgetFlagsDescMap[i]; ok {
		return str
	}
	return ki.Flags(i).Desc()
}

// WidgetFlagsValues returns all possible values
// for the type WidgetFlags.
func WidgetFlagsValues() []WidgetFlags {
	es := ki.FlagsValues()
	res := make([]WidgetFlags, len(es))
	for i, e := range es {
		res[i] = WidgetFlags(e)
	}
	res = append(res, _WidgetFlagsValues...)
	return res
}

// Values returns all possible values
// for the type WidgetFlags.
func (i WidgetFlags) Values() []enums.Enum {
	es := ki.FlagsValues()
	les := len(es)
	res := make([]enums.Enum, les+len(_WidgetFlagsValues))
	for i, d := range es {
		res[i] = d
	}
	for i, d := range _WidgetFlagsValues {
		res[i+les] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type WidgetFlags.
func (i WidgetFlags) IsValid() bool {
	_, ok := _WidgetFlagsMap[i]
	if !ok {
		return ki.Flags(i).IsValid()
	}
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i WidgetFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *WidgetFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i WidgetFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *WidgetFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _FocusChangesValues = []FocusChanges{0, 1, 2, 3}

// FocusChangesN is the highest valid value
// for type FocusChanges, plus one.
const FocusChangesN FocusChanges = 4

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FocusChangesNoOp() {
	var x [1]struct{}
	_ = x[FocusLost-(0)]
	_ = x[FocusGot-(1)]
	_ = x[FocusInactive-(2)]
	_ = x[FocusActive-(3)]
}

var _FocusChangesNameToValueMap = map[string]FocusChanges{
	`FocusLost`:     0,
	`focuslost`:     0,
	`FocusGot`:      1,
	`focusgot`:      1,
	`FocusInactive`: 2,
	`focusinactive`: 2,
	`FocusActive`:   3,
	`focusactive`:   3,
}

var _FocusChangesDescMap = map[FocusChanges]string{
	0: `FocusLost means that keyboard focus is on a different widget (typically) and this one lost focus`,
	1: `FocusGot means that this widget just got keyboard focus`,
	2: `FocusInactive means that although this widget retains keyboard focus (nobody else has it), the user has clicked on something else and therefore the focus should be considered inactive (distracted), and any changes should be applied as this other action could result in closing of a dialog etc. Keyboard events will still be sent to the focus widget, but it is up to the widget if or how to process them (e.g., it could reactivate on its own).`,
	3: `FocusActive means that the user has moved the mouse back into the focused widget to resume active keyboard focus.`,
}

var _FocusChangesMap = map[FocusChanges]string{
	0: `FocusLost`,
	1: `FocusGot`,
	2: `FocusInactive`,
	3: `FocusActive`,
}

// String returns the string representation
// of this FocusChanges value.
func (i FocusChanges) String() string {
	if str, ok := _FocusChangesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the FocusChanges value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FocusChanges) SetString(s string) error {
	if val, ok := _FocusChangesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _FocusChangesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type FocusChanges")
}

// Int64 returns the FocusChanges value as an int64.
func (i FocusChanges) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FocusChanges value from an int64.
func (i *FocusChanges) SetInt64(in int64) {
	*i = FocusChanges(in)
}

// Desc returns the description of the FocusChanges value.
func (i FocusChanges) Desc() string {
	if str, ok := _FocusChangesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// FocusChangesValues returns all possible values
// for the type FocusChanges.
func FocusChangesValues() []FocusChanges {
	return _FocusChangesValues
}

// Values returns all possible values
// for the type FocusChanges.
func (i FocusChanges) Values() []enums.Enum {
	res := make([]enums.Enum, len(_FocusChangesValues))
	for i, d := range _FocusChangesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FocusChanges.
func (i FocusChanges) IsValid() bool {
	_, ok := _FocusChangesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FocusChanges) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FocusChanges) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _StripesValues = []Stripes{0, 1, 2}

// StripesN is the highest valid value
// for type Stripes, plus one.
const StripesN Stripes = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _StripesNoOp() {
	var x [1]struct{}
	_ = x[NoStripes-(0)]
	_ = x[RowStripes-(1)]
	_ = x[ColStripes-(2)]
}

var _StripesNameToValueMap = map[string]Stripes{
	`NoStripes`:  0,
	`nostripes`:  0,
	`RowStripes`: 1,
	`rowstripes`: 1,
	`ColStripes`: 2,
	`colstripes`: 2,
}

var _StripesDescMap = map[Stripes]string{
	0: ``,
	1: ``,
	2: ``,
}

var _StripesMap = map[Stripes]string{
	0: `NoStripes`,
	1: `RowStripes`,
	2: `ColStripes`,
}

// String returns the string representation
// of this Stripes value.
func (i Stripes) String() string {
	if str, ok := _StripesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Stripes value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Stripes) SetString(s string) error {
	if val, ok := _StripesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _StripesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Stripes")
}

// Int64 returns the Stripes value as an int64.
func (i Stripes) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Stripes value from an int64.
func (i *Stripes) SetInt64(in int64) {
	*i = Stripes(in)
}

// Desc returns the description of the Stripes value.
func (i Stripes) Desc() string {
	if str, ok := _StripesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// StripesValues returns all possible values
// for the type Stripes.
func StripesValues() []Stripes {
	return _StripesValues
}

// Values returns all possible values
// for the type Stripes.
func (i Stripes) Values() []enums.Enum {
	res := make([]enums.Enum, len(_StripesValues))
	for i, d := range _StripesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Stripes.
func (i Stripes) IsValid() bool {
	_, ok := _StripesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Stripes) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Stripes) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _KeyFunsValues = []KeyFuns{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65}

// KeyFunsN is the highest valid value
// for type KeyFuns, plus one.
const KeyFunsN KeyFuns = 66

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _KeyFunsNoOp() {
	var x [1]struct{}
	_ = x[KeyFunNil-(0)]
	_ = x[KeyFunMoveUp-(1)]
	_ = x[KeyFunMoveDown-(2)]
	_ = x[KeyFunMoveRight-(3)]
	_ = x[KeyFunMoveLeft-(4)]
	_ = x[KeyFunPageUp-(5)]
	_ = x[KeyFunPageDown-(6)]
	_ = x[KeyFunHome-(7)]
	_ = x[KeyFunEnd-(8)]
	_ = x[KeyFunDocHome-(9)]
	_ = x[KeyFunDocEnd-(10)]
	_ = x[KeyFunWordRight-(11)]
	_ = x[KeyFunWordLeft-(12)]
	_ = x[KeyFunFocusNext-(13)]
	_ = x[KeyFunFocusPrev-(14)]
	_ = x[KeyFunEnter-(15)]
	_ = x[KeyFunAccept-(16)]
	_ = x[KeyFunCancelSelect-(17)]
	_ = x[KeyFunSelectMode-(18)]
	_ = x[KeyFunSelectAll-(19)]
	_ = x[KeyFunAbort-(20)]
	_ = x[KeyFunCopy-(21)]
	_ = x[KeyFunCut-(22)]
	_ = x[KeyFunPaste-(23)]
	_ = x[KeyFunPasteHist-(24)]
	_ = x[KeyFunBackspace-(25)]
	_ = x[KeyFunBackspaceWord-(26)]
	_ = x[KeyFunDelete-(27)]
	_ = x[KeyFunDeleteWord-(28)]
	_ = x[KeyFunKill-(29)]
	_ = x[KeyFunDuplicate-(30)]
	_ = x[KeyFunTranspose-(31)]
	_ = x[KeyFunTransposeWord-(32)]
	_ = x[KeyFunUndo-(33)]
	_ = x[KeyFunRedo-(34)]
	_ = x[KeyFunInsert-(35)]
	_ = x[KeyFunInsertAfter-(36)]
	_ = x[KeyFunZoomOut-(37)]
	_ = x[KeyFunZoomIn-(38)]
	_ = x[KeyFunPrefs-(39)]
	_ = x[KeyFunRefresh-(40)]
	_ = x[KeyFunRecenter-(41)]
	_ = x[KeyFunComplete-(42)]
	_ = x[KeyFunLookup-(43)]
	_ = x[KeyFunSearch-(44)]
	_ = x[KeyFunFind-(45)]
	_ = x[KeyFunReplace-(46)]
	_ = x[KeyFunJump-(47)]
	_ = x[KeyFunHistPrev-(48)]
	_ = x[KeyFunHistNext-(49)]
	_ = x[KeyFunMenu-(50)]
	_ = x[KeyFunWinFocusNext-(51)]
	_ = x[KeyFunWinClose-(52)]
	_ = x[KeyFunWinSnapshot-(53)]
	_ = x[KeyFunGoGiEditor-(54)]
	_ = x[KeyFunMenuNew-(55)]
	_ = x[KeyFunMenuNewAlt1-(56)]
	_ = x[KeyFunMenuNewAlt2-(57)]
	_ = x[KeyFunMenuOpen-(58)]
	_ = x[KeyFunMenuOpenAlt1-(59)]
	_ = x[KeyFunMenuOpenAlt2-(60)]
	_ = x[KeyFunMenuSave-(61)]
	_ = x[KeyFunMenuSaveAs-(62)]
	_ = x[KeyFunMenuSaveAlt-(63)]
	_ = x[KeyFunMenuCloseAlt1-(64)]
	_ = x[KeyFunMenuCloseAlt2-(65)]
}

var _KeyFunsNameToValueMap = map[string]KeyFuns{
	`KeyFunNil`:           0,
	`keyfunnil`:           0,
	`KeyFunMoveUp`:        1,
	`keyfunmoveup`:        1,
	`KeyFunMoveDown`:      2,
	`keyfunmovedown`:      2,
	`KeyFunMoveRight`:     3,
	`keyfunmoveright`:     3,
	`KeyFunMoveLeft`:      4,
	`keyfunmoveleft`:      4,
	`KeyFunPageUp`:        5,
	`keyfunpageup`:        5,
	`KeyFunPageDown`:      6,
	`keyfunpagedown`:      6,
	`KeyFunHome`:          7,
	`keyfunhome`:          7,
	`KeyFunEnd`:           8,
	`keyfunend`:           8,
	`KeyFunDocHome`:       9,
	`keyfundochome`:       9,
	`KeyFunDocEnd`:        10,
	`keyfundocend`:        10,
	`KeyFunWordRight`:     11,
	`keyfunwordright`:     11,
	`KeyFunWordLeft`:      12,
	`keyfunwordleft`:      12,
	`KeyFunFocusNext`:     13,
	`keyfunfocusnext`:     13,
	`KeyFunFocusPrev`:     14,
	`keyfunfocusprev`:     14,
	`KeyFunEnter`:         15,
	`keyfunenter`:         15,
	`KeyFunAccept`:        16,
	`keyfunaccept`:        16,
	`KeyFunCancelSelect`:  17,
	`keyfuncancelselect`:  17,
	`KeyFunSelectMode`:    18,
	`keyfunselectmode`:    18,
	`KeyFunSelectAll`:     19,
	`keyfunselectall`:     19,
	`KeyFunAbort`:         20,
	`keyfunabort`:         20,
	`KeyFunCopy`:          21,
	`keyfuncopy`:          21,
	`KeyFunCut`:           22,
	`keyfuncut`:           22,
	`KeyFunPaste`:         23,
	`keyfunpaste`:         23,
	`KeyFunPasteHist`:     24,
	`keyfunpastehist`:     24,
	`KeyFunBackspace`:     25,
	`keyfunbackspace`:     25,
	`KeyFunBackspaceWord`: 26,
	`keyfunbackspaceword`: 26,
	`KeyFunDelete`:        27,
	`keyfundelete`:        27,
	`KeyFunDeleteWord`:    28,
	`keyfundeleteword`:    28,
	`KeyFunKill`:          29,
	`keyfunkill`:          29,
	`KeyFunDuplicate`:     30,
	`keyfunduplicate`:     30,
	`KeyFunTranspose`:     31,
	`keyfuntranspose`:     31,
	`KeyFunTransposeWord`: 32,
	`keyfuntransposeword`: 32,
	`KeyFunUndo`:          33,
	`keyfunundo`:          33,
	`KeyFunRedo`:          34,
	`keyfunredo`:          34,
	`KeyFunInsert`:        35,
	`keyfuninsert`:        35,
	`KeyFunInsertAfter`:   36,
	`keyfuninsertafter`:   36,
	`KeyFunZoomOut`:       37,
	`keyfunzoomout`:       37,
	`KeyFunZoomIn`:        38,
	`keyfunzoomin`:        38,
	`KeyFunPrefs`:         39,
	`keyfunprefs`:         39,
	`KeyFunRefresh`:       40,
	`keyfunrefresh`:       40,
	`KeyFunRecenter`:      41,
	`keyfunrecenter`:      41,
	`KeyFunComplete`:      42,
	`keyfuncomplete`:      42,
	`KeyFunLookup`:        43,
	`keyfunlookup`:        43,
	`KeyFunSearch`:        44,
	`keyfunsearch`:        44,
	`KeyFunFind`:          45,
	`keyfunfind`:          45,
	`KeyFunReplace`:       46,
	`keyfunreplace`:       46,
	`KeyFunJump`:          47,
	`keyfunjump`:          47,
	`KeyFunHistPrev`:      48,
	`keyfunhistprev`:      48,
	`KeyFunHistNext`:      49,
	`keyfunhistnext`:      49,
	`KeyFunMenu`:          50,
	`keyfunmenu`:          50,
	`KeyFunWinFocusNext`:  51,
	`keyfunwinfocusnext`:  51,
	`KeyFunWinClose`:      52,
	`keyfunwinclose`:      52,
	`KeyFunWinSnapshot`:   53,
	`keyfunwinsnapshot`:   53,
	`KeyFunGoGiEditor`:    54,
	`keyfungogieditor`:    54,
	`KeyFunMenuNew`:       55,
	`keyfunmenunew`:       55,
	`KeyFunMenuNewAlt1`:   56,
	`keyfunmenunewalt1`:   56,
	`KeyFunMenuNewAlt2`:   57,
	`keyfunmenunewalt2`:   57,
	`KeyFunMenuOpen`:      58,
	`keyfunmenuopen`:      58,
	`KeyFunMenuOpenAlt1`:  59,
	`keyfunmenuopenalt1`:  59,
	`KeyFunMenuOpenAlt2`:  60,
	`keyfunmenuopenalt2`:  60,
	`KeyFunMenuSave`:      61,
	`keyfunmenusave`:      61,
	`KeyFunMenuSaveAs`:    62,
	`keyfunmenusaveas`:    62,
	`KeyFunMenuSaveAlt`:   63,
	`keyfunmenusavealt`:   63,
	`KeyFunMenuCloseAlt1`: 64,
	`keyfunmenuclosealt1`: 64,
	`KeyFunMenuCloseAlt2`: 65,
	`keyfunmenuclosealt2`: 65,
}

var _KeyFunsDescMap = map[KeyFuns]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  ``,
	4:  ``,
	5:  ``,
	6:  ``,
	7:  `KeyFunPageRight KeyFunPageLeft`,
	8:  ``,
	9:  ``,
	10: ``,
	11: ``,
	12: ``,
	13: ``,
	14: ``,
	15: ``,
	16: ``,
	17: ``,
	18: ``,
	19: ``,
	20: ``,
	21: `KeyFunEditItem`,
	22: ``,
	23: ``,
	24: ``,
	25: ``,
	26: ``,
	27: ``,
	28: ``,
	29: ``,
	30: ``,
	31: ``,
	32: ``,
	33: ``,
	34: ``,
	35: ``,
	36: ``,
	37: ``,
	38: ``,
	39: ``,
	40: ``,
	41: ``,
	42: ``,
	43: ``,
	44: ``,
	45: ``,
	46: ``,
	47: ``,
	48: ``,
	49: ``,
	50: ``,
	51: ``,
	52: ``,
	53: ``,
	54: ``,
	55: `Below are menu specific functions -- use these as shortcuts for menu actions allows uniqueness of mapping and easy customization of all key actions`,
	56: ``,
	57: ``,
	58: ``,
	59: ``,
	60: ``,
	61: ``,
	62: ``,
	63: ``,
	64: ``,
	65: ``,
}

var _KeyFunsMap = map[KeyFuns]string{
	0:  `KeyFunNil`,
	1:  `KeyFunMoveUp`,
	2:  `KeyFunMoveDown`,
	3:  `KeyFunMoveRight`,
	4:  `KeyFunMoveLeft`,
	5:  `KeyFunPageUp`,
	6:  `KeyFunPageDown`,
	7:  `KeyFunHome`,
	8:  `KeyFunEnd`,
	9:  `KeyFunDocHome`,
	10: `KeyFunDocEnd`,
	11: `KeyFunWordRight`,
	12: `KeyFunWordLeft`,
	13: `KeyFunFocusNext`,
	14: `KeyFunFocusPrev`,
	15: `KeyFunEnter`,
	16: `KeyFunAccept`,
	17: `KeyFunCancelSelect`,
	18: `KeyFunSelectMode`,
	19: `KeyFunSelectAll`,
	20: `KeyFunAbort`,
	21: `KeyFunCopy`,
	22: `KeyFunCut`,
	23: `KeyFunPaste`,
	24: `KeyFunPasteHist`,
	25: `KeyFunBackspace`,
	26: `KeyFunBackspaceWord`,
	27: `KeyFunDelete`,
	28: `KeyFunDeleteWord`,
	29: `KeyFunKill`,
	30: `KeyFunDuplicate`,
	31: `KeyFunTranspose`,
	32: `KeyFunTransposeWord`,
	33: `KeyFunUndo`,
	34: `KeyFunRedo`,
	35: `KeyFunInsert`,
	36: `KeyFunInsertAfter`,
	37: `KeyFunZoomOut`,
	38: `KeyFunZoomIn`,
	39: `KeyFunPrefs`,
	40: `KeyFunRefresh`,
	41: `KeyFunRecenter`,
	42: `KeyFunComplete`,
	43: `KeyFunLookup`,
	44: `KeyFunSearch`,
	45: `KeyFunFind`,
	46: `KeyFunReplace`,
	47: `KeyFunJump`,
	48: `KeyFunHistPrev`,
	49: `KeyFunHistNext`,
	50: `KeyFunMenu`,
	51: `KeyFunWinFocusNext`,
	52: `KeyFunWinClose`,
	53: `KeyFunWinSnapshot`,
	54: `KeyFunGoGiEditor`,
	55: `KeyFunMenuNew`,
	56: `KeyFunMenuNewAlt1`,
	57: `KeyFunMenuNewAlt2`,
	58: `KeyFunMenuOpen`,
	59: `KeyFunMenuOpenAlt1`,
	60: `KeyFunMenuOpenAlt2`,
	61: `KeyFunMenuSave`,
	62: `KeyFunMenuSaveAs`,
	63: `KeyFunMenuSaveAlt`,
	64: `KeyFunMenuCloseAlt1`,
	65: `KeyFunMenuCloseAlt2`,
}

// String returns the string representation
// of this KeyFuns value.
func (i KeyFuns) String() string {
	if str, ok := _KeyFunsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the KeyFuns value from its
// string representation, and returns an
// error if the string is invalid.
func (i *KeyFuns) SetString(s string) error {
	if val, ok := _KeyFunsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _KeyFunsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type KeyFuns")
}

// Int64 returns the KeyFuns value as an int64.
func (i KeyFuns) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the KeyFuns value from an int64.
func (i *KeyFuns) SetInt64(in int64) {
	*i = KeyFuns(in)
}

// Desc returns the description of the KeyFuns value.
func (i KeyFuns) Desc() string {
	if str, ok := _KeyFunsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// KeyFunsValues returns all possible values
// for the type KeyFuns.
func KeyFunsValues() []KeyFuns {
	return _KeyFunsValues
}

// Values returns all possible values
// for the type KeyFuns.
func (i KeyFuns) Values() []enums.Enum {
	res := make([]enums.Enum, len(_KeyFunsValues))
	for i, d := range _KeyFunsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type KeyFuns.
func (i KeyFuns) IsValid() bool {
	_, ok := _KeyFunsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i KeyFuns) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *KeyFuns) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _LabelTypesValues = []LabelTypes{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}

// LabelTypesN is the highest valid value
// for type LabelTypes, plus one.
const LabelTypesN LabelTypes = 15

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _LabelTypesNoOp() {
	var x [1]struct{}
	_ = x[LabelDisplayLarge-(0)]
	_ = x[LabelDisplayMedium-(1)]
	_ = x[LabelDisplaySmall-(2)]
	_ = x[LabelHeadlineLarge-(3)]
	_ = x[LabelHeadlineMedium-(4)]
	_ = x[LabelHeadlineSmall-(5)]
	_ = x[LabelTitleLarge-(6)]
	_ = x[LabelTitleMedium-(7)]
	_ = x[LabelTitleSmall-(8)]
	_ = x[LabelBodyLarge-(9)]
	_ = x[LabelBodyMedium-(10)]
	_ = x[LabelBodySmall-(11)]
	_ = x[LabelLabelLarge-(12)]
	_ = x[LabelLabelMedium-(13)]
	_ = x[LabelLabelSmall-(14)]
}

var _LabelTypesNameToValueMap = map[string]LabelTypes{
	`LabelDisplayLarge`:   0,
	`labeldisplaylarge`:   0,
	`LabelDisplayMedium`:  1,
	`labeldisplaymedium`:  1,
	`LabelDisplaySmall`:   2,
	`labeldisplaysmall`:   2,
	`LabelHeadlineLarge`:  3,
	`labelheadlinelarge`:  3,
	`LabelHeadlineMedium`: 4,
	`labelheadlinemedium`: 4,
	`LabelHeadlineSmall`:  5,
	`labelheadlinesmall`:  5,
	`LabelTitleLarge`:     6,
	`labeltitlelarge`:     6,
	`LabelTitleMedium`:    7,
	`labeltitlemedium`:    7,
	`LabelTitleSmall`:     8,
	`labeltitlesmall`:     8,
	`LabelBodyLarge`:      9,
	`labelbodylarge`:      9,
	`LabelBodyMedium`:     10,
	`labelbodymedium`:     10,
	`LabelBodySmall`:      11,
	`labelbodysmall`:      11,
	`LabelLabelLarge`:     12,
	`labellabellarge`:     12,
	`LabelLabelMedium`:    13,
	`labellabelmedium`:    13,
	`LabelLabelSmall`:     14,
	`labellabelsmall`:     14,
}

var _LabelTypesDescMap = map[LabelTypes]string{
	0:  `LabelDisplayLarge is a large, short, and important display label with a default font size of 57px.`,
	1:  `LabelDisplayMedium is a medium-sized, short, and important display label with a default font size of 45px.`,
	2:  `LabelDisplaySmall is a small, short, and important display label with a default font size of 36px.`,
	3:  `LabelHeadlineLarge is a large, high-emphasis headline label with a default font size of 32px.`,
	4:  `LabelHeadlineMedium is a medium-sized, high-emphasis headline label with a default font size of 28px.`,
	5:  `LabelHeadlineSmall is a small, high-emphasis headline label with a default font size of 24px.`,
	6:  `LabelTitleLarge is a large, medium-emphasis title label with a default font size of 22px.`,
	7:  `LabelTitleMedium is a medium-sized, medium-emphasis title label with a default font size of 16px.`,
	8:  `LabelTitleSmall is a small, medium-emphasis title label with a default font size of 14px.`,
	9:  `LabelBodyLarge is a large body label used for longer passages of text with a default font size of 16px.`,
	10: `LabelBodyMedium is a medium-sized body label used for longer passages of text with a default font size of 14px.`,
	11: `LabelBodySmall is a small body label used for longer passages of text with a default font size of 12px.`,
	12: `LabelLabelLarge is a large label used for label text (like a caption or the text inside a button) with a default font size of 14px.`,
	13: `LabelLabelMedium is a medium-sized label used for label text (like a caption or the text inside a button) with a default font size of 12px.`,
	14: `LabelLabelSmall is a small label used for label text (like a caption or the text inside a button) with a default font size of 11px.`,
}

var _LabelTypesMap = map[LabelTypes]string{
	0:  `LabelDisplayLarge`,
	1:  `LabelDisplayMedium`,
	2:  `LabelDisplaySmall`,
	3:  `LabelHeadlineLarge`,
	4:  `LabelHeadlineMedium`,
	5:  `LabelHeadlineSmall`,
	6:  `LabelTitleLarge`,
	7:  `LabelTitleMedium`,
	8:  `LabelTitleSmall`,
	9:  `LabelBodyLarge`,
	10: `LabelBodyMedium`,
	11: `LabelBodySmall`,
	12: `LabelLabelLarge`,
	13: `LabelLabelMedium`,
	14: `LabelLabelSmall`,
}

// String returns the string representation
// of this LabelTypes value.
func (i LabelTypes) String() string {
	if str, ok := _LabelTypesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the LabelTypes value from its
// string representation, and returns an
// error if the string is invalid.
func (i *LabelTypes) SetString(s string) error {
	if val, ok := _LabelTypesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _LabelTypesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type LabelTypes")
}

// Int64 returns the LabelTypes value as an int64.
func (i LabelTypes) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the LabelTypes value from an int64.
func (i *LabelTypes) SetInt64(in int64) {
	*i = LabelTypes(in)
}

// Desc returns the description of the LabelTypes value.
func (i LabelTypes) Desc() string {
	if str, ok := _LabelTypesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// LabelTypesValues returns all possible values
// for the type LabelTypes.
func LabelTypesValues() []LabelTypes {
	return _LabelTypesValues
}

// Values returns all possible values
// for the type LabelTypes.
func (i LabelTypes) Values() []enums.Enum {
	res := make([]enums.Enum, len(_LabelTypesValues))
	for i, d := range _LabelTypesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type LabelTypes.
func (i LabelTypes) IsValid() bool {
	_, ok := _LabelTypesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i LabelTypes) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *LabelTypes) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _LayoutsValues = []Layouts{0, 1, 2, 3, 4, 5, 6}

// LayoutsN is the highest valid value
// for type Layouts, plus one.
const LayoutsN Layouts = 7

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _LayoutsNoOp() {
	var x [1]struct{}
	_ = x[LayoutHoriz-(0)]
	_ = x[LayoutVert-(1)]
	_ = x[LayoutGrid-(2)]
	_ = x[LayoutHorizFlow-(3)]
	_ = x[LayoutVertFlow-(4)]
	_ = x[LayoutStacked-(5)]
	_ = x[LayoutNil-(6)]
}

var _LayoutsNameToValueMap = map[string]Layouts{
	`LayoutHoriz`:     0,
	`layouthoriz`:     0,
	`LayoutVert`:      1,
	`layoutvert`:      1,
	`LayoutGrid`:      2,
	`layoutgrid`:      2,
	`LayoutHorizFlow`: 3,
	`layouthorizflow`: 3,
	`LayoutVertFlow`:  4,
	`layoutvertflow`:  4,
	`LayoutStacked`:   5,
	`layoutstacked`:   5,
	`LayoutNil`:       6,
	`layoutnil`:       6,
}

var _LayoutsDescMap = map[Layouts]string{
	0: `LayoutHoriz arranges items horizontally across a row`,
	1: `LayoutVert arranges items vertically in a column`,
	2: `LayoutGrid arranges items according to a regular grid`,
	3: `LayoutHorizFlow arranges items horizontally across a row, overflowing vertically as needed. Ballpark target width or height props should be set to generate initial first-pass sizing estimates.`,
	4: `LayoutVertFlow arranges items vertically within a column, overflowing horizontally as needed. Ballpark target width or height props should be set to generate initial first-pass sizing estimates.`,
	5: `LayoutStacked arranges items stacked on top of each other -- Top index indicates which to show -- overall size accommodates largest in each dimension`,
	6: `LayoutNil is a nil layout -- doesn&#39;t do anything -- for cases when a parent wants to take over the job of the layout`,
}

var _LayoutsMap = map[Layouts]string{
	0: `LayoutHoriz`,
	1: `LayoutVert`,
	2: `LayoutGrid`,
	3: `LayoutHorizFlow`,
	4: `LayoutVertFlow`,
	5: `LayoutStacked`,
	6: `LayoutNil`,
}

// String returns the string representation
// of this Layouts value.
func (i Layouts) String() string {
	if str, ok := _LayoutsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Layouts value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Layouts) SetString(s string) error {
	if val, ok := _LayoutsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _LayoutsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Layouts")
}

// Int64 returns the Layouts value as an int64.
func (i Layouts) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Layouts value from an int64.
func (i *Layouts) SetInt64(in int64) {
	*i = Layouts(in)
}

// Desc returns the description of the Layouts value.
func (i Layouts) Desc() string {
	if str, ok := _LayoutsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// LayoutsValues returns all possible values
// for the type Layouts.
func LayoutsValues() []Layouts {
	return _LayoutsValues
}

// Values returns all possible values
// for the type Layouts.
func (i Layouts) Values() []enums.Enum {
	res := make([]enums.Enum, len(_LayoutsValues))
	for i, d := range _LayoutsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Layouts.
func (i Layouts) IsValid() bool {
	_, ok := _LayoutsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Layouts) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Layouts) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _RowColValues = []RowCol{0, 1}

// RowColN is the highest valid value
// for type RowCol, plus one.
const RowColN RowCol = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _RowColNoOp() {
	var x [1]struct{}
	_ = x[Row-(0)]
	_ = x[Col-(1)]
}

var _RowColNameToValueMap = map[string]RowCol{
	`Row`: 0,
	`row`: 0,
	`Col`: 1,
	`col`: 1,
}

var _RowColDescMap = map[RowCol]string{
	0: ``,
	1: ``,
}

var _RowColMap = map[RowCol]string{
	0: `Row`,
	1: `Col`,
}

// String returns the string representation
// of this RowCol value.
func (i RowCol) String() string {
	if str, ok := _RowColMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the RowCol value from its
// string representation, and returns an
// error if the string is invalid.
func (i *RowCol) SetString(s string) error {
	if val, ok := _RowColNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _RowColNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type RowCol")
}

// Int64 returns the RowCol value as an int64.
func (i RowCol) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the RowCol value from an int64.
func (i *RowCol) SetInt64(in int64) {
	*i = RowCol(in)
}

// Desc returns the description of the RowCol value.
func (i RowCol) Desc() string {
	if str, ok := _RowColDescMap[i]; ok {
		return str
	}
	return i.String()
}

// RowColValues returns all possible values
// for the type RowCol.
func RowColValues() []RowCol {
	return _RowColValues
}

// Values returns all possible values
// for the type RowCol.
func (i RowCol) Values() []enums.Enum {
	res := make([]enums.Enum, len(_RowColValues))
	for i, d := range _RowColValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type RowCol.
func (i RowCol) IsValid() bool {
	_, ok := _RowColMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i RowCol) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *RowCol) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _DensitiesValues = []Densities{0, 1, 2}

// DensitiesN is the highest valid value
// for type Densities, plus one.
const DensitiesN Densities = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _DensitiesNoOp() {
	var x [1]struct{}
	_ = x[DensityCompact-(0)]
	_ = x[DensityMedium-(1)]
	_ = x[DensitySpread-(2)]
}

var _DensitiesNameToValueMap = map[string]Densities{
	`DensityCompact`: 0,
	`densitycompact`: 0,
	`DensityMedium`:  1,
	`densitymedium`:  1,
	`DensitySpread`:  2,
	`densityspread`:  2,
}

var _DensitiesDescMap = map[Densities]string{
	0: `DensityCompact represents a compact density with minimal whitespace`,
	1: `DensityMedium represents a medium density with medium whitespace`,
	2: `DensitySpread represents a spread-out density with a lot of whitespace`,
}

var _DensitiesMap = map[Densities]string{
	0: `DensityCompact`,
	1: `DensityMedium`,
	2: `DensitySpread`,
}

// String returns the string representation
// of this Densities value.
func (i Densities) String() string {
	if str, ok := _DensitiesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Densities value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Densities) SetString(s string) error {
	if val, ok := _DensitiesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _DensitiesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Densities")
}

// Int64 returns the Densities value as an int64.
func (i Densities) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Densities value from an int64.
func (i *Densities) SetInt64(in int64) {
	*i = Densities(in)
}

// Desc returns the description of the Densities value.
func (i Densities) Desc() string {
	if str, ok := _DensitiesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// DensitiesValues returns all possible values
// for the type Densities.
func DensitiesValues() []Densities {
	return _DensitiesValues
}

// Values returns all possible values
// for the type Densities.
func (i Densities) Values() []enums.Enum {
	res := make([]enums.Enum, len(_DensitiesValues))
	for i, d := range _DensitiesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Densities.
func (i Densities) IsValid() bool {
	_, ok := _DensitiesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Densities) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Densities) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _WinFlagsValues = []WinFlags{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

// WinFlagsN is the highest valid value
// for type WinFlags, plus one.
const WinFlagsN WinFlags = 11

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _WinFlagsNoOp() {
	var x [1]struct{}
	_ = x[WinFlagHasGeomPrefs-(0)]
	_ = x[WinFlagUpdating-(1)]
	_ = x[WinFlagIsClosing-(2)]
	_ = x[WinFlagIsResizing-(3)]
	_ = x[WinFlagGotFocus-(4)]
	_ = x[WinFlagSentShow-(5)]
	_ = x[WinFlagGoLoop-(6)]
	_ = x[WinFlagStopEventLoop-(7)]
	_ = x[WinFlagDoFullRender-(8)]
	_ = x[WinFlagFocusActive-(9)]
	_ = x[WinFlagSelectionMode-(10)]
}

var _WinFlagsNameToValueMap = map[string]WinFlags{
	`WinFlagHasGeomPrefs`:  0,
	`winflaghasgeomprefs`:  0,
	`WinFlagUpdating`:      1,
	`winflagupdating`:      1,
	`WinFlagIsClosing`:     2,
	`winflagisclosing`:     2,
	`WinFlagIsResizing`:    3,
	`winflagisresizing`:    3,
	`WinFlagGotFocus`:      4,
	`winflaggotfocus`:      4,
	`WinFlagSentShow`:      5,
	`winflagsentshow`:      5,
	`WinFlagGoLoop`:        6,
	`winflaggoloop`:        6,
	`WinFlagStopEventLoop`: 7,
	`winflagstopeventloop`: 7,
	`WinFlagDoFullRender`:  8,
	`winflagdofullrender`:  8,
	`WinFlagFocusActive`:   9,
	`winflagfocusactive`:   9,
	`WinFlagSelectionMode`: 10,
	`winflagselectionmode`: 10,
}

var _WinFlagsDescMap = map[WinFlags]string{
	0:  `WinFlagHasGeomPrefs indicates if this window has WinGeomPrefs setting that sized it -- affects whether other default geom should be applied.`,
	1:  `WinFlagUpdating is atomic flag around global updating -- routines can check IsWinUpdating and bail`,
	2:  `WinFlagIsClosing is atomic flag indicating window is closing`,
	3:  `WinFlagIsResizing is atomic flag indicating window is resizing`,
	4:  `WinFlagGotFocus indicates that have we received RenderWin focus`,
	5:  `WinFlagSentShow have we sent the show event yet? Only ever sent ONCE`,
	6:  `WinFlagGoLoop true if we are running from GoStartEventLoop -- requires a WinWait.Done at end`,
	7:  `WinFlagStopEventLoop is set when event loop stop is requested`,
	8:  `WinFlagDoFullRender is set at event loop startup to trigger a full render once the window is properly shown`,
	9:  `WinFlagFocusActive indicates if widget focus is currently in an active state or not`,
	10: `WinSelectionMode indicates that the window is in GoGi inspect editor edit mode`,
}

var _WinFlagsMap = map[WinFlags]string{
	0:  `WinFlagHasGeomPrefs`,
	1:  `WinFlagUpdating`,
	2:  `WinFlagIsClosing`,
	3:  `WinFlagIsResizing`,
	4:  `WinFlagGotFocus`,
	5:  `WinFlagSentShow`,
	6:  `WinFlagGoLoop`,
	7:  `WinFlagStopEventLoop`,
	8:  `WinFlagDoFullRender`,
	9:  `WinFlagFocusActive`,
	10: `WinFlagSelectionMode`,
}

// String returns the string representation
// of this WinFlags value.
func (i WinFlags) String() string {
	str := ""
	for _, ie := range _WinFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this WinFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i WinFlags) BitIndexString() string {
	if str, ok := _WinFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the WinFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *WinFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the WinFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *WinFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _WinFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _WinFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type WinFlags")
		}
	}
	return nil
}

// Int64 returns the WinFlags value as an int64.
func (i WinFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the WinFlags value from an int64.
func (i *WinFlags) SetInt64(in int64) {
	*i = WinFlags(in)
}

// Desc returns the description of the WinFlags value.
func (i WinFlags) Desc() string {
	if str, ok := _WinFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// WinFlagsValues returns all possible values
// for the type WinFlags.
func WinFlagsValues() []WinFlags {
	return _WinFlagsValues
}

// Values returns all possible values
// for the type WinFlags.
func (i WinFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_WinFlagsValues))
	for i, d := range _WinFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type WinFlags.
func (i WinFlags) IsValid() bool {
	_, ok := _WinFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i WinFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *WinFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i WinFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *WinFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _ScFlagsValues = []ScFlags{0, 1, 2, 3, 4, 5, 6}

// ScFlagsN is the highest valid value
// for type ScFlags, plus one.
const ScFlagsN ScFlags = 7

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ScFlagsNoOp() {
	var x [1]struct{}
	_ = x[ScIsUpdating-(0)]
	_ = x[ScNeedsRender-(1)]
	_ = x[ScNeedsLayout-(2)]
	_ = x[ScNeedsRebuild-(3)]
	_ = x[ScRebuild-(4)]
	_ = x[ScPrefSizing-(5)]
	_ = x[ScPreserve-(6)]
}

var _ScFlagsNameToValueMap = map[string]ScFlags{
	`ScIsUpdating`:   0,
	`scisupdating`:   0,
	`ScNeedsRender`:  1,
	`scneedsrender`:  1,
	`ScNeedsLayout`:  2,
	`scneedslayout`:  2,
	`ScNeedsRebuild`: 3,
	`scneedsrebuild`: 3,
	`ScRebuild`:      4,
	`screbuild`:      4,
	`ScPrefSizing`:   5,
	`scprefsizing`:   5,
	`ScPreserve`:     6,
	`scpreserve`:     6,
}

var _ScFlagsDescMap = map[ScFlags]string{
	0: `ScIsUpdating means scene is in the process of updating: set for any kind of tree-level update. skip any further update passes until it goes off.`,
	1: `ScNeedsRender means nodes have flagged that they need a Render update.`,
	2: `ScNeedsLayout means that this scene needs DoLayout stack: GetSize, DoLayout, then Render. This is true after any Config.`,
	3: `ScNeedsRebuild means that this scene needs full Rebuild: Config, Layout, Render with DoRebuild flag set (e.g., after global style changes, zooming, etc)`,
	4: `ScRebuild triggers extra rebuilding of all elements during Config, including all icons, sprites, cursors, etc. Set by DoRebuild call.`,
	5: `ScPrefSizing means that this scene is currently doing a PrefSize computation to compute the size of the scene (for sizing window for example) -- affects layout size computation only for Over`,
	6: `ScPreserve keeps this scene around instead of deleting when it is no longer needed. Set if added to SceneLibrary for example.`,
}

var _ScFlagsMap = map[ScFlags]string{
	0: `ScIsUpdating`,
	1: `ScNeedsRender`,
	2: `ScNeedsLayout`,
	3: `ScNeedsRebuild`,
	4: `ScRebuild`,
	5: `ScPrefSizing`,
	6: `ScPreserve`,
}

// String returns the string representation
// of this ScFlags value.
func (i ScFlags) String() string {
	str := ""
	for _, ie := range _ScFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this ScFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i ScFlags) BitIndexString() string {
	if str, ok := _ScFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the ScFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *ScFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the ScFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *ScFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _ScFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _ScFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type ScFlags")
		}
	}
	return nil
}

// Int64 returns the ScFlags value as an int64.
func (i ScFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the ScFlags value from an int64.
func (i *ScFlags) SetInt64(in int64) {
	*i = ScFlags(in)
}

// Desc returns the description of the ScFlags value.
func (i ScFlags) Desc() string {
	if str, ok := _ScFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// ScFlagsValues returns all possible values
// for the type ScFlags.
func ScFlagsValues() []ScFlags {
	return _ScFlagsValues
}

// Values returns all possible values
// for the type ScFlags.
func (i ScFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_ScFlagsValues))
	for i, d := range _ScFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type ScFlags.
func (i ScFlags) IsValid() bool {
	_, ok := _ScFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i ScFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *ScFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ScFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ScFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _StageTypesValues = []StageTypes{0, 1, 2, 3, 4, 5, 6}

// StageTypesN is the highest valid value
// for type StageTypes, plus one.
const StageTypesN StageTypes = 7

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _StageTypesNoOp() {
	var x [1]struct{}
	_ = x[Window-(0)]
	_ = x[Dialog-(1)]
	_ = x[Sheet-(2)]
	_ = x[Menu-(3)]
	_ = x[Tooltip-(4)]
	_ = x[Snackbar-(5)]
	_ = x[Chooser-(6)]
}

var _StageTypesNameToValueMap = map[string]StageTypes{
	`Window`:   0,
	`window`:   0,
	`Dialog`:   1,
	`dialog`:   1,
	`Sheet`:    2,
	`sheet`:    2,
	`Menu`:     3,
	`menu`:     3,
	`Tooltip`:  4,
	`tooltip`:  4,
	`Snackbar`: 5,
	`snackbar`: 5,
	`Chooser`:  6,
	`chooser`:  6,
}

var _StageTypesDescMap = map[StageTypes]string{
	0: `Window is a MainStage that displays a Scene in a full window. One of these must be created first, as the primary App contents, and it typically persists throughout. It fills the RenderWin window. Additional Windows can be created either within the same RenderWin (Mobile) or in separate RenderWin windows (Desktop, OwnWin).`,
	1: `Dialog is a MainStage that displays Scene in a smaller dialog window on top of a Window, or in its own RenderWin (on Desktop only). It can be Modal or not.`,
	2: `Sheet is a MainStage that displays Scene as a partially overlapping panel coming up from the Bottom or LeftSide of the RenderWin main window. It can be Modal or not.`,
	3: `Menu is a PopupStage that displays a Scene with Action Widgets overlaid on a MainStage. It is typically Modal and ClickOff, and closes when an Action is selected.`,
	4: `Tooltip is a PopupStage that displays a Scene with extra info overlaid on a MainStage. It is typically ClickOff and not Modal.`,
	5: `Snackbar is a PopupStage displays a Scene with info and typically an additional optional Action, usually displayed at the bottom. It is typically not ClickOff or Modal, but has a timeout.`,
	6: `Chooser is a PopupStage that displays a Scene with text completions, spelling corrections, or other such dynamic info. It is typically ClickOff, not Modal, dynamically updating, and closes when something is selected or typing renders it no longer relevant.`,
}

var _StageTypesMap = map[StageTypes]string{
	0: `Window`,
	1: `Dialog`,
	2: `Sheet`,
	3: `Menu`,
	4: `Tooltip`,
	5: `Snackbar`,
	6: `Chooser`,
}

// String returns the string representation
// of this StageTypes value.
func (i StageTypes) String() string {
	if str, ok := _StageTypesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the StageTypes value from its
// string representation, and returns an
// error if the string is invalid.
func (i *StageTypes) SetString(s string) error {
	if val, ok := _StageTypesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _StageTypesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type StageTypes")
}

// Int64 returns the StageTypes value as an int64.
func (i StageTypes) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the StageTypes value from an int64.
func (i *StageTypes) SetInt64(in int64) {
	*i = StageTypes(in)
}

// Desc returns the description of the StageTypes value.
func (i StageTypes) Desc() string {
	if str, ok := _StageTypesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// StageTypesValues returns all possible values
// for the type StageTypes.
func StageTypesValues() []StageTypes {
	return _StageTypesValues
}

// Values returns all possible values
// for the type StageTypes.
func (i StageTypes) Values() []enums.Enum {
	res := make([]enums.Enum, len(_StageTypesValues))
	for i, d := range _StageTypesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type StageTypes.
func (i StageTypes) IsValid() bool {
	_, ok := _StageTypesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i StageTypes) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *StageTypes) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _StageSidesValues = []StageSides{0, 1}

// StageSidesN is the highest valid value
// for type StageSides, plus one.
const StageSidesN StageSides = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _StageSidesNoOp() {
	var x [1]struct{}
	_ = x[Bottom-(0)]
	_ = x[LeftSide-(1)]
}

var _StageSidesNameToValueMap = map[string]StageSides{
	`Bottom`:   0,
	`bottom`:   0,
	`LeftSide`: 1,
	`leftside`: 1,
}

var _StageSidesDescMap = map[StageSides]string{
	0: `Bottom anchors Sheet to the bottom of the window, with handle on the top`,
	1: `LeftSide anchors Sheet to the left side of the window, with handle on the top`,
}

var _StageSidesMap = map[StageSides]string{
	0: `Bottom`,
	1: `LeftSide`,
}

// String returns the string representation
// of this StageSides value.
func (i StageSides) String() string {
	if str, ok := _StageSidesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the StageSides value from its
// string representation, and returns an
// error if the string is invalid.
func (i *StageSides) SetString(s string) error {
	if val, ok := _StageSidesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _StageSidesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type StageSides")
}

// Int64 returns the StageSides value as an int64.
func (i StageSides) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the StageSides value from an int64.
func (i *StageSides) SetInt64(in int64) {
	*i = StageSides(in)
}

// Desc returns the description of the StageSides value.
func (i StageSides) Desc() string {
	if str, ok := _StageSidesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// StageSidesValues returns all possible values
// for the type StageSides.
func StageSidesValues() []StageSides {
	return _StageSidesValues
}

// Values returns all possible values
// for the type StageSides.
func (i StageSides) Values() []enums.Enum {
	res := make([]enums.Enum, len(_StageSidesValues))
	for i, d := range _StageSidesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type StageSides.
func (i StageSides) IsValid() bool {
	_, ok := _StageSidesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i StageSides) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *StageSides) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextFieldTypesValues = []TextFieldTypes{0, 1}

// TextFieldTypesN is the highest valid value
// for type TextFieldTypes, plus one.
const TextFieldTypesN TextFieldTypes = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextFieldTypesNoOp() {
	var x [1]struct{}
	_ = x[TextFieldFilled-(0)]
	_ = x[TextFieldOutlined-(1)]
}

var _TextFieldTypesNameToValueMap = map[string]TextFieldTypes{
	`TextFieldFilled`:   0,
	`textfieldfilled`:   0,
	`TextFieldOutlined`: 1,
	`textfieldoutlined`: 1,
}

var _TextFieldTypesDescMap = map[TextFieldTypes]string{
	0: `TextFieldFilled represents a filled TextField with a background color and a bottom border`,
	1: `TextFieldOutlined represents an outlined TextField with a border on all sides and no background color`,
}

var _TextFieldTypesMap = map[TextFieldTypes]string{
	0: `TextFieldFilled`,
	1: `TextFieldOutlined`,
}

// String returns the string representation
// of this TextFieldTypes value.
func (i TextFieldTypes) String() string {
	if str, ok := _TextFieldTypesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TextFieldTypes value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextFieldTypes) SetString(s string) error {
	if val, ok := _TextFieldTypesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TextFieldTypesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type TextFieldTypes")
}

// Int64 returns the TextFieldTypes value as an int64.
func (i TextFieldTypes) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextFieldTypes value from an int64.
func (i *TextFieldTypes) SetInt64(in int64) {
	*i = TextFieldTypes(in)
}

// Desc returns the description of the TextFieldTypes value.
func (i TextFieldTypes) Desc() string {
	if str, ok := _TextFieldTypesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TextFieldTypesValues returns all possible values
// for the type TextFieldTypes.
func TextFieldTypesValues() []TextFieldTypes {
	return _TextFieldTypesValues
}

// Values returns all possible values
// for the type TextFieldTypes.
func (i TextFieldTypes) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TextFieldTypesValues))
	for i, d := range _TextFieldTypesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextFieldTypes.
func (i TextFieldTypes) IsValid() bool {
	_, ok := _TextFieldTypesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextFieldTypes) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextFieldTypes) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextFieldSignalsValues = []TextFieldSignals{0, 1, 2, 3, 4, 5, 6}

// TextFieldSignalsN is the highest valid value
// for type TextFieldSignals, plus one.
const TextFieldSignalsN TextFieldSignals = 7

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextFieldSignalsNoOp() {
	var x [1]struct{}
	_ = x[TextFieldDone-(0)]
	_ = x[TextFieldDeFocused-(1)]
	_ = x[TextFieldSelected-(2)]
	_ = x[TextFieldCleared-(3)]
	_ = x[TextFieldInsert-(4)]
	_ = x[TextFieldBackspace-(5)]
	_ = x[TextFieldDelete-(6)]
}

var _TextFieldSignalsNameToValueMap = map[string]TextFieldSignals{
	`TextFieldDone`:      0,
	`textfielddone`:      0,
	`TextFieldDeFocused`: 1,
	`textfielddefocused`: 1,
	`TextFieldSelected`:  2,
	`textfieldselected`:  2,
	`TextFieldCleared`:   3,
	`textfieldcleared`:   3,
	`TextFieldInsert`:    4,
	`textfieldinsert`:    4,
	`TextFieldBackspace`: 5,
	`textfieldbackspace`: 5,
	`TextFieldDelete`:    6,
	`textfielddelete`:    6,
}

var _TextFieldSignalsDescMap = map[TextFieldSignals]string{
	0: `TextFieldDone is main signal -- return or tab was pressed and the edit was intentionally completed. data is the text.`,
	1: `TextFieldDeFocused means that the user has transitioned focus away from the text field due to interactions elsewhere, and any ongoing changes have been applied and the editor is no longer active. data is the text. If you have a button that performs the same action as pressing enter in a textfield, then pressing that button will trigger a TextFieldDeFocused event, for any active edits. Otherwise, you probably want to respond to both TextFieldDone and TextFieldDeFocused as &#34;apply&#34; events that trigger actions associated with the field.`,
	2: `TextFieldSelected means that some text was selected (for Inactive state, selection is via WidgetSig)`,
	3: `TextFieldCleared means the clear button was clicked`,
	4: `TextFieldInsert is emitted when a character is inserted into the textfield`,
	5: `TextFieldBackspace is emitted when a character before cursor is deleted`,
	6: `TextFieldDelete is emitted when a character after cursor is deleted`,
}

var _TextFieldSignalsMap = map[TextFieldSignals]string{
	0: `TextFieldDone`,
	1: `TextFieldDeFocused`,
	2: `TextFieldSelected`,
	3: `TextFieldCleared`,
	4: `TextFieldInsert`,
	5: `TextFieldBackspace`,
	6: `TextFieldDelete`,
}

// String returns the string representation
// of this TextFieldSignals value.
func (i TextFieldSignals) String() string {
	if str, ok := _TextFieldSignalsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TextFieldSignals value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextFieldSignals) SetString(s string) error {
	if val, ok := _TextFieldSignalsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TextFieldSignalsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type TextFieldSignals")
}

// Int64 returns the TextFieldSignals value as an int64.
func (i TextFieldSignals) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextFieldSignals value from an int64.
func (i *TextFieldSignals) SetInt64(in int64) {
	*i = TextFieldSignals(in)
}

// Desc returns the description of the TextFieldSignals value.
func (i TextFieldSignals) Desc() string {
	if str, ok := _TextFieldSignalsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TextFieldSignalsValues returns all possible values
// for the type TextFieldSignals.
func TextFieldSignalsValues() []TextFieldSignals {
	return _TextFieldSignalsValues
}

// Values returns all possible values
// for the type TextFieldSignals.
func (i TextFieldSignals) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TextFieldSignalsValues))
	for i, d := range _TextFieldSignalsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextFieldSignals.
func (i TextFieldSignals) IsValid() bool {
	_, ok := _TextFieldSignalsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextFieldSignals) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextFieldSignals) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextFieldFlagsValues = []TextFieldFlags{23}

// TextFieldFlagsN is the highest valid value
// for type TextFieldFlags, plus one.
const TextFieldFlagsN TextFieldFlags = 24

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextFieldFlagsNoOp() {
	var x [1]struct{}
	_ = x[TextFieldFocusActive-(23)]
}

var _TextFieldFlagsNameToValueMap = map[string]TextFieldFlags{
	`TextFieldFocusActive`: 23,
	`textfieldfocusactive`: 23,
}

var _TextFieldFlagsDescMap = map[TextFieldFlags]string{
	23: `TextFieldFocusActive indicates that the focus is active in this field`,
}

var _TextFieldFlagsMap = map[TextFieldFlags]string{
	23: `TextFieldFocusActive`,
}

// String returns the string representation
// of this TextFieldFlags value.
func (i TextFieldFlags) String() string {
	str := ""
	for _, ie := range WidgetFlagsValues() {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	for _, ie := range _TextFieldFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this TextFieldFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i TextFieldFlags) BitIndexString() string {
	if str, ok := _TextFieldFlagsMap[i]; ok {
		return str
	}
	return WidgetFlags(i).BitIndexString()
}

// SetString sets the TextFieldFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextFieldFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the TextFieldFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *TextFieldFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _TextFieldFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _TextFieldFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			err := (*WidgetFlags)(i).SetStringOr(flg)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Int64 returns the TextFieldFlags value as an int64.
func (i TextFieldFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextFieldFlags value from an int64.
func (i *TextFieldFlags) SetInt64(in int64) {
	*i = TextFieldFlags(in)
}

// Desc returns the description of the TextFieldFlags value.
func (i TextFieldFlags) Desc() string {
	if str, ok := _TextFieldFlagsDescMap[i]; ok {
		return str
	}
	return WidgetFlags(i).Desc()
}

// TextFieldFlagsValues returns all possible values
// for the type TextFieldFlags.
func TextFieldFlagsValues() []TextFieldFlags {
	es := WidgetFlagsValues()
	res := make([]TextFieldFlags, len(es))
	for i, e := range es {
		res[i] = TextFieldFlags(e)
	}
	res = append(res, _TextFieldFlagsValues...)
	return res
}

// Values returns all possible values
// for the type TextFieldFlags.
func (i TextFieldFlags) Values() []enums.Enum {
	es := WidgetFlagsValues()
	les := len(es)
	res := make([]enums.Enum, les+len(_TextFieldFlagsValues))
	for i, d := range es {
		res[i] = d
	}
	for i, d := range _TextFieldFlagsValues {
		res[i+les] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextFieldFlags.
func (i TextFieldFlags) IsValid() bool {
	_, ok := _TextFieldFlagsMap[i]
	if !ok {
		return WidgetFlags(i).IsValid()
	}
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i TextFieldFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *TextFieldFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextFieldFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextFieldFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}
