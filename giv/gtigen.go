// Code generated by "goki generate ./..."; DO NOT EDIT.

package giv

import (
	"reflect"
	"sync"

	"goki.dev/cam/hsl"
	"goki.dev/colors/colormap"
	"goki.dev/gi/v2/gi"
	"goki.dev/girl/units"
	"goki.dev/goosi/events/key"
	"goki.dev/gti"
	"goki.dev/icons"
	"goki.dev/ki/v2"
	"goki.dev/mat32/v2"
	"goki.dev/ordmap"
	"goki.dev/pi/v2/filecat"
	"goki.dev/vci/v2"
)

// ArgViewType is the [gti.Type] for [ArgView]
var ArgViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.ArgView",
	ShortName:  "giv.ArgView",
	IDName:     "arg-view",
	Doc:        "ArgView represents a slice of reflect.Value's and associated names, for the\npurpose of supplying arguments to methods called via the MethodView\nframework.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Title", &gti.Field{Name: "Title", Type: "string", LocalType: "string", Doc: "title / prompt to show above the editor fields", Directives: gti.Directives{}, Tag: ""}},
		{"Args", &gti.Field{Name: "Args", Type: "[]goki.dev/gi/v2/giv.Value", LocalType: "[]Value", Doc: "the args that we are a view onto", Directives: gti.Directives{}, Tag: ""}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", LocalType: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "goki.dev/gi/v2/gi.Frame", LocalType: "gi.Frame", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ArgView{},
})

// NewArgView adds a new [ArgView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewArgView(par ki.Ki, name ...string) *ArgView {
	return par.NewChild(ArgViewType, name...).(*ArgView)
}

// KiType returns the [*gti.Type] of [ArgView]
func (t *ArgView) KiType() *gti.Type {
	return ArgViewType
}

// New returns a new [*ArgView] value
func (t *ArgView) New() ki.Ki {
	return &ArgView{}
}

// SetTitle sets the [ArgView.Title]:
// title / prompt to show above the editor fields
func (t *ArgView) SetTitle(v string) *ArgView {
	t.Title = v
	return t
}

// SetArgs sets the [ArgView.Args]:
// the args that we are a view onto
func (t *ArgView) SetArgs(v []Value) *ArgView {
	t.Args = v
	return t
}

// SetViewPath sets the [ArgView.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *ArgView) SetViewPath(v string) *ArgView {
	t.ViewPath = v
	return t
}

// SetTooltip sets the [ArgView.Tooltip]
func (t *ArgView) SetTooltip(v string) *ArgView {
	t.Tooltip = v
	return t
}

// SetClass sets the [ArgView.Class]
func (t *ArgView) SetClass(v string) *ArgView {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [ArgView.CustomContextMenu]
func (t *ArgView) SetCustomContextMenu(v func(m *gi.Scene)) *ArgView {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [ArgView.Lay]
func (t *ArgView) SetLayout(v gi.Layouts) *ArgView {
	t.Lay = v
	return t
}

// SetSpacing sets the [ArgView.Spacing]
func (t *ArgView) SetSpacing(v units.Value) *ArgView {
	t.Spacing = v
	return t
}

// SetStackTop sets the [ArgView.StackTop]
func (t *ArgView) SetStackTop(v int) *ArgView {
	t.StackTop = v
	return t
}

// SetStripes sets the [ArgView.Stripes]
func (t *ArgView) SetStripes(v gi.Stripes) *ArgView {
	t.Stripes = v
	return t
}

// ColorMapViewType is the [gti.Type] for [ColorMapView]
var ColorMapViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.ColorMapView",
	ShortName:  "giv.ColorMapView",
	IDName:     "color-map-view",
	Doc:        "ColorMapView is a widget that displays a ColorMap.\nNote that this is not a Value widget",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Orient", &gti.Field{Name: "Orient", Type: "goki.dev/mat32/v2.Dims", LocalType: "mat32.Dims", Doc: "orientation along which to display the spectrum", Directives: gti.Directives{}, Tag: ""}},
		{"Map", &gti.Field{Name: "Map", Type: "*goki.dev/colors/colormap.Map", LocalType: "*colormap.Map", Doc: "the colormap that we view", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "gi.WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ColorMapView{},
})

// NewColorMapView adds a new [ColorMapView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewColorMapView(par ki.Ki, name ...string) *ColorMapView {
	return par.NewChild(ColorMapViewType, name...).(*ColorMapView)
}

// KiType returns the [*gti.Type] of [ColorMapView]
func (t *ColorMapView) KiType() *gti.Type {
	return ColorMapViewType
}

// New returns a new [*ColorMapView] value
func (t *ColorMapView) New() ki.Ki {
	return &ColorMapView{}
}

// SetOrient sets the [ColorMapView.Orient]:
// orientation along which to display the spectrum
func (t *ColorMapView) SetOrient(v mat32.Dims) *ColorMapView {
	t.Orient = v
	return t
}

// SetMap sets the [ColorMapView.Map]:
// the colormap that we view
func (t *ColorMapView) SetMap(v *colormap.Map) *ColorMapView {
	t.Map = v
	return t
}

// SetTooltip sets the [ColorMapView.Tooltip]
func (t *ColorMapView) SetTooltip(v string) *ColorMapView {
	t.Tooltip = v
	return t
}

// SetClass sets the [ColorMapView.Class]
func (t *ColorMapView) SetClass(v string) *ColorMapView {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [ColorMapView.CustomContextMenu]
func (t *ColorMapView) SetCustomContextMenu(v func(m *gi.Scene)) *ColorMapView {
	t.CustomContextMenu = v
	return t
}

// ColorViewType is the [gti.Type] for [ColorView]
var ColorViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.ColorView",
	ShortName:  "giv.ColorView",
	IDName:     "color-view",
	Doc:        "ColorView shows a color, using sliders or numbers to set values.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Color", &gti.Field{Name: "Color", Type: "image/color.RGBA", LocalType: "color.RGBA", Doc: "the color that we view", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"ColorHSLA", &gti.Field{Name: "ColorHSLA", Type: "goki.dev/cam/hsl.HSL", LocalType: "hsl.HSL", Doc: "the color that we view, in HSLA form", Directives: gti.Directives{}, Tag: "edit:\"-\""}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", LocalType: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "goki.dev/gi/v2/gi.Frame", LocalType: "gi.Frame", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ColorView{},
})

// NewColorView adds a new [ColorView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewColorView(par ki.Ki, name ...string) *ColorView {
	return par.NewChild(ColorViewType, name...).(*ColorView)
}

// KiType returns the [*gti.Type] of [ColorView]
func (t *ColorView) KiType() *gti.Type {
	return ColorViewType
}

// New returns a new [*ColorView] value
func (t *ColorView) New() ki.Ki {
	return &ColorView{}
}

// SetColorHsla sets the [ColorView.ColorHSLA]:
// the color that we view, in HSLA form
func (t *ColorView) SetColorHsla(v hsl.HSL) *ColorView {
	t.ColorHSLA = v
	return t
}

// SetTmpSave sets the [ColorView.TmpSave]:
// value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent
func (t *ColorView) SetTmpSave(v Value) *ColorView {
	t.TmpSave = v
	return t
}

// SetViewPath sets the [ColorView.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *ColorView) SetViewPath(v string) *ColorView {
	t.ViewPath = v
	return t
}

// SetTooltip sets the [ColorView.Tooltip]
func (t *ColorView) SetTooltip(v string) *ColorView {
	t.Tooltip = v
	return t
}

// SetClass sets the [ColorView.Class]
func (t *ColorView) SetClass(v string) *ColorView {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [ColorView.CustomContextMenu]
func (t *ColorView) SetCustomContextMenu(v func(m *gi.Scene)) *ColorView {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [ColorView.Lay]
func (t *ColorView) SetLayout(v gi.Layouts) *ColorView {
	t.Lay = v
	return t
}

// SetSpacing sets the [ColorView.Spacing]
func (t *ColorView) SetSpacing(v units.Value) *ColorView {
	t.Spacing = v
	return t
}

// SetStackTop sets the [ColorView.StackTop]
func (t *ColorView) SetStackTop(v int) *ColorView {
	t.StackTop = v
	return t
}

// SetStripes sets the [ColorView.Stripes]
func (t *ColorView) SetStripes(v gi.Stripes) *ColorView {
	t.Stripes = v
	return t
}

// FileViewType is the [gti.Type] for [FileView]
var FileViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.FileView",
	ShortName:  "giv.FileView",
	IDName:     "file-view",
	Doc:        "FileView is a viewer onto files -- core of the file chooser dialog",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"DirPath", &gti.Field{Name: "DirPath", Type: "string", LocalType: "string", Doc: "path to directory of files to display", Directives: gti.Directives{}, Tag: ""}},
		{"SelFile", &gti.Field{Name: "SelFile", Type: "string", LocalType: "string", Doc: "selected file", Directives: gti.Directives{}, Tag: ""}},
		{"Ext", &gti.Field{Name: "Ext", Type: "string", LocalType: "string", Doc: "target extension(s) (comma separated if multiple, including initial .), if any", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"FilterFunc", &gti.Field{Name: "FilterFunc", Type: "goki.dev/gi/v2/giv.FileViewFilterFunc", LocalType: "FileViewFilterFunc", Doc: "optional styling function", Directives: gti.Directives{}, Tag: "view:\"-\" json:\"-\" xml:\"-\""}},
		{"ExtMap", &gti.Field{Name: "ExtMap", Type: "map[string]string", LocalType: "map[string]string", Doc: "map of lower-cased extensions from Ext -- used for highlighting files with one of these extensions -- maps onto original ext value", Directives: gti.Directives{}, Tag: ""}},
		{"Files", &gti.Field{Name: "Files", Type: "[]*goki.dev/pi/v2/filecat.FileInfo", LocalType: "[]*filecat.FileInfo", Doc: "files for current directory", Directives: gti.Directives{}, Tag: ""}},
		{"SelectedIdx", &gti.Field{Name: "SelectedIdx", Type: "int", LocalType: "int", Doc: "index of currently-selected file in Files list (-1 if none)", Directives: gti.Directives{}, Tag: "set:\"-\" edit:\"-\""}},
		{"Watcher", &gti.Field{Name: "Watcher", Type: "*github.com/fsnotify/fsnotify.Watcher", LocalType: "*fsnotify.Watcher", Doc: "change notify for current dir", Directives: gti.Directives{}, Tag: "set:\"-\" view:\"-\""}},
		{"DoneWatcher", &gti.Field{Name: "DoneWatcher", Type: "chan bool", LocalType: "chan bool", Doc: "channel to close watcher watcher", Directives: gti.Directives{}, Tag: "set:\"-\" view:\"-\""}},
		{"UpdtMu", &gti.Field{Name: "UpdtMu", Type: "sync.Mutex", LocalType: "sync.Mutex", Doc: "UpdateFiles mutex", Directives: gti.Directives{}, Tag: "set:\"-\" view:\"-\""}},
		{"PrevPath", &gti.Field{Name: "PrevPath", Type: "string", LocalType: "string", Doc: "Previous path that was processed via UpdateFiles", Directives: gti.Directives{}, Tag: "set:\"-\" view:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "goki.dev/gi/v2/gi.Frame", LocalType: "gi.Frame", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &FileView{},
})

// NewFileView adds a new [FileView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewFileView(par ki.Ki, name ...string) *FileView {
	return par.NewChild(FileViewType, name...).(*FileView)
}

// KiType returns the [*gti.Type] of [FileView]
func (t *FileView) KiType() *gti.Type {
	return FileViewType
}

// New returns a new [*FileView] value
func (t *FileView) New() ki.Ki {
	return &FileView{}
}

// SetDirPath sets the [FileView.DirPath]:
// path to directory of files to display
func (t *FileView) SetDirPath(v string) *FileView {
	t.DirPath = v
	return t
}

// SetSelFile sets the [FileView.SelFile]:
// selected file
func (t *FileView) SetSelFile(v string) *FileView {
	t.SelFile = v
	return t
}

// SetFilterFunc sets the [FileView.FilterFunc]:
// optional styling function
func (t *FileView) SetFilterFunc(v FileViewFilterFunc) *FileView {
	t.FilterFunc = v
	return t
}

// SetExtMap sets the [FileView.ExtMap]:
// map of lower-cased extensions from Ext -- used for highlighting files with one of these extensions -- maps onto original ext value
func (t *FileView) SetExtMap(v map[string]string) *FileView {
	t.ExtMap = v
	return t
}

// SetFiles sets the [FileView.Files]:
// files for current directory
func (t *FileView) SetFiles(v []*filecat.FileInfo) *FileView {
	t.Files = v
	return t
}

// SetTooltip sets the [FileView.Tooltip]
func (t *FileView) SetTooltip(v string) *FileView {
	t.Tooltip = v
	return t
}

// SetClass sets the [FileView.Class]
func (t *FileView) SetClass(v string) *FileView {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [FileView.CustomContextMenu]
func (t *FileView) SetCustomContextMenu(v func(m *gi.Scene)) *FileView {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [FileView.Lay]
func (t *FileView) SetLayout(v gi.Layouts) *FileView {
	t.Lay = v
	return t
}

// SetSpacing sets the [FileView.Spacing]
func (t *FileView) SetSpacing(v units.Value) *FileView {
	t.Spacing = v
	return t
}

// SetStackTop sets the [FileView.StackTop]
func (t *FileView) SetStackTop(v int) *FileView {
	t.StackTop = v
	return t
}

// SetStripes sets the [FileView.Stripes]
func (t *FileView) SetStripes(v gi.Stripes) *FileView {
	t.Stripes = v
	return t
}

// FuncButtonType is the [gti.Type] for [FuncButton]
var FuncButtonType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/giv.FuncButton",
	ShortName: "giv.FuncButton",
	IDName:    "func-button",
	Doc:       "FuncButton is a button that is set up to call a function when it\nis pressed, using a dialog to prompt the user for any arguments.\nAlso, it automatically sets various properties of the button like\nthe name, text, tooltip, and icon based on the properties of the\nfunction, using reflect and gti. The function must be registered\nwith gti to get documentation information, but that is not required;\nadd a `//gti:add` comment directive and run `goki generate`\nif you want tooltips. If the function is a method, both the method and\nits receiver type must be added to gti to get documentation.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "no-new", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Func", &gti.Field{Name: "Func", Type: "*goki.dev/gti.Func", LocalType: "*gti.Func", Doc: "Func is the [gti.Func] associated with this button.\nThis function can also be a method, but it must be\nconverted to a [gti.Func] first. It should typically\nbe set using [FuncButton.SetFunc].", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"ReflectFunc", &gti.Field{Name: "ReflectFunc", Type: "reflect.Value", LocalType: "reflect.Value", Doc: "ReflectFunc is the [reflect.Value] of the function or\nmethod associated with this button. It should typically\nbet set using [FuncButton.SetFunc].", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Args", &gti.Field{Name: "Args", Type: "[]goki.dev/gi/v2/giv.Value", LocalType: "[]Value", Doc: "Args are the [Value] objects associated with the\narguments of the function. They are automatically set in\n[SetFunc], but they can be customized to configure\ndefault values and other options.", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Returns", &gti.Field{Name: "Returns", Type: "[]goki.dev/gi/v2/giv.Value", LocalType: "[]Value", Doc: "Returns are the [Value] objects associated with the\nreturn values of the function. They are automatically\nset in [SetFunc], but they can be customized to configure\ndefault values and other options. The [reflect.Value]s of\nthe [Value] objects are not set until the function is\ncalled, and are thus not typically applicable to access.", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Confirm", &gti.Field{Name: "Confirm", Type: "bool", LocalType: "bool", Doc: "Confirm is whether to prompt the user for confirmation\nbefore calling the function.", Directives: gti.Directives{}, Tag: ""}},
		{"ShowReturn", &gti.Field{Name: "ShowReturn", Type: "bool", LocalType: "bool", Doc: "ShowReturn is whether to display the return values of\nthe function (and a success message if there are none).\nThe way that the return values are shown is determined\nby ShowReturnAsDialog. ShowReturn is on by default, unless\nthe function has no return values.", Directives: gti.Directives{}, Tag: "def:\"true\""}},
		{"ShowReturnAsDialog", &gti.Field{Name: "ShowReturnAsDialog", Type: "bool", LocalType: "bool", Doc: "ShowReturnAsDialog, if and only if ShowReturn is true,\nindicates to show the return values of the function in\na dialog, instead of in a snackbar, as they are by default.\nIf there are multiple return values from the function, or if\none of them is a complex type (pointer, struct, slice,\narray, map), then ShowReturnAsDialog will\nautomatically be set to true.", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Button", &gti.Field{Name: "Button", Type: "goki.dev/gi/v2/gi.Button", LocalType: "gi.Button", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &FuncButton{},
})

// KiType returns the [*gti.Type] of [FuncButton]
func (t *FuncButton) KiType() *gti.Type {
	return FuncButtonType
}

// New returns a new [*FuncButton] value
func (t *FuncButton) New() ki.Ki {
	return &FuncButton{}
}

// SetConfirm sets the [FuncButton.Confirm]:
// Confirm is whether to prompt the user for confirmation
// before calling the function.
func (t *FuncButton) SetConfirm(v bool) *FuncButton {
	t.Confirm = v
	return t
}

// SetShowReturn sets the [FuncButton.ShowReturn]:
// ShowReturn is whether to display the return values of
// the function (and a success message if there are none).
// The way that the return values are shown is determined
// by ShowReturnAsDialog. ShowReturn is on by default, unless
// the function has no return values.
func (t *FuncButton) SetShowReturn(v bool) *FuncButton {
	t.ShowReturn = v
	return t
}

// SetShowReturnAsDialog sets the [FuncButton.ShowReturnAsDialog]:
// ShowReturnAsDialog, if and only if ShowReturn is true,
// indicates to show the return values of the function in
// a dialog, instead of in a snackbar, as they are by default.
// If there are multiple return values from the function, or if
// one of them is a complex type (pointer, struct, slice,
// array, map), then ShowReturnAsDialog will
// automatically be set to true.
func (t *FuncButton) SetShowReturnAsDialog(v bool) *FuncButton {
	t.ShowReturnAsDialog = v
	return t
}

// SetTooltip sets the [FuncButton.Tooltip]
func (t *FuncButton) SetTooltip(v string) *FuncButton {
	t.Tooltip = v
	return t
}

// SetClass sets the [FuncButton.Class]
func (t *FuncButton) SetClass(v string) *FuncButton {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [FuncButton.CustomContextMenu]
func (t *FuncButton) SetCustomContextMenu(v func(m *gi.Scene)) *FuncButton {
	t.CustomContextMenu = v
	return t
}

// SetType sets the [FuncButton.Type]
func (t *FuncButton) SetType(v gi.ButtonTypes) *FuncButton {
	t.Type = v
	return t
}

// SetText sets the [FuncButton.Text]
func (t *FuncButton) SetText(v string) *FuncButton {
	t.Text = v
	return t
}

// SetIcon sets the [FuncButton.Icon]
func (t *FuncButton) SetIcon(v icons.Icon) *FuncButton {
	t.Icon = v
	return t
}

// SetIndicator sets the [FuncButton.Indicator]
func (t *FuncButton) SetIndicator(v icons.Icon) *FuncButton {
	t.Indicator = v
	return t
}

// SetShortcut sets the [FuncButton.Shortcut]
func (t *FuncButton) SetShortcut(v key.Chord) *FuncButton {
	t.Shortcut = v
	return t
}

// SetMenu sets the [FuncButton.Menu]
func (t *FuncButton) SetMenu(v func(m *gi.Scene)) *FuncButton {
	t.Menu = v
	return t
}

// SetData sets the [FuncButton.Data]
func (t *FuncButton) SetData(v any) *FuncButton {
	t.Data = v
	return t
}

// SetUpdateFunc sets the [FuncButton.UpdateFunc]
func (t *FuncButton) SetUpdateFunc(v func()) *FuncButton {
	t.UpdateFunc = v
	return t
}

// GiEditorType is the [gti.Type] for [GiEditor]
var GiEditorType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.GiEditor",
	ShortName:  "giv.GiEditor",
	IDName:     "gi-editor",
	Doc:        "GiEditor represents a struct, creating a property editor of the fields --\nconstructs Children widgets to show the field names and editor fields for\neach field, within an overall frame with an optional title, and a button\nbox at the bottom where methods can be invoked",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"KiRoot", &gti.Field{Name: "KiRoot", Type: "goki.dev/ki/v2.Ki", LocalType: "ki.Ki", Doc: "root of tree being edited", Directives: gti.Directives{}, Tag: ""}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", LocalType: "bool", Doc: "has the root changed via gui actions?  updated from treeview and structview for changes", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Filename", &gti.Field{Name: "Filename", Type: "goki.dev/gi/v2/gi.FileName", LocalType: "gi.FileName", Doc: "current filename for saving / loading", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "goki.dev/gi/v2/gi.Frame", LocalType: "gi.Frame", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{
		{"Update", &gti.Method{Name: "Update", Doc: "Update updates the objects being edited (e.g., updating display changes)", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"Save", &gti.Method{Name: "Save", Doc: "Save saves tree to current filename, in a standard JSON-formatted file", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"SaveAs", &gti.Method{Name: "SaveAs", Doc: "SaveAs saves tree to given filename, in a standard JSON-formatted file", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"filename", &gti.Field{Name: "filename", Type: "goki.dev/gi/v2/gi.FileName", LocalType: "gi.FileName", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"Open", &gti.Method{Name: "Open", Doc: "Open opens tree from given filename, in a standard JSON-formatted file", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"filename", &gti.Field{Name: "filename", Type: "goki.dev/gi/v2/gi.FileName", LocalType: "gi.FileName", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"EditColorScheme", &gti.Method{Name: "EditColorScheme", Doc: "EditColorScheme pulls up a window to edit the current color scheme", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"ToggleSelectionMode", &gti.Method{Name: "ToggleSelectionMode", Doc: "ToggleSelectionMode toggles the editor between selection mode or not", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
	}),
	Instance: &GiEditor{},
})

// NewGiEditor adds a new [GiEditor] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewGiEditor(par ki.Ki, name ...string) *GiEditor {
	return par.NewChild(GiEditorType, name...).(*GiEditor)
}

// KiType returns the [*gti.Type] of [GiEditor]
func (t *GiEditor) KiType() *gti.Type {
	return GiEditorType
}

// New returns a new [*GiEditor] value
func (t *GiEditor) New() ki.Ki {
	return &GiEditor{}
}

// SetKiRoot sets the [GiEditor.KiRoot]:
// root of tree being edited
func (t *GiEditor) SetKiRoot(v ki.Ki) *GiEditor {
	t.KiRoot = v
	return t
}

// SetFilename sets the [GiEditor.Filename]:
// current filename for saving / loading
func (t *GiEditor) SetFilename(v gi.FileName) *GiEditor {
	t.Filename = v
	return t
}

// SetTooltip sets the [GiEditor.Tooltip]
func (t *GiEditor) SetTooltip(v string) *GiEditor {
	t.Tooltip = v
	return t
}

// SetClass sets the [GiEditor.Class]
func (t *GiEditor) SetClass(v string) *GiEditor {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [GiEditor.CustomContextMenu]
func (t *GiEditor) SetCustomContextMenu(v func(m *gi.Scene)) *GiEditor {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [GiEditor.Lay]
func (t *GiEditor) SetLayout(v gi.Layouts) *GiEditor {
	t.Lay = v
	return t
}

// SetSpacing sets the [GiEditor.Spacing]
func (t *GiEditor) SetSpacing(v units.Value) *GiEditor {
	t.Spacing = v
	return t
}

// SetStackTop sets the [GiEditor.StackTop]
func (t *GiEditor) SetStackTop(v int) *GiEditor {
	t.StackTop = v
	return t
}

// SetStripes sets the [GiEditor.Stripes]
func (t *GiEditor) SetStripes(v gi.Stripes) *GiEditor {
	t.Stripes = v
	return t
}

// KeyChordEditType is the [gti.Type] for [KeyChordEdit]
var KeyChordEditType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.KeyChordEdit",
	ShortName:  "giv.KeyChordEdit",
	IDName:     "key-chord-edit",
	Doc:        "KeyChordEdit is a label widget that shows a key chord string, and, when in\nfocus (after being clicked) will update to whatever key chord is typed --\nused for representing and editing key chords.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"FocusActive", &gti.Field{Name: "FocusActive", Type: "bool", LocalType: "bool", Doc: "true if the keyboard focus is active or not -- when we lose active focus we apply changes", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Label", &gti.Field{Name: "Label", Type: "goki.dev/gi/v2/gi.Label", LocalType: "gi.Label", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &KeyChordEdit{},
})

// NewKeyChordEdit adds a new [KeyChordEdit] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewKeyChordEdit(par ki.Ki, name ...string) *KeyChordEdit {
	return par.NewChild(KeyChordEditType, name...).(*KeyChordEdit)
}

// KiType returns the [*gti.Type] of [KeyChordEdit]
func (t *KeyChordEdit) KiType() *gti.Type {
	return KeyChordEditType
}

// New returns a new [*KeyChordEdit] value
func (t *KeyChordEdit) New() ki.Ki {
	return &KeyChordEdit{}
}

// SetFocusActive sets the [KeyChordEdit.FocusActive]:
// true if the keyboard focus is active or not -- when we lose active focus we apply changes
func (t *KeyChordEdit) SetFocusActive(v bool) *KeyChordEdit {
	t.FocusActive = v
	return t
}

// SetTooltip sets the [KeyChordEdit.Tooltip]
func (t *KeyChordEdit) SetTooltip(v string) *KeyChordEdit {
	t.Tooltip = v
	return t
}

// SetClass sets the [KeyChordEdit.Class]
func (t *KeyChordEdit) SetClass(v string) *KeyChordEdit {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [KeyChordEdit.CustomContextMenu]
func (t *KeyChordEdit) SetCustomContextMenu(v func(m *gi.Scene)) *KeyChordEdit {
	t.CustomContextMenu = v
	return t
}

// SetText sets the [KeyChordEdit.Text]
func (t *KeyChordEdit) SetText(v string) *KeyChordEdit {
	t.Text = v
	return t
}

// SetType sets the [KeyChordEdit.Type]
func (t *KeyChordEdit) SetType(v gi.LabelTypes) *KeyChordEdit {
	t.Type = v
	return t
}

// MapViewType is the [gti.Type] for [MapView]
var MapViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.MapView",
	ShortName:  "giv.MapView",
	IDName:     "map-view",
	Doc:        "MapView represents a map, creating a property editor of the values --\nconstructs Children widgets to show the key / value pairs, within an\noverall frame.\nAutomatically has a toolbar with Map Toolbar props if defined\nset prop toolbar = false to turn off",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Map", &gti.Field{Name: "Map", Type: "any", LocalType: "any", Doc: "the map that we are a view onto", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"MapValView", &gti.Field{Name: "MapValView", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "Value for the map itself, if this was created within value view framework -- otherwise nil", Directives: gti.Directives{}, Tag: ""}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", LocalType: "bool", Doc: "has the map been edited?", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Keys", &gti.Field{Name: "Keys", Type: "[]goki.dev/gi/v2/giv.Value", LocalType: "[]Value", Doc: "Value representations of the map keys", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"Values", &gti.Field{Name: "Values", Type: "[]goki.dev/gi/v2/giv.Value", LocalType: "[]Value", Doc: "Value representations of the map values", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"SortVals", &gti.Field{Name: "SortVals", Type: "bool", LocalType: "bool", Doc: "sort by values instead of keys", Directives: gti.Directives{}, Tag: ""}},
		{"ShowToolbar", &gti.Field{Name: "ShowToolbar", Type: "bool", LocalType: "bool", Doc: "whether to show the toolbar or not", Directives: gti.Directives{}, Tag: ""}},
		{"NCols", &gti.Field{Name: "NCols", Type: "int", LocalType: "int", Doc: "the number of columns in the map; do not set externally; generally only access internally", Directives: gti.Directives{}, Tag: ""}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", LocalType: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}, Tag: ""}},
		{"ToolbarMap", &gti.Field{Name: "ToolbarMap", Type: "any", LocalType: "any", Doc: "the map that we successfully set a toolbar for", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "goki.dev/gi/v2/gi.Frame", LocalType: "gi.Frame", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &MapView{},
})

// NewMapView adds a new [MapView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewMapView(par ki.Ki, name ...string) *MapView {
	return par.NewChild(MapViewType, name...).(*MapView)
}

// KiType returns the [*gti.Type] of [MapView]
func (t *MapView) KiType() *gti.Type {
	return MapViewType
}

// New returns a new [*MapView] value
func (t *MapView) New() ki.Ki {
	return &MapView{}
}

// SetMapValView sets the [MapView.MapValView]:
// Value for the map itself, if this was created within value view framework -- otherwise nil
func (t *MapView) SetMapValView(v Value) *MapView {
	t.MapValView = v
	return t
}

// SetKeys sets the [MapView.Keys]:
// Value representations of the map keys
func (t *MapView) SetKeys(v []Value) *MapView {
	t.Keys = v
	return t
}

// SetValues sets the [MapView.Values]:
// Value representations of the map values
func (t *MapView) SetValues(v []Value) *MapView {
	t.Values = v
	return t
}

// SetSortVals sets the [MapView.SortVals]:
// sort by values instead of keys
func (t *MapView) SetSortVals(v bool) *MapView {
	t.SortVals = v
	return t
}

// SetShowToolbar sets the [MapView.ShowToolbar]:
// whether to show the toolbar or not
func (t *MapView) SetShowToolbar(v bool) *MapView {
	t.ShowToolbar = v
	return t
}

// SetNcols sets the [MapView.NCols]:
// the number of columns in the map; do not set externally; generally only access internally
func (t *MapView) SetNcols(v int) *MapView {
	t.NCols = v
	return t
}

// SetTmpSave sets the [MapView.TmpSave]:
// value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent
func (t *MapView) SetTmpSave(v Value) *MapView {
	t.TmpSave = v
	return t
}

// SetViewPath sets the [MapView.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *MapView) SetViewPath(v string) *MapView {
	t.ViewPath = v
	return t
}

// SetToolbarMap sets the [MapView.ToolbarMap]:
// the map that we successfully set a toolbar for
func (t *MapView) SetToolbarMap(v any) *MapView {
	t.ToolbarMap = v
	return t
}

// SetTooltip sets the [MapView.Tooltip]
func (t *MapView) SetTooltip(v string) *MapView {
	t.Tooltip = v
	return t
}

// SetClass sets the [MapView.Class]
func (t *MapView) SetClass(v string) *MapView {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [MapView.CustomContextMenu]
func (t *MapView) SetCustomContextMenu(v func(m *gi.Scene)) *MapView {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [MapView.Lay]
func (t *MapView) SetLayout(v gi.Layouts) *MapView {
	t.Lay = v
	return t
}

// SetSpacing sets the [MapView.Spacing]
func (t *MapView) SetSpacing(v units.Value) *MapView {
	t.Spacing = v
	return t
}

// SetStackTop sets the [MapView.StackTop]
func (t *MapView) SetStackTop(v int) *MapView {
	t.StackTop = v
	return t
}

// SetStripes sets the [MapView.Stripes]
func (t *MapView) SetStripes(v gi.Stripes) *MapView {
	t.Stripes = v
	return t
}

// MapViewInlineType is the [gti.Type] for [MapViewInline]
var MapViewInlineType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.MapViewInline",
	ShortName:  "giv.MapViewInline",
	IDName:     "map-view-inline",
	Doc:        "MapViewInline represents a map as a single line widget,\nfor smaller maps and those explicitly marked inline.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Map", &gti.Field{Name: "Map", Type: "any", LocalType: "any", Doc: "the map that we are a view onto", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"MapValView", &gti.Field{Name: "MapValView", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "Value for the map itself, if this was created within value view framework -- otherwise nil", Directives: gti.Directives{}, Tag: ""}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", LocalType: "bool", Doc: "has the map been edited?", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Keys", &gti.Field{Name: "Keys", Type: "[]goki.dev/gi/v2/giv.Value", LocalType: "[]Value", Doc: "Value representations of the map keys", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"Values", &gti.Field{Name: "Values", Type: "[]goki.dev/gi/v2/giv.Value", LocalType: "[]Value", Doc: "Value representations of the fields", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}, Tag: "view:\"-\" json:\"-\" xml:\"-\""}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", LocalType: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "goki.dev/gi/v2/gi.Layout", LocalType: "gi.Layout", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &MapViewInline{},
})

// NewMapViewInline adds a new [MapViewInline] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewMapViewInline(par ki.Ki, name ...string) *MapViewInline {
	return par.NewChild(MapViewInlineType, name...).(*MapViewInline)
}

// KiType returns the [*gti.Type] of [MapViewInline]
func (t *MapViewInline) KiType() *gti.Type {
	return MapViewInlineType
}

// New returns a new [*MapViewInline] value
func (t *MapViewInline) New() ki.Ki {
	return &MapViewInline{}
}

// SetMapValView sets the [MapViewInline.MapValView]:
// Value for the map itself, if this was created within value view framework -- otherwise nil
func (t *MapViewInline) SetMapValView(v Value) *MapViewInline {
	t.MapValView = v
	return t
}

// SetKeys sets the [MapViewInline.Keys]:
// Value representations of the map keys
func (t *MapViewInline) SetKeys(v []Value) *MapViewInline {
	t.Keys = v
	return t
}

// SetValues sets the [MapViewInline.Values]:
// Value representations of the fields
func (t *MapViewInline) SetValues(v []Value) *MapViewInline {
	t.Values = v
	return t
}

// SetTmpSave sets the [MapViewInline.TmpSave]:
// value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent
func (t *MapViewInline) SetTmpSave(v Value) *MapViewInline {
	t.TmpSave = v
	return t
}

// SetViewPath sets the [MapViewInline.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *MapViewInline) SetViewPath(v string) *MapViewInline {
	t.ViewPath = v
	return t
}

// SetTooltip sets the [MapViewInline.Tooltip]
func (t *MapViewInline) SetTooltip(v string) *MapViewInline {
	t.Tooltip = v
	return t
}

// SetClass sets the [MapViewInline.Class]
func (t *MapViewInline) SetClass(v string) *MapViewInline {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [MapViewInline.CustomContextMenu]
func (t *MapViewInline) SetCustomContextMenu(v func(m *gi.Scene)) *MapViewInline {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [MapViewInline.Lay]
func (t *MapViewInline) SetLayout(v gi.Layouts) *MapViewInline {
	t.Lay = v
	return t
}

// SetSpacing sets the [MapViewInline.Spacing]
func (t *MapViewInline) SetSpacing(v units.Value) *MapViewInline {
	t.Spacing = v
	return t
}

// SetStackTop sets the [MapViewInline.StackTop]
func (t *MapViewInline) SetStackTop(v int) *MapViewInline {
	t.StackTop = v
	return t
}

// SliceViewType is the [gti.Type] for [SliceView]
var SliceViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.SliceView",
	ShortName:  "giv.SliceView",
	IDName:     "slice-view",
	Doc:        "SliceView represents a slice, creating an interactive viewer / editor of the\nelements as rows in a table.  Widgets to show the index / value pairs, within an\noverall frame.\nSet to ReadOnly for select-only mode, which emits WidgetSig WidgetSelected\nsignals when selection is updated.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"StyleFunc", &gti.Field{Name: "StyleFunc", Type: "goki.dev/gi/v2/giv.SliceViewStyleFunc", LocalType: "SliceViewStyleFunc", Doc: "optional styling function", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SliceViewBase", &gti.Field{Name: "SliceViewBase", Type: "goki.dev/gi/v2/giv.SliceViewBase", LocalType: "SliceViewBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SliceView{},
})

// NewSliceView adds a new [SliceView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSliceView(par ki.Ki, name ...string) *SliceView {
	return par.NewChild(SliceViewType, name...).(*SliceView)
}

// KiType returns the [*gti.Type] of [SliceView]
func (t *SliceView) KiType() *gti.Type {
	return SliceViewType
}

// New returns a new [*SliceView] value
func (t *SliceView) New() ki.Ki {
	return &SliceView{}
}

// SetStyleFunc sets the [SliceView.StyleFunc]:
// optional styling function
func (t *SliceView) SetStyleFunc(v SliceViewStyleFunc) *SliceView {
	t.StyleFunc = v
	return t
}

// SetTooltip sets the [SliceView.Tooltip]
func (t *SliceView) SetTooltip(v string) *SliceView {
	t.Tooltip = v
	return t
}

// SetClass sets the [SliceView.Class]
func (t *SliceView) SetClass(v string) *SliceView {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [SliceView.CustomContextMenu]
func (t *SliceView) SetCustomContextMenu(v func(m *gi.Scene)) *SliceView {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [SliceView.Lay]
func (t *SliceView) SetLayout(v gi.Layouts) *SliceView {
	t.Lay = v
	return t
}

// SetSpacing sets the [SliceView.Spacing]
func (t *SliceView) SetSpacing(v units.Value) *SliceView {
	t.Spacing = v
	return t
}

// SetStackTop sets the [SliceView.StackTop]
func (t *SliceView) SetStackTop(v int) *SliceView {
	t.StackTop = v
	return t
}

// SetStripes sets the [SliceView.Stripes]
func (t *SliceView) SetStripes(v gi.Stripes) *SliceView {
	t.Stripes = v
	return t
}

// SetViewMu sets the [SliceView.ViewMu]
func (t *SliceView) SetViewMu(v *sync.Mutex) *SliceView {
	t.ViewMu = v
	return t
}

// SetSliceNpval sets the [SliceView.SliceNPVal]
func (t *SliceView) SetSliceNpval(v reflect.Value) *SliceView {
	t.SliceNPVal = v
	return t
}

// SetSliceValView sets the [SliceView.SliceValView]
func (t *SliceView) SetSliceValView(v Value) *SliceView {
	t.SliceValView = v
	return t
}

// SetValues sets the [SliceView.Values]
func (t *SliceView) SetValues(v []Value) *SliceView {
	t.Values = v
	return t
}

// SetSelVal sets the [SliceView.SelVal]
func (t *SliceView) SetSelVal(v any) *SliceView {
	t.SelVal = v
	return t
}

// SetSelIdx sets the [SliceView.SelIdx]
func (t *SliceView) SetSelIdx(v int) *SliceView {
	t.SelIdx = v
	return t
}

// SetSelIdxs sets the [SliceView.SelIdxs]
func (t *SliceView) SetSelIdxs(v map[int]struct{}) *SliceView {
	t.SelIdxs = v
	return t
}

// SetDraggedIdxs sets the [SliceView.DraggedIdxs]
func (t *SliceView) SetDraggedIdxs(v []int) *SliceView {
	t.DraggedIdxs = v
	return t
}

// SetViewPath sets the [SliceView.ViewPath]
func (t *SliceView) SetViewPath(v string) *SliceView {
	t.ViewPath = v
	return t
}

// SetTmpSave sets the [SliceView.TmpSave]
func (t *SliceView) SetTmpSave(v Value) *SliceView {
	t.TmpSave = v
	return t
}

// SetToolbarSlice sets the [SliceView.ToolbarSlice]
func (t *SliceView) SetToolbarSlice(v any) *SliceView {
	t.ToolbarSlice = v
	return t
}

// SetRowHeight sets the [SliceView.RowHeight]
func (t *SliceView) SetRowHeight(v float32) *SliceView {
	t.RowHeight = v
	return t
}

// SetLayoutHeight sets the [SliceView.LayoutHeight]
func (t *SliceView) SetLayoutHeight(v float32) *SliceView {
	t.LayoutHeight = v
	return t
}

// SetVisRows sets the [SliceView.VisRows]
func (t *SliceView) SetVisRows(v int) *SliceView {
	t.VisRows = v
	return t
}

// SetStartIdx sets the [SliceView.StartIdx]
func (t *SliceView) SetStartIdx(v int) *SliceView {
	t.StartIdx = v
	return t
}

// SetRenderedRows sets the [SliceView.RenderedRows]
func (t *SliceView) SetRenderedRows(v int) *SliceView {
	t.RenderedRows = v
	return t
}

// SetSliceSize sets the [SliceView.SliceSize]
func (t *SliceView) SetSliceSize(v int) *SliceView {
	t.SliceSize = v
	return t
}

// SetCurIdx sets the [SliceView.CurIdx]
func (t *SliceView) SetCurIdx(v int) *SliceView {
	t.CurIdx = v
	return t
}

// SetElVal sets the [SliceView.ElVal]
func (t *SliceView) SetElVal(v reflect.Value) *SliceView {
	t.ElVal = v
	return t
}

// SliceViewBaseType is the [gti.Type] for [SliceViewBase]
var SliceViewBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.SliceViewBase",
	ShortName:  "giv.SliceViewBase",
	IDName:     "slice-view-base",
	Doc:        "SliceViewBase is the base for SliceView and TableView and any other viewers\nof array-like data.  It automatically computes the number of rows that fit\nwithin its allocated space, and manages the offset view window into the full\nlist of items, and supports row selection, copy / paste, Drag-n-Drop, etc.\nSet to ReadOnly for select-only mode, which emits WidgetSig WidgetSelected\nsignals when selection is updated.\nAutomatically has a toolbar with Slice Toolbar props if defined\nset prop toolbar = false to turn off",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Slice", &gti.Field{Name: "Slice", Type: "any", LocalType: "any", Doc: "the slice that we are a view onto -- must be a pointer to that slice", Directives: gti.Directives{}, Tag: "set:\"-\" copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"ViewMu", &gti.Field{Name: "ViewMu", Type: "*sync.Mutex", LocalType: "*sync.Mutex", Doc: "optional mutex that, if non-nil, will be used around any updates that read / modify the underlying Slice data -- can be used to protect against random updating if your code has specific update points that can be likewise protected with this same mutex", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", LocalType: "bool", Doc: "Changed indicates whether the underlying slice\nhas been edited in any way", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"SliceNPVal", &gti.Field{Name: "SliceNPVal", Type: "reflect.Value", LocalType: "reflect.Value", Doc: "non-ptr reflect.Value of the slice", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"SliceValView", &gti.Field{Name: "SliceValView", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "Value for the slice itself, if this was created within value view framework -- otherwise nil", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"Values", &gti.Field{Name: "Values", Type: "[]goki.dev/gi/v2/giv.Value", LocalType: "[]Value", Doc: "Value representations of the slice values", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"SelVal", &gti.Field{Name: "SelVal", Type: "any", LocalType: "any", Doc: "current selection value -- initially select this value if set", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"SelIdx", &gti.Field{Name: "SelIdx", Type: "int", LocalType: "int", Doc: "index of currently-selected item, in ReadOnly mode only", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\""}},
		{"SelIdxs", &gti.Field{Name: "SelIdxs", Type: "map[int]struct{}", LocalType: "map[int]struct{}", Doc: "list of currently-selected slice indexes", Directives: gti.Directives{}, Tag: "copy:\"-\""}},
		{"DraggedIdxs", &gti.Field{Name: "DraggedIdxs", Type: "[]int", LocalType: "[]int", Doc: "list of currently-dragged indexes", Directives: gti.Directives{}, Tag: "copy:\"-\""}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", LocalType: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}, Tag: ""}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\""}},
		{"ToolbarSlice", &gti.Field{Name: "ToolbarSlice", Type: "any", LocalType: "any", Doc: "the slice that we successfully set a toolbar for", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"RowHeight", &gti.Field{Name: "RowHeight", Type: "float32", LocalType: "float32", Doc: "height of a single row", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\""}},
		{"LayoutHeight", &gti.Field{Name: "LayoutHeight", Type: "float32", LocalType: "float32", Doc: "the height of grid from last layout -- determines when update needed", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"VisRows", &gti.Field{Name: "VisRows", Type: "int", LocalType: "int", Doc: "total number of rows visible in allocated display size", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\""}},
		{"StartIdx", &gti.Field{Name: "StartIdx", Type: "int", LocalType: "int", Doc: "starting slice index of visible rows", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\""}},
		{"RenderedRows", &gti.Field{Name: "RenderedRows", Type: "int", LocalType: "int", Doc: "the number of rows rendered -- determines update", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"SliceSize", &gti.Field{Name: "SliceSize", Type: "int", LocalType: "int", Doc: "size of slice", Directives: gti.Directives{}, Tag: "edit:\"-\" copy:\"-\" json:\"-\" xml:\"-\""}},
		{"CurIdx", &gti.Field{Name: "CurIdx", Type: "int", LocalType: "int", Doc: "temp idx state for e.g., dnd", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"ElVal", &gti.Field{Name: "ElVal", Type: "reflect.Value", LocalType: "reflect.Value", Doc: "ElVal is a Value representation of the underlying element type\nwhich is used whenever there are no slice elements available", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "goki.dev/gi/v2/gi.Frame", LocalType: "gi.Frame", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SliceViewBase{},
})

// NewSliceViewBase adds a new [SliceViewBase] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSliceViewBase(par ki.Ki, name ...string) *SliceViewBase {
	return par.NewChild(SliceViewBaseType, name...).(*SliceViewBase)
}

// KiType returns the [*gti.Type] of [SliceViewBase]
func (t *SliceViewBase) KiType() *gti.Type {
	return SliceViewBaseType
}

// New returns a new [*SliceViewBase] value
func (t *SliceViewBase) New() ki.Ki {
	return &SliceViewBase{}
}

// SetViewMu sets the [SliceViewBase.ViewMu]:
// optional mutex that, if non-nil, will be used around any updates that read / modify the underlying Slice data -- can be used to protect against random updating if your code has specific update points that can be likewise protected with this same mutex
func (t *SliceViewBase) SetViewMu(v *sync.Mutex) *SliceViewBase {
	t.ViewMu = v
	return t
}

// SetSliceNpval sets the [SliceViewBase.SliceNPVal]:
// non-ptr reflect.Value of the slice
func (t *SliceViewBase) SetSliceNpval(v reflect.Value) *SliceViewBase {
	t.SliceNPVal = v
	return t
}

// SetSliceValView sets the [SliceViewBase.SliceValView]:
// Value for the slice itself, if this was created within value view framework -- otherwise nil
func (t *SliceViewBase) SetSliceValView(v Value) *SliceViewBase {
	t.SliceValView = v
	return t
}

// SetValues sets the [SliceViewBase.Values]:
// Value representations of the slice values
func (t *SliceViewBase) SetValues(v []Value) *SliceViewBase {
	t.Values = v
	return t
}

// SetSelVal sets the [SliceViewBase.SelVal]:
// current selection value -- initially select this value if set
func (t *SliceViewBase) SetSelVal(v any) *SliceViewBase {
	t.SelVal = v
	return t
}

// SetSelIdx sets the [SliceViewBase.SelIdx]:
// index of currently-selected item, in ReadOnly mode only
func (t *SliceViewBase) SetSelIdx(v int) *SliceViewBase {
	t.SelIdx = v
	return t
}

// SetSelIdxs sets the [SliceViewBase.SelIdxs]:
// list of currently-selected slice indexes
func (t *SliceViewBase) SetSelIdxs(v map[int]struct{}) *SliceViewBase {
	t.SelIdxs = v
	return t
}

// SetDraggedIdxs sets the [SliceViewBase.DraggedIdxs]:
// list of currently-dragged indexes
func (t *SliceViewBase) SetDraggedIdxs(v []int) *SliceViewBase {
	t.DraggedIdxs = v
	return t
}

// SetViewPath sets the [SliceViewBase.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *SliceViewBase) SetViewPath(v string) *SliceViewBase {
	t.ViewPath = v
	return t
}

// SetTmpSave sets the [SliceViewBase.TmpSave]:
// value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent
func (t *SliceViewBase) SetTmpSave(v Value) *SliceViewBase {
	t.TmpSave = v
	return t
}

// SetToolbarSlice sets the [SliceViewBase.ToolbarSlice]:
// the slice that we successfully set a toolbar for
func (t *SliceViewBase) SetToolbarSlice(v any) *SliceViewBase {
	t.ToolbarSlice = v
	return t
}

// SetRowHeight sets the [SliceViewBase.RowHeight]:
// height of a single row
func (t *SliceViewBase) SetRowHeight(v float32) *SliceViewBase {
	t.RowHeight = v
	return t
}

// SetLayoutHeight sets the [SliceViewBase.LayoutHeight]:
// the height of grid from last layout -- determines when update needed
func (t *SliceViewBase) SetLayoutHeight(v float32) *SliceViewBase {
	t.LayoutHeight = v
	return t
}

// SetVisRows sets the [SliceViewBase.VisRows]:
// total number of rows visible in allocated display size
func (t *SliceViewBase) SetVisRows(v int) *SliceViewBase {
	t.VisRows = v
	return t
}

// SetStartIdx sets the [SliceViewBase.StartIdx]:
// starting slice index of visible rows
func (t *SliceViewBase) SetStartIdx(v int) *SliceViewBase {
	t.StartIdx = v
	return t
}

// SetRenderedRows sets the [SliceViewBase.RenderedRows]:
// the number of rows rendered -- determines update
func (t *SliceViewBase) SetRenderedRows(v int) *SliceViewBase {
	t.RenderedRows = v
	return t
}

// SetSliceSize sets the [SliceViewBase.SliceSize]:
// size of slice
func (t *SliceViewBase) SetSliceSize(v int) *SliceViewBase {
	t.SliceSize = v
	return t
}

// SetCurIdx sets the [SliceViewBase.CurIdx]:
// temp idx state for e.g., dnd
func (t *SliceViewBase) SetCurIdx(v int) *SliceViewBase {
	t.CurIdx = v
	return t
}

// SetElVal sets the [SliceViewBase.ElVal]:
// ElVal is a Value representation of the underlying element type
// which is used whenever there are no slice elements available
func (t *SliceViewBase) SetElVal(v reflect.Value) *SliceViewBase {
	t.ElVal = v
	return t
}

// SetTooltip sets the [SliceViewBase.Tooltip]
func (t *SliceViewBase) SetTooltip(v string) *SliceViewBase {
	t.Tooltip = v
	return t
}

// SetClass sets the [SliceViewBase.Class]
func (t *SliceViewBase) SetClass(v string) *SliceViewBase {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [SliceViewBase.CustomContextMenu]
func (t *SliceViewBase) SetCustomContextMenu(v func(m *gi.Scene)) *SliceViewBase {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [SliceViewBase.Lay]
func (t *SliceViewBase) SetLayout(v gi.Layouts) *SliceViewBase {
	t.Lay = v
	return t
}

// SetSpacing sets the [SliceViewBase.Spacing]
func (t *SliceViewBase) SetSpacing(v units.Value) *SliceViewBase {
	t.Spacing = v
	return t
}

// SetStackTop sets the [SliceViewBase.StackTop]
func (t *SliceViewBase) SetStackTop(v int) *SliceViewBase {
	t.StackTop = v
	return t
}

// SetStripes sets the [SliceViewBase.Stripes]
func (t *SliceViewBase) SetStripes(v gi.Stripes) *SliceViewBase {
	t.Stripes = v
	return t
}

// SliceViewInlineType is the [gti.Type] for [SliceViewInline]
var SliceViewInlineType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.SliceViewInline",
	ShortName:  "giv.SliceViewInline",
	IDName:     "slice-view-inline",
	Doc:        "SliceViewInline represents a slice as a single line widget,\nfor smaller slices and those explicitly marked inline.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Slice", &gti.Field{Name: "Slice", Type: "any", LocalType: "any", Doc: "the slice that we are a view onto", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"SliceValView", &gti.Field{Name: "SliceValView", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "Value for the slice itself, if this was created within value view framework -- otherwise nil", Directives: gti.Directives{}, Tag: ""}},
		{"IsArray", &gti.Field{Name: "IsArray", Type: "bool", LocalType: "bool", Doc: "whether the slice is actually an array -- no modifications", Directives: gti.Directives{}, Tag: ""}},
		{"IsFixedLen", &gti.Field{Name: "IsFixedLen", Type: "bool", LocalType: "bool", Doc: "whether the slice has a fixed-len flag on it", Directives: gti.Directives{}, Tag: ""}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", LocalType: "bool", Doc: "has the slice been edited?", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Values", &gti.Field{Name: "Values", Type: "[]goki.dev/gi/v2/giv.Value", LocalType: "[]Value", Doc: "Value representations of the fields", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}, Tag: "view:\"-\" json:\"-\" xml:\"-\""}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", LocalType: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "goki.dev/gi/v2/gi.Layout", LocalType: "gi.Layout", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SliceViewInline{},
})

// NewSliceViewInline adds a new [SliceViewInline] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSliceViewInline(par ki.Ki, name ...string) *SliceViewInline {
	return par.NewChild(SliceViewInlineType, name...).(*SliceViewInline)
}

// KiType returns the [*gti.Type] of [SliceViewInline]
func (t *SliceViewInline) KiType() *gti.Type {
	return SliceViewInlineType
}

// New returns a new [*SliceViewInline] value
func (t *SliceViewInline) New() ki.Ki {
	return &SliceViewInline{}
}

// SetSliceValView sets the [SliceViewInline.SliceValView]:
// Value for the slice itself, if this was created within value view framework -- otherwise nil
func (t *SliceViewInline) SetSliceValView(v Value) *SliceViewInline {
	t.SliceValView = v
	return t
}

// SetIsArray sets the [SliceViewInline.IsArray]:
// whether the slice is actually an array -- no modifications
func (t *SliceViewInline) SetIsArray(v bool) *SliceViewInline {
	t.IsArray = v
	return t
}

// SetIsFixedLen sets the [SliceViewInline.IsFixedLen]:
// whether the slice has a fixed-len flag on it
func (t *SliceViewInline) SetIsFixedLen(v bool) *SliceViewInline {
	t.IsFixedLen = v
	return t
}

// SetValues sets the [SliceViewInline.Values]:
// Value representations of the fields
func (t *SliceViewInline) SetValues(v []Value) *SliceViewInline {
	t.Values = v
	return t
}

// SetTmpSave sets the [SliceViewInline.TmpSave]:
// value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent
func (t *SliceViewInline) SetTmpSave(v Value) *SliceViewInline {
	t.TmpSave = v
	return t
}

// SetViewPath sets the [SliceViewInline.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *SliceViewInline) SetViewPath(v string) *SliceViewInline {
	t.ViewPath = v
	return t
}

// SetTooltip sets the [SliceViewInline.Tooltip]
func (t *SliceViewInline) SetTooltip(v string) *SliceViewInline {
	t.Tooltip = v
	return t
}

// SetClass sets the [SliceViewInline.Class]
func (t *SliceViewInline) SetClass(v string) *SliceViewInline {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [SliceViewInline.CustomContextMenu]
func (t *SliceViewInline) SetCustomContextMenu(v func(m *gi.Scene)) *SliceViewInline {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [SliceViewInline.Lay]
func (t *SliceViewInline) SetLayout(v gi.Layouts) *SliceViewInline {
	t.Lay = v
	return t
}

// SetSpacing sets the [SliceViewInline.Spacing]
func (t *SliceViewInline) SetSpacing(v units.Value) *SliceViewInline {
	t.Spacing = v
	return t
}

// SetStackTop sets the [SliceViewInline.StackTop]
func (t *SliceViewInline) SetStackTop(v int) *SliceViewInline {
	t.StackTop = v
	return t
}

// StructViewType is the [gti.Type] for [StructView]
var StructViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.StructView",
	ShortName:  "giv.StructView",
	IDName:     "struct-view",
	Doc:        "StructView represents a struct, creating a property editor of the fields --\nconstructs Children widgets to show the field names and editor fields for\neach field, within an overall frame.\nAutomatically has a toolbar with Struct Toolbar props if defined\nset prop toolbar = false to turn off",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Struct", &gti.Field{Name: "Struct", Type: "any", LocalType: "any", Doc: "the struct that we are a view onto", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"StructValView", &gti.Field{Name: "StructValView", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "Value for the struct itself, if this was created within value view framework -- otherwise nil", Directives: gti.Directives{}, Tag: ""}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", LocalType: "bool", Doc: "has the value of any field changed?  updated by the ViewSig signals from fields", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"ChangeFlag", &gti.Field{Name: "ChangeFlag", Type: "*reflect.Value", LocalType: "*reflect.Value", Doc: "Value for a field marked with changeflag struct tag, which must be a bool type, which is updated when changes are registered in field values.", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"FieldViews", &gti.Field{Name: "FieldViews", Type: "[]goki.dev/gi/v2/giv.Value", LocalType: "[]Value", Doc: "Value representations of the fields", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"ShowToolbar", &gti.Field{Name: "ShowToolbar", Type: "bool", LocalType: "bool", Doc: "whether to show the toolbar or not", Directives: gti.Directives{}, Tag: ""}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", LocalType: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}, Tag: ""}},
		{"ToolbarStru", &gti.Field{Name: "ToolbarStru", Type: "any", LocalType: "any", Doc: "the struct that we successfully set a toolbar for", Directives: gti.Directives{}, Tag: ""}},
		{"HasDefs", &gti.Field{Name: "HasDefs", Type: "bool", LocalType: "bool", Doc: "if true, some fields have default values -- update labels when values change", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" edit:\"-\""}},
		{"HasViewIfs", &gti.Field{Name: "HasViewIfs", Type: "bool", LocalType: "bool", Doc: "if true, some fields have viewif conditional view tags -- update after..", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" edit:\"-\""}},
		{"TypeFieldTags", &gti.Field{Name: "TypeFieldTags", Type: "map[string]string", LocalType: "map[string]string", Doc: "extra tags by field name -- from type properties", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" edit:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "goki.dev/gi/v2/gi.Frame", LocalType: "gi.Frame", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &StructView{},
})

// NewStructView adds a new [StructView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewStructView(par ki.Ki, name ...string) *StructView {
	return par.NewChild(StructViewType, name...).(*StructView)
}

// KiType returns the [*gti.Type] of [StructView]
func (t *StructView) KiType() *gti.Type {
	return StructViewType
}

// New returns a new [*StructView] value
func (t *StructView) New() ki.Ki {
	return &StructView{}
}

// SetStructValView sets the [StructView.StructValView]:
// Value for the struct itself, if this was created within value view framework -- otherwise nil
func (t *StructView) SetStructValView(v Value) *StructView {
	t.StructValView = v
	return t
}

// SetChangeFlag sets the [StructView.ChangeFlag]:
// Value for a field marked with changeflag struct tag, which must be a bool type, which is updated when changes are registered in field values.
func (t *StructView) SetChangeFlag(v *reflect.Value) *StructView {
	t.ChangeFlag = v
	return t
}

// SetFieldViews sets the [StructView.FieldViews]:
// Value representations of the fields
func (t *StructView) SetFieldViews(v []Value) *StructView {
	t.FieldViews = v
	return t
}

// SetShowToolbar sets the [StructView.ShowToolbar]:
// whether to show the toolbar or not
func (t *StructView) SetShowToolbar(v bool) *StructView {
	t.ShowToolbar = v
	return t
}

// SetTmpSave sets the [StructView.TmpSave]:
// value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent
func (t *StructView) SetTmpSave(v Value) *StructView {
	t.TmpSave = v
	return t
}

// SetViewPath sets the [StructView.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *StructView) SetViewPath(v string) *StructView {
	t.ViewPath = v
	return t
}

// SetToolbarStru sets the [StructView.ToolbarStru]:
// the struct that we successfully set a toolbar for
func (t *StructView) SetToolbarStru(v any) *StructView {
	t.ToolbarStru = v
	return t
}

// SetHasDefs sets the [StructView.HasDefs]:
// if true, some fields have default values -- update labels when values change
func (t *StructView) SetHasDefs(v bool) *StructView {
	t.HasDefs = v
	return t
}

// SetHasViewIfs sets the [StructView.HasViewIfs]:
// if true, some fields have viewif conditional view tags -- update after..
func (t *StructView) SetHasViewIfs(v bool) *StructView {
	t.HasViewIfs = v
	return t
}

// SetTypeFieldTags sets the [StructView.TypeFieldTags]:
// extra tags by field name -- from type properties
func (t *StructView) SetTypeFieldTags(v map[string]string) *StructView {
	t.TypeFieldTags = v
	return t
}

// SetTooltip sets the [StructView.Tooltip]
func (t *StructView) SetTooltip(v string) *StructView {
	t.Tooltip = v
	return t
}

// SetClass sets the [StructView.Class]
func (t *StructView) SetClass(v string) *StructView {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [StructView.CustomContextMenu]
func (t *StructView) SetCustomContextMenu(v func(m *gi.Scene)) *StructView {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [StructView.Lay]
func (t *StructView) SetLayout(v gi.Layouts) *StructView {
	t.Lay = v
	return t
}

// SetSpacing sets the [StructView.Spacing]
func (t *StructView) SetSpacing(v units.Value) *StructView {
	t.Spacing = v
	return t
}

// SetStackTop sets the [StructView.StackTop]
func (t *StructView) SetStackTop(v int) *StructView {
	t.StackTop = v
	return t
}

// SetStripes sets the [StructView.Stripes]
func (t *StructView) SetStripes(v gi.Stripes) *StructView {
	t.Stripes = v
	return t
}

// StructViewInlineType is the [gti.Type] for [StructViewInline]
var StructViewInlineType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.StructViewInline",
	ShortName:  "giv.StructViewInline",
	IDName:     "struct-view-inline",
	Doc:        "StructViewInline represents a struct as a single line widget,\nfor smaller structs and those explicitly marked inline.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Struct", &gti.Field{Name: "Struct", Type: "any", LocalType: "any", Doc: "the struct that we are a view onto", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"StructValView", &gti.Field{Name: "StructValView", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "Value for the struct itself, if this was created within value view framework -- otherwise nil", Directives: gti.Directives{}, Tag: ""}},
		{"AddButton", &gti.Field{Name: "AddButton", Type: "bool", LocalType: "bool", Doc: "if true add an edit action button at the end -- other users of this widget can then configure that -- it is called 'edit-action'", Directives: gti.Directives{}, Tag: ""}},
		{"FieldViews", &gti.Field{Name: "FieldViews", Type: "[]goki.dev/gi/v2/giv.Value", LocalType: "[]Value", Doc: "Value representations of the fields", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\""}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "goki.dev/gi/v2/giv.Value", LocalType: "Value", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" view:\"-\""}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", LocalType: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}, Tag: ""}},
		{"HasDefs", &gti.Field{Name: "HasDefs", Type: "bool", LocalType: "bool", Doc: "if true, some fields have default values -- update labels when values change", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" edit:\"-\""}},
		{"HasViewIfs", &gti.Field{Name: "HasViewIfs", Type: "bool", LocalType: "bool", Doc: "if true, some fields have viewif conditional view tags -- update after..", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" edit:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "goki.dev/gi/v2/gi.Frame", LocalType: "gi.Frame", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &StructViewInline{},
})

// NewStructViewInline adds a new [StructViewInline] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewStructViewInline(par ki.Ki, name ...string) *StructViewInline {
	return par.NewChild(StructViewInlineType, name...).(*StructViewInline)
}

// KiType returns the [*gti.Type] of [StructViewInline]
func (t *StructViewInline) KiType() *gti.Type {
	return StructViewInlineType
}

// New returns a new [*StructViewInline] value
func (t *StructViewInline) New() ki.Ki {
	return &StructViewInline{}
}

// SetStructValView sets the [StructViewInline.StructValView]:
// Value for the struct itself, if this was created within value view framework -- otherwise nil
func (t *StructViewInline) SetStructValView(v Value) *StructViewInline {
	t.StructValView = v
	return t
}

// SetAddButton sets the [StructViewInline.AddButton]:
// if true add an edit action button at the end -- other users of this widget can then configure that -- it is called 'edit-action'
func (t *StructViewInline) SetAddButton(v bool) *StructViewInline {
	t.AddButton = v
	return t
}

// SetFieldViews sets the [StructViewInline.FieldViews]:
// Value representations of the fields
func (t *StructViewInline) SetFieldViews(v []Value) *StructViewInline {
	t.FieldViews = v
	return t
}

// SetTmpSave sets the [StructViewInline.TmpSave]:
// value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent
func (t *StructViewInline) SetTmpSave(v Value) *StructViewInline {
	t.TmpSave = v
	return t
}

// SetViewPath sets the [StructViewInline.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *StructViewInline) SetViewPath(v string) *StructViewInline {
	t.ViewPath = v
	return t
}

// SetHasDefs sets the [StructViewInline.HasDefs]:
// if true, some fields have default values -- update labels when values change
func (t *StructViewInline) SetHasDefs(v bool) *StructViewInline {
	t.HasDefs = v
	return t
}

// SetHasViewIfs sets the [StructViewInline.HasViewIfs]:
// if true, some fields have viewif conditional view tags -- update after..
func (t *StructViewInline) SetHasViewIfs(v bool) *StructViewInline {
	t.HasViewIfs = v
	return t
}

// SetTooltip sets the [StructViewInline.Tooltip]
func (t *StructViewInline) SetTooltip(v string) *StructViewInline {
	t.Tooltip = v
	return t
}

// SetClass sets the [StructViewInline.Class]
func (t *StructViewInline) SetClass(v string) *StructViewInline {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [StructViewInline.CustomContextMenu]
func (t *StructViewInline) SetCustomContextMenu(v func(m *gi.Scene)) *StructViewInline {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [StructViewInline.Lay]
func (t *StructViewInline) SetLayout(v gi.Layouts) *StructViewInline {
	t.Lay = v
	return t
}

// SetSpacing sets the [StructViewInline.Spacing]
func (t *StructViewInline) SetSpacing(v units.Value) *StructViewInline {
	t.Spacing = v
	return t
}

// SetStackTop sets the [StructViewInline.StackTop]
func (t *StructViewInline) SetStackTop(v int) *StructViewInline {
	t.StackTop = v
	return t
}

// SetStripes sets the [StructViewInline.Stripes]
func (t *StructViewInline) SetStripes(v gi.Stripes) *StructViewInline {
	t.Stripes = v
	return t
}

// EditorType is the [gti.Type] for [Editor]
var EditorType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.Editor",
	ShortName:  "giv.Editor",
	IDName:     "editor",
	Doc:        "Editor supports editing of SVG elements",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Trans", &gti.Field{Name: "Trans", Type: "goki.dev/mat32/v2.Vec2", LocalType: "mat32.Vec2", Doc: "view translation offset (from dragging)", Directives: gti.Directives{}, Tag: ""}},
		{"Scale", &gti.Field{Name: "Scale", Type: "float32", LocalType: "float32", Doc: "view scaling (from zooming)", Directives: gti.Directives{}, Tag: ""}},
		{"SetDragCursor", &gti.Field{Name: "SetDragCursor", Type: "bool", LocalType: "bool", Doc: "has dragging cursor been set yet?", Directives: gti.Directives{}, Tag: "view:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "gi.WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Editor{},
})

// NewEditor adds a new [Editor] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewEditor(par ki.Ki, name ...string) *Editor {
	return par.NewChild(EditorType, name...).(*Editor)
}

// KiType returns the [*gti.Type] of [Editor]
func (t *Editor) KiType() *gti.Type {
	return EditorType
}

// New returns a new [*Editor] value
func (t *Editor) New() ki.Ki {
	return &Editor{}
}

// SetTrans sets the [Editor.Trans]:
// view translation offset (from dragging)
func (t *Editor) SetTrans(v mat32.Vec2) *Editor {
	t.Trans = v
	return t
}

// SetScale sets the [Editor.Scale]:
// view scaling (from zooming)
func (t *Editor) SetScale(v float32) *Editor {
	t.Scale = v
	return t
}

// SetSetDragCursor sets the [Editor.SetDragCursor]:
// has dragging cursor been set yet?
func (t *Editor) SetSetDragCursor(v bool) *Editor {
	t.SetDragCursor = v
	return t
}

// SetTooltip sets the [Editor.Tooltip]
func (t *Editor) SetTooltip(v string) *Editor {
	t.Tooltip = v
	return t
}

// SetClass sets the [Editor.Class]
func (t *Editor) SetClass(v string) *Editor {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Editor.CustomContextMenu]
func (t *Editor) SetCustomContextMenu(v func(m *gi.Scene)) *Editor {
	t.CustomContextMenu = v
	return t
}

// TableViewType is the [gti.Type] for [TableView]
var TableViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.TableView",
	ShortName:  "giv.TableView",
	IDName:     "table-view",
	Doc:        "TableView represents a slice-of-structs as a table, where the fields are\nthe columns, within an overall frame.  It is a full-featured editor with\nmultiple-selection, cut-and-paste, and drag-and-drop.\nIf ReadOnly, it functions as a mutually-exclusive item\nselector, highlighting the selected row and emitting a Selected action.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"StyleFunc", &gti.Field{Name: "StyleFunc", Type: "goki.dev/gi/v2/giv.TableViewStyleFunc", LocalType: "TableViewStyleFunc", Doc: "optional styling function", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"SelField", &gti.Field{Name: "SelField", Type: "string", LocalType: "string", Doc: "current selection field -- initially select value in this field", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"SortIdx", &gti.Field{Name: "SortIdx", Type: "int", LocalType: "int", Doc: "current sort index", Directives: gti.Directives{}, Tag: ""}},
		{"SortDesc", &gti.Field{Name: "SortDesc", Type: "bool", LocalType: "bool", Doc: "whether current sort order is descending", Directives: gti.Directives{}, Tag: ""}},
		{"StruType", &gti.Field{Name: "StruType", Type: "reflect.Type", LocalType: "reflect.Type", Doc: "struct type for each row", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"VisFields", &gti.Field{Name: "VisFields", Type: "[]reflect.StructField", LocalType: "[]reflect.StructField", Doc: "the visible fields", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
		{"NVisFields", &gti.Field{Name: "NVisFields", Type: "int", LocalType: "int", Doc: "number of visible fields", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" json:\"-\" xml:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SliceViewBase", &gti.Field{Name: "SliceViewBase", Type: "goki.dev/gi/v2/giv.SliceViewBase", LocalType: "SliceViewBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TableView{},
})

// NewTableView adds a new [TableView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTableView(par ki.Ki, name ...string) *TableView {
	return par.NewChild(TableViewType, name...).(*TableView)
}

// KiType returns the [*gti.Type] of [TableView]
func (t *TableView) KiType() *gti.Type {
	return TableViewType
}

// New returns a new [*TableView] value
func (t *TableView) New() ki.Ki {
	return &TableView{}
}

// SetStyleFunc sets the [TableView.StyleFunc]:
// optional styling function
func (t *TableView) SetStyleFunc(v TableViewStyleFunc) *TableView {
	t.StyleFunc = v
	return t
}

// SetSelField sets the [TableView.SelField]:
// current selection field -- initially select value in this field
func (t *TableView) SetSelField(v string) *TableView {
	t.SelField = v
	return t
}

// SetSortIdx sets the [TableView.SortIdx]:
// current sort index
func (t *TableView) SetSortIdx(v int) *TableView {
	t.SortIdx = v
	return t
}

// SetSortDesc sets the [TableView.SortDesc]:
// whether current sort order is descending
func (t *TableView) SetSortDesc(v bool) *TableView {
	t.SortDesc = v
	return t
}

// SetStruType sets the [TableView.StruType]:
// struct type for each row
func (t *TableView) SetStruType(v reflect.Type) *TableView {
	t.StruType = v
	return t
}

// SetVisFields sets the [TableView.VisFields]:
// the visible fields
func (t *TableView) SetVisFields(v []reflect.StructField) *TableView {
	t.VisFields = v
	return t
}

// SetNvisFields sets the [TableView.NVisFields]:
// number of visible fields
func (t *TableView) SetNvisFields(v int) *TableView {
	t.NVisFields = v
	return t
}

// SetTooltip sets the [TableView.Tooltip]
func (t *TableView) SetTooltip(v string) *TableView {
	t.Tooltip = v
	return t
}

// SetClass sets the [TableView.Class]
func (t *TableView) SetClass(v string) *TableView {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [TableView.CustomContextMenu]
func (t *TableView) SetCustomContextMenu(v func(m *gi.Scene)) *TableView {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [TableView.Lay]
func (t *TableView) SetLayout(v gi.Layouts) *TableView {
	t.Lay = v
	return t
}

// SetSpacing sets the [TableView.Spacing]
func (t *TableView) SetSpacing(v units.Value) *TableView {
	t.Spacing = v
	return t
}

// SetStackTop sets the [TableView.StackTop]
func (t *TableView) SetStackTop(v int) *TableView {
	t.StackTop = v
	return t
}

// SetStripes sets the [TableView.Stripes]
func (t *TableView) SetStripes(v gi.Stripes) *TableView {
	t.Stripes = v
	return t
}

// SetViewMu sets the [TableView.ViewMu]
func (t *TableView) SetViewMu(v *sync.Mutex) *TableView {
	t.ViewMu = v
	return t
}

// SetSliceNpval sets the [TableView.SliceNPVal]
func (t *TableView) SetSliceNpval(v reflect.Value) *TableView {
	t.SliceNPVal = v
	return t
}

// SetSliceValView sets the [TableView.SliceValView]
func (t *TableView) SetSliceValView(v Value) *TableView {
	t.SliceValView = v
	return t
}

// SetValues sets the [TableView.Values]
func (t *TableView) SetValues(v []Value) *TableView {
	t.Values = v
	return t
}

// SetSelVal sets the [TableView.SelVal]
func (t *TableView) SetSelVal(v any) *TableView {
	t.SelVal = v
	return t
}

// SetSelIdx sets the [TableView.SelIdx]
func (t *TableView) SetSelIdx(v int) *TableView {
	t.SelIdx = v
	return t
}

// SetSelIdxs sets the [TableView.SelIdxs]
func (t *TableView) SetSelIdxs(v map[int]struct{}) *TableView {
	t.SelIdxs = v
	return t
}

// SetDraggedIdxs sets the [TableView.DraggedIdxs]
func (t *TableView) SetDraggedIdxs(v []int) *TableView {
	t.DraggedIdxs = v
	return t
}

// SetViewPath sets the [TableView.ViewPath]
func (t *TableView) SetViewPath(v string) *TableView {
	t.ViewPath = v
	return t
}

// SetTmpSave sets the [TableView.TmpSave]
func (t *TableView) SetTmpSave(v Value) *TableView {
	t.TmpSave = v
	return t
}

// SetToolbarSlice sets the [TableView.ToolbarSlice]
func (t *TableView) SetToolbarSlice(v any) *TableView {
	t.ToolbarSlice = v
	return t
}

// SetRowHeight sets the [TableView.RowHeight]
func (t *TableView) SetRowHeight(v float32) *TableView {
	t.RowHeight = v
	return t
}

// SetLayoutHeight sets the [TableView.LayoutHeight]
func (t *TableView) SetLayoutHeight(v float32) *TableView {
	t.LayoutHeight = v
	return t
}

// SetVisRows sets the [TableView.VisRows]
func (t *TableView) SetVisRows(v int) *TableView {
	t.VisRows = v
	return t
}

// SetStartIdx sets the [TableView.StartIdx]
func (t *TableView) SetStartIdx(v int) *TableView {
	t.StartIdx = v
	return t
}

// SetRenderedRows sets the [TableView.RenderedRows]
func (t *TableView) SetRenderedRows(v int) *TableView {
	t.RenderedRows = v
	return t
}

// SetSliceSize sets the [TableView.SliceSize]
func (t *TableView) SetSliceSize(v int) *TableView {
	t.SliceSize = v
	return t
}

// SetCurIdx sets the [TableView.CurIdx]
func (t *TableView) SetCurIdx(v int) *TableView {
	t.CurIdx = v
	return t
}

// SetElVal sets the [TableView.ElVal]
func (t *TableView) SetElVal(v reflect.Value) *TableView {
	t.ElVal = v
	return t
}

// TreeViewType is the [gti.Type] for [TreeView]
var TreeViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.TreeView",
	ShortName:  "giv.TreeView",
	IDName:     "tree-view",
	Doc:        "TreeView provides a graphical representation of a tree tructure\nproviding full navigation and manipulation abilities.\n\nIf the SyncNode field is non-nil, typically via\nSyncRootNode method, then the TreeView mirrors another\nKi tree structure, and tree editing functions apply to\nthe source tree first, and then to the TreeView by sync.\n\nOtherwise, data can be directly encoded in a TreeView\nderived type, to represent any kind of tree structure\nand associated data.\n\nStandard events.Event are sent to any listeners, including\nSelect, Change, and DoubleClick.  The selected nodes\nare in the root SelectedNodes list.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SyncNode", &gti.Field{Name: "SyncNode", Type: "goki.dev/ki/v2.Ki", LocalType: "ki.Ki", Doc: "If non-Ki Node that this widget is viewing in the tree -- the source", Directives: gti.Directives{}, Tag: "set:\"-\" copy:\"-\" json:\"-\" xml:\"-\""}},
		{"Icon", &gti.Field{Name: "Icon", Type: "goki.dev/icons.Icon", LocalType: "icons.Icon", Doc: "optional icon, displayed to the the left of the text label", Directives: gti.Directives{}, Tag: ""}},
		{"Indent", &gti.Field{Name: "Indent", Type: "goki.dev/girl/units.Value", LocalType: "units.Value", Doc: "amount to indent children relative to this node", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\""}},
		{"OpenDepth", &gti.Field{Name: "OpenDepth", Type: "int", LocalType: "int", Doc: "depth for nodes be initialized as open (default 4).\nNodes beyond this depth will be initialized as closed.", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\""}},
		{"ViewIdx", &gti.Field{Name: "ViewIdx", Type: "int", LocalType: "int", Doc: "linear index of this node within the entire tree.\nupdated on full rebuilds and may sometimes be off,\nbut close enough for expected uses", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" edit:\"-\""}},
		{"WidgetSize", &gti.Field{Name: "WidgetSize", Type: "goki.dev/mat32/v2.Vec2", LocalType: "mat32.Vec2", Doc: "size of just this node widget.\nour alloc includes all of our children, but we only draw us.", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" edit:\"-\""}},
		{"RootView", &gti.Field{Name: "RootView", Type: "*goki.dev/gi/v2/giv.TreeView", LocalType: "*TreeView", Doc: "cached root of the view", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" edit:\"-\""}},
		{"SelectedNodes", &gti.Field{Name: "SelectedNodes", Type: "[]*goki.dev/gi/v2/giv.TreeView", LocalType: "[]*TreeView", Doc: "SelectedNodes holds the currently-selected nodes, on the\nRootView node only.", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" edit:\"-\""}},
		{"actStateLayer", &gti.Field{Name: "actStateLayer", Type: "float32", LocalType: "float32", Doc: "actStateLayer is the actual state layer of the tree view, which\nshould be used when rendering it and its parts (but not its children).\nthe reason that it exists is so that the children of the tree view\n(other tree views) do not inherit its stateful background color, as\nthat does not look good.", Directives: gti.Directives{}, Tag: "set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "gi.WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{
		{"InsertAfter", &gti.Method{Name: "InsertAfter", Doc: "InsertAfter inserts a new node in the tree\nafter this node, at the same (sibling) level,\nprompting for the type of node to insert.\nIf SyncNode is set, operates on Sync Tree.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"InsertBefore", &gti.Method{Name: "InsertBefore", Doc: "InsertBefore inserts a new node in the tree\nbefore this node, at the same (sibling) level,\nprompting for the type of node to insert\nIf SyncNode is set, operates on Sync Tree.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"AddChildNode", &gti.Method{Name: "AddChildNode", Doc: "AddChildNode adds a new child node to this one in the tree,\nprompting the user for the type of node to add\nIf SyncNode is set, operates on Sync Tree.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"DeleteNode", &gti.Method{Name: "DeleteNode", Doc: "DeleteNode deletes the tree node or sync node corresponding\nto this view node in the sync tree.\nIf SyncNode is set, operates on Sync Tree.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"Duplicate", &gti.Method{Name: "Duplicate", Doc: "Duplicate duplicates the sync node corresponding to this view node in\nthe tree, and inserts the duplicate after this node (as a new sibling).\nIf SyncNode is set, operates on Sync Tree.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"EditNode", &gti.Method{Name: "EditNode", Doc: "EditNode pulls up a StructViewDialog window on the node.\nIf SyncNode is set, operates on Sync Tree.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"GoGiEditNode", &gti.Method{Name: "GoGiEditNode", Doc: "GoGiEditNode pulls up a new GoGiEditor window on the node.\nIf SyncNode is set, operates on Sync Tree.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"OpenAll", &gti.Method{Name: "OpenAll", Doc: "OpenAll opens the given node and all of its sub-nodes", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"CloseAll", &gti.Method{Name: "CloseAll", Doc: "CloseAll closes the given node and all of its sub-nodes.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"Copy", &gti.Method{Name: "Copy", Doc: "Copy copies to clip.Board, optionally resetting the selection.\nsatisfies gi.Clipper interface and can be overridden by subtypes", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"reset", &gti.Field{Name: "reset", Type: "bool", LocalType: "bool", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"Cut", &gti.Method{Name: "Cut", Doc: "Cut copies to clip.Board and deletes selected items.\nsatisfies gi.Clipper interface and can be overridden by subtypes", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"Paste", &gti.Method{Name: "Paste", Doc: "Paste pastes clipboard at given node.\nsatisfies gi.Clipper interface and can be overridden by subtypes", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
	}),
	Instance: &TreeView{},
})

// NewTreeView adds a new [TreeView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTreeView(par ki.Ki, name ...string) *TreeView {
	return par.NewChild(TreeViewType, name...).(*TreeView)
}

// KiType returns the [*gti.Type] of [TreeView]
func (t *TreeView) KiType() *gti.Type {
	return TreeViewType
}

// New returns a new [*TreeView] value
func (t *TreeView) New() ki.Ki {
	return &TreeView{}
}

// SetIcon sets the [TreeView.Icon]:
// optional icon, displayed to the the left of the text label
func (t *TreeView) SetIcon(v icons.Icon) *TreeView {
	t.Icon = v
	return t
}

// SetIndent sets the [TreeView.Indent]:
// amount to indent children relative to this node
func (t *TreeView) SetIndent(v units.Value) *TreeView {
	t.Indent = v
	return t
}

// SetOpenDepth sets the [TreeView.OpenDepth]:
// depth for nodes be initialized as open (default 4).
// Nodes beyond this depth will be initialized as closed.
func (t *TreeView) SetOpenDepth(v int) *TreeView {
	t.OpenDepth = v
	return t
}

// SetViewIdx sets the [TreeView.ViewIdx]:
// linear index of this node within the entire tree.
// updated on full rebuilds and may sometimes be off,
// but close enough for expected uses
func (t *TreeView) SetViewIdx(v int) *TreeView {
	t.ViewIdx = v
	return t
}

// SetWidgetSize sets the [TreeView.WidgetSize]:
// size of just this node widget.
// our alloc includes all of our children, but we only draw us.
func (t *TreeView) SetWidgetSize(v mat32.Vec2) *TreeView {
	t.WidgetSize = v
	return t
}

// SetRootView sets the [TreeView.RootView]:
// cached root of the view
func (t *TreeView) SetRootView(v *TreeView) *TreeView {
	t.RootView = v
	return t
}

// SetSelectedNodes sets the [TreeView.SelectedNodes]:
// SelectedNodes holds the currently-selected nodes, on the
// RootView node only.
func (t *TreeView) SetSelectedNodes(v []*TreeView) *TreeView {
	t.SelectedNodes = v
	return t
}

// SetTooltip sets the [TreeView.Tooltip]
func (t *TreeView) SetTooltip(v string) *TreeView {
	t.Tooltip = v
	return t
}

// SetClass sets the [TreeView.Class]
func (t *TreeView) SetClass(v string) *TreeView {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [TreeView.CustomContextMenu]
func (t *TreeView) SetCustomContextMenu(v func(m *gi.Scene)) *TreeView {
	t.CustomContextMenu = v
	return t
}

// VCSLogViewType is the [gti.Type] for [VCSLogView]
var VCSLogViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.VCSLogView",
	ShortName:  "giv.VCSLogView",
	IDName:     "vcs-log-view",
	Doc:        "VCSLogView is a view of the variables",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Log", &gti.Field{Name: "Log", Type: "goki.dev/vci/v2.Log", LocalType: "vci.Log", Doc: "current log", Directives: gti.Directives{}, Tag: ""}},
		{"File", &gti.Field{Name: "File", Type: "string", LocalType: "string", Doc: "file that this is a log of -- if blank then it is entire repository", Directives: gti.Directives{}, Tag: ""}},
		{"Since", &gti.Field{Name: "Since", Type: "string", LocalType: "string", Doc: "date expression for how long ago to include log entries from", Directives: gti.Directives{}, Tag: ""}},
		{"Repo", &gti.Field{Name: "Repo", Type: "goki.dev/vci/v2.Repo", LocalType: "vci.Repo", Doc: "version control system repository", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" copy:\"-\""}},
		{"RevA", &gti.Field{Name: "RevA", Type: "string", LocalType: "string", Doc: "revision A -- defaults to HEAD", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"RevB", &gti.Field{Name: "RevB", Type: "string", LocalType: "string", Doc: "revision B -- blank means current working copy", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"SetA", &gti.Field{Name: "SetA", Type: "bool", LocalType: "bool", Doc: "double-click will set the A revision -- else B", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "goki.dev/gi/v2/gi.Layout", LocalType: "gi.Layout", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &VCSLogView{},
})

// NewVCSLogView adds a new [VCSLogView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewVCSLogView(par ki.Ki, name ...string) *VCSLogView {
	return par.NewChild(VCSLogViewType, name...).(*VCSLogView)
}

// KiType returns the [*gti.Type] of [VCSLogView]
func (t *VCSLogView) KiType() *gti.Type {
	return VCSLogViewType
}

// New returns a new [*VCSLogView] value
func (t *VCSLogView) New() ki.Ki {
	return &VCSLogView{}
}

// SetLog sets the [VCSLogView.Log]:
// current log
func (t *VCSLogView) SetLog(v vci.Log) *VCSLogView {
	t.Log = v
	return t
}

// SetFile sets the [VCSLogView.File]:
// file that this is a log of -- if blank then it is entire repository
func (t *VCSLogView) SetFile(v string) *VCSLogView {
	t.File = v
	return t
}

// SetSince sets the [VCSLogView.Since]:
// date expression for how long ago to include log entries from
func (t *VCSLogView) SetSince(v string) *VCSLogView {
	t.Since = v
	return t
}

// SetRepo sets the [VCSLogView.Repo]:
// version control system repository
func (t *VCSLogView) SetRepo(v vci.Repo) *VCSLogView {
	t.Repo = v
	return t
}

// SetSetA sets the [VCSLogView.SetA]:
// double-click will set the A revision -- else B
func (t *VCSLogView) SetSetA(v bool) *VCSLogView {
	t.SetA = v
	return t
}

// SetTooltip sets the [VCSLogView.Tooltip]
func (t *VCSLogView) SetTooltip(v string) *VCSLogView {
	t.Tooltip = v
	return t
}

// SetClass sets the [VCSLogView.Class]
func (t *VCSLogView) SetClass(v string) *VCSLogView {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [VCSLogView.CustomContextMenu]
func (t *VCSLogView) SetCustomContextMenu(v func(m *gi.Scene)) *VCSLogView {
	t.CustomContextMenu = v
	return t
}

// SetLayout sets the [VCSLogView.Lay]
func (t *VCSLogView) SetLayout(v gi.Layouts) *VCSLogView {
	t.Lay = v
	return t
}

// SetSpacing sets the [VCSLogView.Spacing]
func (t *VCSLogView) SetSpacing(v units.Value) *VCSLogView {
	t.Spacing = v
	return t
}

// SetStackTop sets the [VCSLogView.StackTop]
func (t *VCSLogView) SetStackTop(v int) *VCSLogView {
	t.StackTop = v
	return t
}

var _ = gti.AddFunc(&gti.Func{
	Name: "goki.dev/gi/v2/giv.ViewStdKeyMaps",
	Doc:  "ViewStdKeyMaps shows the standard maps that are compiled into the program and have\nall the lastest key functions bound to standard values.  Useful for\ncomparing against custom maps.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Args:    ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
})
