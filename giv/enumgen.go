// Code generated by "goki generate"; DO NOT EDIT.

package giv

import (
	"errors"
	"strconv"
	"strings"
	"sync/atomic"

	"goki.dev/enums"
	"goki.dev/ki/v2"
)

var _FileNodeFlagsValues = []FileNodeFlags{7, 8}

// FileNodeFlagsN is the highest valid value
// for type FileNodeFlags, plus one.
const FileNodeFlagsN FileNodeFlags = 9

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FileNodeFlagsNoOp() {
	var x [1]struct{}
	_ = x[FileNodeOpen-(7)]
	_ = x[FileNodeSymLink-(8)]
}

var _FileNodeFlagsNameToValueMap = map[string]FileNodeFlags{
	`FileNodeOpen`:    7,
	`filenodeopen`:    7,
	`FileNodeSymLink`: 8,
	`filenodesymlink`: 8,
}

var _FileNodeFlagsDescMap = map[FileNodeFlags]string{
	7: `FileNodeOpen means file is open -- for directories, this means that sub-files should be / have been loaded -- for files, means that they have been opened e.g., for editing`,
	8: `FileNodeSymLink indicates that file is a symbolic link -- file info is all for the target of the symlink`,
}

var _FileNodeFlagsMap = map[FileNodeFlags]string{
	7: `FileNodeOpen`,
	8: `FileNodeSymLink`,
}

// String returns the string representation
// of this FileNodeFlags value.
func (i FileNodeFlags) String() string {
	str := ""
	for _, ie := range ki.FlagsValues() {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	for _, ie := range _FileNodeFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this FileNodeFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i FileNodeFlags) BitIndexString() string {
	if str, ok := _FileNodeFlagsMap[i]; ok {
		return str
	}
	return ki.Flags(i).BitIndexString()
}

// SetString sets the FileNodeFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FileNodeFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the FileNodeFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *FileNodeFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _FileNodeFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _FileNodeFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			err := (*ki.Flags)(i).SetStringOr(flg)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Int64 returns the FileNodeFlags value as an int64.
func (i FileNodeFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FileNodeFlags value from an int64.
func (i *FileNodeFlags) SetInt64(in int64) {
	*i = FileNodeFlags(in)
}

// Desc returns the description of the FileNodeFlags value.
func (i FileNodeFlags) Desc() string {
	if str, ok := _FileNodeFlagsDescMap[i]; ok {
		return str
	}
	return ki.Flags(i).Desc()
}

// FileNodeFlagsValues returns all possible values
// for the type FileNodeFlags.
func FileNodeFlagsValues() []FileNodeFlags {
	es := ki.FlagsValues()
	res := make([]FileNodeFlags, len(es))
	for i, e := range es {
		res[i] = FileNodeFlags(e)
	}
	res = append(res, _FileNodeFlagsValues...)
	return res
}

// Values returns all possible values
// for the type FileNodeFlags.
func (i FileNodeFlags) Values() []enums.Enum {
	es := ki.FlagsValues()
	les := len(es)
	res := make([]enums.Enum, les+len(_FileNodeFlagsValues))
	for i, d := range es {
		res[i] = d
	}
	for i, d := range _FileNodeFlagsValues {
		res[i+les] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FileNodeFlags.
func (i FileNodeFlags) IsValid() bool {
	_, ok := _FileNodeFlagsMap[i]
	if !ok {
		return ki.Flags(i).IsValid()
	}
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i FileNodeFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *FileNodeFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FileNodeFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FileNodeFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _DirFlagsValues = []DirFlags{0, 1, 2, 3}

// DirFlagsN is the highest valid value
// for type DirFlags, plus one.
const DirFlagsN DirFlags = 4

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _DirFlagsNoOp() {
	var x [1]struct{}
	_ = x[DirMark-(0)]
	_ = x[DirIsOpen-(1)]
	_ = x[DirSortByName-(2)]
	_ = x[DirSortByModTime-(3)]
}

var _DirFlagsNameToValueMap = map[string]DirFlags{
	`DirMark`:          0,
	`dirmark`:          0,
	`DirIsOpen`:        1,
	`dirisopen`:        1,
	`DirSortByName`:    2,
	`dirsortbyname`:    2,
	`DirSortByModTime`: 3,
	`dirsortbymodtime`: 3,
}

var _DirFlagsDescMap = map[DirFlags]string{
	0: `DirMark means directory is marked -- unmarked entries are deleted post-update`,
	1: `DirIsOpen means directory is open -- else closed`,
	2: `DirSortByName means sort the directory entries by name. this is mutex with other sorts -- keeping option open for non-binary sort choices.`,
	3: `DirSortByModTime means sort the directory entries by modification time`,
}

var _DirFlagsMap = map[DirFlags]string{
	0: `DirMark`,
	1: `DirIsOpen`,
	2: `DirSortByName`,
	3: `DirSortByModTime`,
}

// String returns the string representation
// of this DirFlags value.
func (i DirFlags) String() string {
	str := ""
	for _, ie := range _DirFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this DirFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i DirFlags) BitIndexString() string {
	if str, ok := _DirFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the DirFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *DirFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the DirFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *DirFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _DirFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _DirFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type DirFlags")
		}
	}
	return nil
}

// Int64 returns the DirFlags value as an int64.
func (i DirFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the DirFlags value from an int64.
func (i *DirFlags) SetInt64(in int64) {
	*i = DirFlags(in)
}

// Desc returns the description of the DirFlags value.
func (i DirFlags) Desc() string {
	if str, ok := _DirFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// DirFlagsValues returns all possible values
// for the type DirFlags.
func DirFlagsValues() []DirFlags {
	return _DirFlagsValues
}

// Values returns all possible values
// for the type DirFlags.
func (i DirFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_DirFlagsValues))
	for i, d := range _DirFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type DirFlags.
func (i DirFlags) IsValid() bool {
	_, ok := _DirFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i DirFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *DirFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i DirFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *DirFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _MethViewFlagsValues = []MethViewFlags{0, 1, 2, 3, 4, 5}

// MethViewFlagsN is the highest valid value
// for type MethViewFlags, plus one.
const MethViewFlagsN MethViewFlags = 6

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _MethViewFlagsNoOp() {
	var x [1]struct{}
	_ = x[MethViewConfirm-(0)]
	_ = x[MethViewShowReturn-(1)]
	_ = x[MethViewNoUpdateAfter-(2)]
	_ = x[MethViewHasSubMenu-(3)]
	_ = x[MethViewHasSubMenuVal-(4)]
	_ = x[MethViewKeyFun-(5)]
}

var _MethViewFlagsNameToValueMap = map[string]MethViewFlags{
	`MethViewConfirm`:       0,
	`methviewconfirm`:       0,
	`MethViewShowReturn`:    1,
	`methviewshowreturn`:    1,
	`MethViewNoUpdateAfter`: 2,
	`methviewnoupdateafter`: 2,
	`MethViewHasSubMenu`:    3,
	`methviewhassubmenu`:    3,
	`MethViewHasSubMenuVal`: 4,
	`methviewhassubmenuval`: 4,
	`MethViewKeyFun`:        5,
	`methviewkeyfun`:        5,
}

var _MethViewFlagsDescMap = map[MethViewFlags]string{
	0: `MethViewConfirm confirms action before proceeding`,
	1: `MethViewShowReturn shows the return value from the method`,
	2: `MethViewNoUpdateAfter means do not update window after method runs (default is to do so)`,
	3: `MethViewHasSubMenu means that this action has a submenu option -- argument values will be selected from the auto-generated submenu`,
	4: `MethViewHasSubMenuVal means that this action was called using a submenu and the SubMenuVal has the selected value`,
	5: `MethViewKeyFun means this action&#39;s only function is to emit the key fun`,
}

var _MethViewFlagsMap = map[MethViewFlags]string{
	0: `MethViewConfirm`,
	1: `MethViewShowReturn`,
	2: `MethViewNoUpdateAfter`,
	3: `MethViewHasSubMenu`,
	4: `MethViewHasSubMenuVal`,
	5: `MethViewKeyFun`,
}

// String returns the string representation
// of this MethViewFlags value.
func (i MethViewFlags) String() string {
	str := ""
	for _, ie := range _MethViewFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this MethViewFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i MethViewFlags) BitIndexString() string {
	if str, ok := _MethViewFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the MethViewFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *MethViewFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the MethViewFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *MethViewFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _MethViewFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _MethViewFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type MethViewFlags")
		}
	}
	return nil
}

// Int64 returns the MethViewFlags value as an int64.
func (i MethViewFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the MethViewFlags value from an int64.
func (i *MethViewFlags) SetInt64(in int64) {
	*i = MethViewFlags(in)
}

// Desc returns the description of the MethViewFlags value.
func (i MethViewFlags) Desc() string {
	if str, ok := _MethViewFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// MethViewFlagsValues returns all possible values
// for the type MethViewFlags.
func MethViewFlagsValues() []MethViewFlags {
	return _MethViewFlagsValues
}

// Values returns all possible values
// for the type MethViewFlags.
func (i MethViewFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_MethViewFlagsValues))
	for i, d := range _MethViewFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type MethViewFlags.
func (i MethViewFlags) IsValid() bool {
	_, ok := _MethViewFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i MethViewFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *MethViewFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i MethViewFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *MethViewFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _ArgDataFlagsValues = []ArgDataFlags{0, 1}

// ArgDataFlagsN is the highest valid value
// for type ArgDataFlags, plus one.
const ArgDataFlagsN ArgDataFlags = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ArgDataFlagsNoOp() {
	var x [1]struct{}
	_ = x[ArgDataHasDef-(0)]
	_ = x[ArgDataValSet-(1)]
}

var _ArgDataFlagsNameToValueMap = map[string]ArgDataFlags{
	`ArgDataHasDef`: 0,
	`argdatahasdef`: 0,
	`ArgDataValSet`: 1,
	`argdatavalset`: 1,
}

var _ArgDataFlagsDescMap = map[ArgDataFlags]string{
	0: `ArgDataHasDef means that there was a Default value set`,
	1: `ArgDataValSet means that there is a fixed value for this arg, given in the config props and set in the Default, so it does not need to be prompted for`,
}

var _ArgDataFlagsMap = map[ArgDataFlags]string{
	0: `ArgDataHasDef`,
	1: `ArgDataValSet`,
}

// String returns the string representation
// of this ArgDataFlags value.
func (i ArgDataFlags) String() string {
	str := ""
	for _, ie := range _ArgDataFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this ArgDataFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i ArgDataFlags) BitIndexString() string {
	if str, ok := _ArgDataFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the ArgDataFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *ArgDataFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the ArgDataFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *ArgDataFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _ArgDataFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _ArgDataFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type ArgDataFlags")
		}
	}
	return nil
}

// Int64 returns the ArgDataFlags value as an int64.
func (i ArgDataFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the ArgDataFlags value from an int64.
func (i *ArgDataFlags) SetInt64(in int64) {
	*i = ArgDataFlags(in)
}

// Desc returns the description of the ArgDataFlags value.
func (i ArgDataFlags) Desc() string {
	if str, ok := _ArgDataFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// ArgDataFlagsValues returns all possible values
// for the type ArgDataFlags.
func ArgDataFlagsValues() []ArgDataFlags {
	return _ArgDataFlagsValues
}

// Values returns all possible values
// for the type ArgDataFlags.
func (i ArgDataFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_ArgDataFlagsValues))
	for i, d := range _ArgDataFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type ArgDataFlags.
func (i ArgDataFlags) IsValid() bool {
	_, ok := _ArgDataFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i ArgDataFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *ArgDataFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ArgDataFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ArgDataFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextBufSignalsValues = []TextBufSignals{0, 1, 2, 3, 4, 5}

// TextBufSignalsN is the highest valid value
// for type TextBufSignals, plus one.
const TextBufSignalsN TextBufSignals = 6

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextBufSignalsNoOp() {
	var x [1]struct{}
	_ = x[TextBufDone-(0)]
	_ = x[TextBufNew-(1)]
	_ = x[TextBufInsert-(2)]
	_ = x[TextBufDelete-(3)]
	_ = x[TextBufMarkUpdt-(4)]
	_ = x[TextBufClosed-(5)]
}

var _TextBufSignalsNameToValueMap = map[string]TextBufSignals{
	`TextBufDone`:     0,
	`textbufdone`:     0,
	`TextBufNew`:      1,
	`textbufnew`:      1,
	`TextBufInsert`:   2,
	`textbufinsert`:   2,
	`TextBufDelete`:   3,
	`textbufdelete`:   3,
	`TextBufMarkUpdt`: 4,
	`textbufmarkupdt`: 4,
	`TextBufClosed`:   5,
	`textbufclosed`:   5,
}

var _TextBufSignalsDescMap = map[TextBufSignals]string{
	0: `TextBufDone means that editing was completed and applied to Txt field -- data is Txt bytes`,
	1: `TextBufNew signals that entirely new text is present -- all views update -- data is Txt bytes.`,
	2: `TextBufInsert signals that some text was inserted -- data is textbuf.Edit describing change -- the TextBuf always reflects the current state *after* the edit.`,
	3: `TextBufDelete signals that some text was deleted -- data is textbuf.Edit describing change -- the TextBuf always reflects the current state *after* the edit.`,
	4: `TextBufMarkUpdt signals that the Markup text has been updated -- this signal is typically sent from a separate goroutine so should be used with a mutex`,
	5: `TextBufClosed signals that the textbuf was closed`,
}

var _TextBufSignalsMap = map[TextBufSignals]string{
	0: `TextBufDone`,
	1: `TextBufNew`,
	2: `TextBufInsert`,
	3: `TextBufDelete`,
	4: `TextBufMarkUpdt`,
	5: `TextBufClosed`,
}

// String returns the string representation
// of this TextBufSignals value.
func (i TextBufSignals) String() string {
	if str, ok := _TextBufSignalsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TextBufSignals value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextBufSignals) SetString(s string) error {
	if val, ok := _TextBufSignalsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TextBufSignalsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type TextBufSignals")
}

// Int64 returns the TextBufSignals value as an int64.
func (i TextBufSignals) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextBufSignals value from an int64.
func (i *TextBufSignals) SetInt64(in int64) {
	*i = TextBufSignals(in)
}

// Desc returns the description of the TextBufSignals value.
func (i TextBufSignals) Desc() string {
	if str, ok := _TextBufSignalsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TextBufSignalsValues returns all possible values
// for the type TextBufSignals.
func TextBufSignalsValues() []TextBufSignals {
	return _TextBufSignalsValues
}

// Values returns all possible values
// for the type TextBufSignals.
func (i TextBufSignals) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TextBufSignalsValues))
	for i, d := range _TextBufSignalsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextBufSignals.
func (i TextBufSignals) IsValid() bool {
	_, ok := _TextBufSignalsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextBufSignals) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextBufSignals) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextBufFlagsValues = []TextBufFlags{10, 11, 12, 13}

// TextBufFlagsN is the highest valid value
// for type TextBufFlags, plus one.
const TextBufFlagsN TextBufFlags = 14

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextBufFlagsNoOp() {
	var x [1]struct{}
	_ = x[TextBufAutoSaving-(10)]
	_ = x[TextBufMarkingUp-(11)]
	_ = x[TextBufChanged-(12)]
	_ = x[TextBufFileModOk-(13)]
}

var _TextBufFlagsNameToValueMap = map[string]TextBufFlags{
	`TextBufAutoSaving`: 10,
	`textbufautosaving`: 10,
	`TextBufMarkingUp`:  11,
	`textbufmarkingup`:  11,
	`TextBufChanged`:    12,
	`textbufchanged`:    12,
	`TextBufFileModOk`:  13,
	`textbuffilemodok`:  13,
}

var _TextBufFlagsDescMap = map[TextBufFlags]string{
	10: `TextBufAutoSaving is used in atomically safe way to protect autosaving`,
	11: `TextBufMarkingUp indicates current markup operation in progress -- don&#39;t redo`,
	12: `TextBufChanged indicates if the text has been changed (edited) relative to the original, since last save`,
	13: `TextBufFileModOk have already asked about fact that file has changed since being opened, user is ok`,
}

var _TextBufFlagsMap = map[TextBufFlags]string{
	10: `TextBufAutoSaving`,
	11: `TextBufMarkingUp`,
	12: `TextBufChanged`,
	13: `TextBufFileModOk`,
}

// String returns the string representation
// of this TextBufFlags value.
func (i TextBufFlags) String() string {
	str := ""
	for _, ie := range ki.FlagsValues() {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	for _, ie := range _TextBufFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this TextBufFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i TextBufFlags) BitIndexString() string {
	if str, ok := _TextBufFlagsMap[i]; ok {
		return str
	}
	return ki.Flags(i).BitIndexString()
}

// SetString sets the TextBufFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextBufFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the TextBufFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *TextBufFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _TextBufFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _TextBufFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			err := (*ki.Flags)(i).SetStringOr(flg)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Int64 returns the TextBufFlags value as an int64.
func (i TextBufFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextBufFlags value from an int64.
func (i *TextBufFlags) SetInt64(in int64) {
	*i = TextBufFlags(in)
}

// Desc returns the description of the TextBufFlags value.
func (i TextBufFlags) Desc() string {
	if str, ok := _TextBufFlagsDescMap[i]; ok {
		return str
	}
	return ki.Flags(i).Desc()
}

// TextBufFlagsValues returns all possible values
// for the type TextBufFlags.
func TextBufFlagsValues() []TextBufFlags {
	es := ki.FlagsValues()
	res := make([]TextBufFlags, len(es))
	for i, e := range es {
		res[i] = TextBufFlags(e)
	}
	res = append(res, _TextBufFlagsValues...)
	return res
}

// Values returns all possible values
// for the type TextBufFlags.
func (i TextBufFlags) Values() []enums.Enum {
	es := ki.FlagsValues()
	les := len(es)
	res := make([]enums.Enum, les+len(_TextBufFlagsValues))
	for i, d := range es {
		res[i] = d
	}
	for i, d := range _TextBufFlagsValues {
		res[i+les] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextBufFlags.
func (i TextBufFlags) IsValid() bool {
	_, ok := _TextBufFlagsMap[i]
	if !ok {
		return ki.Flags(i).IsValid()
	}
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i TextBufFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *TextBufFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextBufFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextBufFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextViewSignalsValues = []TextViewSignals{0, 1, 2, 3, 4}

// TextViewSignalsN is the highest valid value
// for type TextViewSignals, plus one.
const TextViewSignalsN TextViewSignals = 5

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextViewSignalsNoOp() {
	var x [1]struct{}
	_ = x[TextViewDone-(0)]
	_ = x[TextViewSelected-(1)]
	_ = x[TextViewCursorMoved-(2)]
	_ = x[TextViewISearch-(3)]
	_ = x[TextViewQReplace-(4)]
}

var _TextViewSignalsNameToValueMap = map[string]TextViewSignals{
	`TextViewDone`:        0,
	`textviewdone`:        0,
	`TextViewSelected`:    1,
	`textviewselected`:    1,
	`TextViewCursorMoved`: 2,
	`textviewcursormoved`: 2,
	`TextViewISearch`:     3,
	`textviewisearch`:     3,
	`TextViewQReplace`:    4,
	`textviewqreplace`:    4,
}

var _TextViewSignalsDescMap = map[TextViewSignals]string{
	0: `TextViewDone signal indicates return was pressed and an edit was completed -- data is the text`,
	1: `TextViewSelected signal indicates some text was selected (for Inactive state, selection is via WidgetSig)`,
	2: `TextViewCursorMoved signal indicates cursor moved emitted for every cursor movement -- e.g., for displaying cursor pos`,
	3: `TextViewISearch is emitted for every update of interactive search process -- see ISearch.* members for current state`,
	4: `TextViewQReplace is emitted for every update of query-replace process -- see QReplace.* members for current state`,
}

var _TextViewSignalsMap = map[TextViewSignals]string{
	0: `TextViewDone`,
	1: `TextViewSelected`,
	2: `TextViewCursorMoved`,
	3: `TextViewISearch`,
	4: `TextViewQReplace`,
}

// String returns the string representation
// of this TextViewSignals value.
func (i TextViewSignals) String() string {
	if str, ok := _TextViewSignalsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TextViewSignals value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextViewSignals) SetString(s string) error {
	if val, ok := _TextViewSignalsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TextViewSignalsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type TextViewSignals")
}

// Int64 returns the TextViewSignals value as an int64.
func (i TextViewSignals) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextViewSignals value from an int64.
func (i *TextViewSignals) SetInt64(in int64) {
	*i = TextViewSignals(in)
}

// Desc returns the description of the TextViewSignals value.
func (i TextViewSignals) Desc() string {
	if str, ok := _TextViewSignalsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TextViewSignalsValues returns all possible values
// for the type TextViewSignals.
func TextViewSignalsValues() []TextViewSignals {
	return _TextViewSignalsValues
}

// Values returns all possible values
// for the type TextViewSignals.
func (i TextViewSignals) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TextViewSignalsValues))
	for i, d := range _TextViewSignalsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextViewSignals.
func (i TextViewSignals) IsValid() bool {
	_, ok := _TextViewSignalsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextViewSignals) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextViewSignals) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextViewStatesValues = []TextViewStates{0, 1, 2, 3, 4}

// TextViewStatesN is the highest valid value
// for type TextViewStates, plus one.
const TextViewStatesN TextViewStates = 5

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextViewStatesNoOp() {
	var x [1]struct{}
	_ = x[TextViewActive-(0)]
	_ = x[TextViewFocus-(1)]
	_ = x[TextViewInactive-(2)]
	_ = x[TextViewSel-(3)]
	_ = x[TextViewHighlight-(4)]
}

var _TextViewStatesNameToValueMap = map[string]TextViewStates{
	`TextViewActive`:    0,
	`textviewactive`:    0,
	`TextViewFocus`:     1,
	`textviewfocus`:     1,
	`TextViewInactive`:  2,
	`textviewinactive`:  2,
	`TextViewSel`:       3,
	`textviewsel`:       3,
	`TextViewHighlight`: 4,
	`textviewhighlight`: 4,
}

var _TextViewStatesDescMap = map[TextViewStates]string{
	0: `TextViewActive is the normal state -- there but not being interacted with`,
	1: `TextViewFocus states means textvieww is the focus -- will respond to keyboard input`,
	2: `TextViewInactive means the textview is inactive -- not editable`,
	3: `TextViewSel means the text region is selected`,
	4: `TextViewHighlight means the text region is highlighted`,
}

var _TextViewStatesMap = map[TextViewStates]string{
	0: `TextViewActive`,
	1: `TextViewFocus`,
	2: `TextViewInactive`,
	3: `TextViewSel`,
	4: `TextViewHighlight`,
}

// String returns the string representation
// of this TextViewStates value.
func (i TextViewStates) String() string {
	if str, ok := _TextViewStatesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TextViewStates value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextViewStates) SetString(s string) error {
	if val, ok := _TextViewStatesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TextViewStatesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type TextViewStates")
}

// Int64 returns the TextViewStates value as an int64.
func (i TextViewStates) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextViewStates value from an int64.
func (i *TextViewStates) SetInt64(in int64) {
	*i = TextViewStates(in)
}

// Desc returns the description of the TextViewStates value.
func (i TextViewStates) Desc() string {
	if str, ok := _TextViewStatesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TextViewStatesValues returns all possible values
// for the type TextViewStates.
func TextViewStatesValues() []TextViewStates {
	return _TextViewStatesValues
}

// Values returns all possible values
// for the type TextViewStates.
func (i TextViewStates) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TextViewStatesValues))
	for i, d := range _TextViewStatesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextViewStates.
func (i TextViewStates) IsValid() bool {
	_, ok := _TextViewStatesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextViewStates) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextViewStates) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextViewFlagsValues = []TextViewFlags{10, 11, 12, 13, 14, 15, 16}

// TextViewFlagsN is the highest valid value
// for type TextViewFlags, plus one.
const TextViewFlagsN TextViewFlags = 17

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextViewFlagsNoOp() {
	var x [1]struct{}
	_ = x[TextViewNeedsRefresh-(10)]
	_ = x[TextViewInReLayout-(11)]
	_ = x[TextViewRenderScrolls-(12)]
	_ = x[TextViewFocusActive-(13)]
	_ = x[TextViewHasLineNos-(14)]
	_ = x[TextViewLastWasTabAI-(15)]
	_ = x[TextViewLastWasUndo-(16)]
}

var _TextViewFlagsNameToValueMap = map[string]TextViewFlags{
	`TextViewNeedsRefresh`:  10,
	`textviewneedsrefresh`:  10,
	`TextViewInReLayout`:    11,
	`textviewinrelayout`:    11,
	`TextViewRenderScrolls`: 12,
	`textviewrenderscrolls`: 12,
	`TextViewFocusActive`:   13,
	`textviewfocusactive`:   13,
	`TextViewHasLineNos`:    14,
	`textviewhaslinenos`:    14,
	`TextViewLastWasTabAI`:  15,
	`textviewlastwastabai`:  15,
	`TextViewLastWasUndo`:   16,
	`textviewlastwasundo`:   16,
}

var _TextViewFlagsDescMap = map[TextViewFlags]string{
	10: `TextViewNeedsRefresh indicates when refresh is required`,
	11: `TextViewInReLayout indicates that we are currently resizing ourselves via parent layout`,
	12: `TextViewRenderScrolls indicates that parent layout scrollbars need to be re-rendered at next rerender`,
	13: `TextViewFocusActive is set if the keyboard focus is active -- when we lose active focus we apply changes`,
	14: `TextViewHasLineNos indicates that this view has line numbers (per TextBuf option)`,
	15: `TextViewLastWasTabAI indicates that last key was a Tab auto-indent`,
	16: `TextViewLastWasUndo indicates that last key was an undo`,
}

var _TextViewFlagsMap = map[TextViewFlags]string{
	10: `TextViewNeedsRefresh`,
	11: `TextViewInReLayout`,
	12: `TextViewRenderScrolls`,
	13: `TextViewFocusActive`,
	14: `TextViewHasLineNos`,
	15: `TextViewLastWasTabAI`,
	16: `TextViewLastWasUndo`,
}

// String returns the string representation
// of this TextViewFlags value.
func (i TextViewFlags) String() string {
	str := ""
	for _, ie := range ki.FlagsValues() {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	for _, ie := range _TextViewFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this TextViewFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i TextViewFlags) BitIndexString() string {
	if str, ok := _TextViewFlagsMap[i]; ok {
		return str
	}
	return ki.Flags(i).BitIndexString()
}

// SetString sets the TextViewFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextViewFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the TextViewFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *TextViewFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _TextViewFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _TextViewFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			err := (*ki.Flags)(i).SetStringOr(flg)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Int64 returns the TextViewFlags value as an int64.
func (i TextViewFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextViewFlags value from an int64.
func (i *TextViewFlags) SetInt64(in int64) {
	*i = TextViewFlags(in)
}

// Desc returns the description of the TextViewFlags value.
func (i TextViewFlags) Desc() string {
	if str, ok := _TextViewFlagsDescMap[i]; ok {
		return str
	}
	return ki.Flags(i).Desc()
}

// TextViewFlagsValues returns all possible values
// for the type TextViewFlags.
func TextViewFlagsValues() []TextViewFlags {
	es := ki.FlagsValues()
	res := make([]TextViewFlags, len(es))
	for i, e := range es {
		res[i] = TextViewFlags(e)
	}
	res = append(res, _TextViewFlagsValues...)
	return res
}

// Values returns all possible values
// for the type TextViewFlags.
func (i TextViewFlags) Values() []enums.Enum {
	es := ki.FlagsValues()
	les := len(es)
	res := make([]enums.Enum, les+len(_TextViewFlagsValues))
	for i, d := range es {
		res[i] = d
	}
	for i, d := range _TextViewFlagsValues {
		res[i+les] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextViewFlags.
func (i TextViewFlags) IsValid() bool {
	_, ok := _TextViewFlagsMap[i]
	if !ok {
		return ki.Flags(i).IsValid()
	}
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i TextViewFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *TextViewFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextViewFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextViewFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TreeViewSignalsValues = []TreeViewSignals{0, 1, 2, 3, 4, 5, 6, 7, 8}

// TreeViewSignalsN is the highest valid value
// for type TreeViewSignals, plus one.
const TreeViewSignalsN TreeViewSignals = 9

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TreeViewSignalsNoOp() {
	var x [1]struct{}
	_ = x[TreeViewSelected-(0)]
	_ = x[TreeViewUnselected-(1)]
	_ = x[TreeViewAllSelected-(2)]
	_ = x[TreeViewAllUnselected-(3)]
	_ = x[TreeViewOpened-(4)]
	_ = x[TreeViewClosed-(5)]
	_ = x[TreeViewChanged-(6)]
	_ = x[TreeViewInserted-(7)]
	_ = x[TreeViewDeleted-(8)]
}

var _TreeViewSignalsNameToValueMap = map[string]TreeViewSignals{
	`TreeViewSelected`:      0,
	`treeviewselected`:      0,
	`TreeViewUnselected`:    1,
	`treeviewunselected`:    1,
	`TreeViewAllSelected`:   2,
	`treeviewallselected`:   2,
	`TreeViewAllUnselected`: 3,
	`treeviewallunselected`: 3,
	`TreeViewOpened`:        4,
	`treeviewopened`:        4,
	`TreeViewClosed`:        5,
	`treeviewclosed`:        5,
	`TreeViewChanged`:       6,
	`treeviewchanged`:       6,
	`TreeViewInserted`:      7,
	`treeviewinserted`:      7,
	`TreeViewDeleted`:       8,
	`treeviewdeleted`:       8,
}

var _TreeViewSignalsDescMap = map[TreeViewSignals]string{
	0: `node was selected`,
	1: `TreeView unselected`,
	2: `TreeView all items were selected`,
	3: `TreeView all items were unselected`,
	4: `closed TreeView was opened`,
	5: `open TreeView was closed -- children not visible`,
	6: `means that some kind of edit operation has taken place by the user via the gui -- we don&#39;t track the details, just that changes have happened`,
	7: `a node was inserted into the tree (Paste, DND) in this case, the data is the *source node* that was inserted`,
	8: `a node was deleted from the tree (Cut, DND Move)`,
}

var _TreeViewSignalsMap = map[TreeViewSignals]string{
	0: `TreeViewSelected`,
	1: `TreeViewUnselected`,
	2: `TreeViewAllSelected`,
	3: `TreeViewAllUnselected`,
	4: `TreeViewOpened`,
	5: `TreeViewClosed`,
	6: `TreeViewChanged`,
	7: `TreeViewInserted`,
	8: `TreeViewDeleted`,
}

// String returns the string representation
// of this TreeViewSignals value.
func (i TreeViewSignals) String() string {
	if str, ok := _TreeViewSignalsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TreeViewSignals value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TreeViewSignals) SetString(s string) error {
	if val, ok := _TreeViewSignalsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TreeViewSignalsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type TreeViewSignals")
}

// Int64 returns the TreeViewSignals value as an int64.
func (i TreeViewSignals) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TreeViewSignals value from an int64.
func (i *TreeViewSignals) SetInt64(in int64) {
	*i = TreeViewSignals(in)
}

// Desc returns the description of the TreeViewSignals value.
func (i TreeViewSignals) Desc() string {
	if str, ok := _TreeViewSignalsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TreeViewSignalsValues returns all possible values
// for the type TreeViewSignals.
func TreeViewSignalsValues() []TreeViewSignals {
	return _TreeViewSignalsValues
}

// Values returns all possible values
// for the type TreeViewSignals.
func (i TreeViewSignals) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TreeViewSignalsValues))
	for i, d := range _TreeViewSignalsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TreeViewSignals.
func (i TreeViewSignals) IsValid() bool {
	_, ok := _TreeViewSignalsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TreeViewSignals) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TreeViewSignals) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TreeViewFlagsValues = []TreeViewFlags{10, 11, 12, 13}

// TreeViewFlagsN is the highest valid value
// for type TreeViewFlags, plus one.
const TreeViewFlagsN TreeViewFlags = 14

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TreeViewFlagsNoOp() {
	var x [1]struct{}
	_ = x[TreeViewFlagClosed-(10)]
	_ = x[TreeViewFlagChanged-(11)]
	_ = x[TreeViewFlagNoTemplate-(12)]
	_ = x[TreeViewFlagUpdtRoot-(13)]
}

var _TreeViewFlagsNameToValueMap = map[string]TreeViewFlags{
	`TreeViewFlagClosed`:     10,
	`treeviewflagclosed`:     10,
	`TreeViewFlagChanged`:    11,
	`treeviewflagchanged`:    11,
	`TreeViewFlagNoTemplate`: 12,
	`treeviewflagnotemplate`: 12,
	`TreeViewFlagUpdtRoot`:   13,
	`treeviewflagupdtroot`:   13,
}

var _TreeViewFlagsDescMap = map[TreeViewFlags]string{
	10: `TreeViewFlagClosed means node is toggled closed (children not visible)`,
	11: `TreeViewFlagChanged is updated on the root node whenever a gui edit is made through the tree view on the tree -- this does not track any other changes that might have occurred in the tree itself. Also emits a TreeViewChanged signal on the root node.`,
	12: `TreeViewFlagNoTemplate -- this node is not using a style template -- should be restyled on any full re-render change`,
	13: `TreeViewFlagUpdtRoot -- for any update signal that comes from the source root node, do a full update of the treeview. This increases responsiveness of the updating and makes it easy to trigger a full update by updating the root node, but can be slower when not needed`,
}

var _TreeViewFlagsMap = map[TreeViewFlags]string{
	10: `TreeViewFlagClosed`,
	11: `TreeViewFlagChanged`,
	12: `TreeViewFlagNoTemplate`,
	13: `TreeViewFlagUpdtRoot`,
}

// String returns the string representation
// of this TreeViewFlags value.
func (i TreeViewFlags) String() string {
	str := ""
	for _, ie := range ki.FlagsValues() {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	for _, ie := range _TreeViewFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this TreeViewFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i TreeViewFlags) BitIndexString() string {
	if str, ok := _TreeViewFlagsMap[i]; ok {
		return str
	}
	return ki.Flags(i).BitIndexString()
}

// SetString sets the TreeViewFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TreeViewFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the TreeViewFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *TreeViewFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _TreeViewFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _TreeViewFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			err := (*ki.Flags)(i).SetStringOr(flg)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Int64 returns the TreeViewFlags value as an int64.
func (i TreeViewFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TreeViewFlags value from an int64.
func (i *TreeViewFlags) SetInt64(in int64) {
	*i = TreeViewFlags(in)
}

// Desc returns the description of the TreeViewFlags value.
func (i TreeViewFlags) Desc() string {
	if str, ok := _TreeViewFlagsDescMap[i]; ok {
		return str
	}
	return ki.Flags(i).Desc()
}

// TreeViewFlagsValues returns all possible values
// for the type TreeViewFlags.
func TreeViewFlagsValues() []TreeViewFlags {
	es := ki.FlagsValues()
	res := make([]TreeViewFlags, len(es))
	for i, e := range es {
		res[i] = TreeViewFlags(e)
	}
	res = append(res, _TreeViewFlagsValues...)
	return res
}

// Values returns all possible values
// for the type TreeViewFlags.
func (i TreeViewFlags) Values() []enums.Enum {
	es := ki.FlagsValues()
	les := len(es)
	res := make([]enums.Enum, les+len(_TreeViewFlagsValues))
	for i, d := range es {
		res[i] = d
	}
	for i, d := range _TreeViewFlagsValues {
		res[i+les] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TreeViewFlags.
func (i TreeViewFlags) IsValid() bool {
	_, ok := _TreeViewFlagsMap[i]
	if !ok {
		return ki.Flags(i).IsValid()
	}
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i TreeViewFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *TreeViewFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TreeViewFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TreeViewFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TreeViewStatesValues = []TreeViewStates{0, 1, 2, 3}

// TreeViewStatesN is the highest valid value
// for type TreeViewStates, plus one.
const TreeViewStatesN TreeViewStates = 4

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TreeViewStatesNoOp() {
	var x [1]struct{}
	_ = x[TreeViewActive-(0)]
	_ = x[TreeViewSel-(1)]
	_ = x[TreeViewFocus-(2)]
	_ = x[TreeViewInactive-(3)]
}

var _TreeViewStatesNameToValueMap = map[string]TreeViewStates{
	`TreeViewActive`:   0,
	`treeviewactive`:   0,
	`TreeViewSel`:      1,
	`treeviewsel`:      1,
	`TreeViewFocus`:    2,
	`treeviewfocus`:    2,
	`TreeViewInactive`: 3,
	`treeviewinactive`: 3,
}

var _TreeViewStatesDescMap = map[TreeViewStates]string{
	0: `TreeViewActive is normal state -- there but not being interacted with`,
	1: `TreeViewSel is selected`,
	2: `TreeViewFocus is in focus -- will respond to keyboard input`,
	3: `TreeViewInactive is inactive -- if SrcNode is nil, or source has &#34;inactive&#34; property set, or treeview node has inactive property set directly`,
}

var _TreeViewStatesMap = map[TreeViewStates]string{
	0: `TreeViewActive`,
	1: `TreeViewSel`,
	2: `TreeViewFocus`,
	3: `TreeViewInactive`,
}

// String returns the string representation
// of this TreeViewStates value.
func (i TreeViewStates) String() string {
	if str, ok := _TreeViewStatesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TreeViewStates value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TreeViewStates) SetString(s string) error {
	if val, ok := _TreeViewStatesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TreeViewStatesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type TreeViewStates")
}

// Int64 returns the TreeViewStates value as an int64.
func (i TreeViewStates) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TreeViewStates value from an int64.
func (i *TreeViewStates) SetInt64(in int64) {
	*i = TreeViewStates(in)
}

// Desc returns the description of the TreeViewStates value.
func (i TreeViewStates) Desc() string {
	if str, ok := _TreeViewStatesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TreeViewStatesValues returns all possible values
// for the type TreeViewStates.
func TreeViewStatesValues() []TreeViewStates {
	return _TreeViewStatesValues
}

// Values returns all possible values
// for the type TreeViewStates.
func (i TreeViewStates) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TreeViewStatesValues))
	for i, d := range _TreeViewStatesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TreeViewStates.
func (i TreeViewStates) IsValid() bool {
	_, ok := _TreeViewStatesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TreeViewStates) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TreeViewStates) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}
