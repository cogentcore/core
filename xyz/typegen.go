// Code generated by "core generate -add-types"; DO NOT EDIT.

package xyz

import (
	"image"
	"image/color"

	"cogentcore.org/core/math32"
	"cogentcore.org/core/tree"
	"cogentcore.org/core/types"
)

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.BBox", IDName: "b-box", Doc: "BBox contains bounding box and other gross solid properties", Fields: []types.Field{{Name: "BBox", Doc: "bounding box in local coords"}, {Name: "BSphere", Doc: "bounding sphere in local coords"}, {Name: "Area", Doc: "area"}, {Name: "Volume", Doc: "volume"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Camera", IDName: "camera", Doc: "Camera defines the properties of the camera", Fields: []types.Field{{Name: "Pose", Doc: "overall orientation and direction of the camera, relative to pointing at negative Z axis with up (positive Y) direction"}, {Name: "Target", Doc: "target location for the camera -- where it is pointing at -- defaults to the origin, but moves with panning movements, and is reset by a call to LookAt method"}, {Name: "UpDir", Doc: "up direction for camera -- which way is up -- defaults to positive Y axis, and is reset by call to LookAt method"}, {Name: "Ortho", Doc: "default is a Perspective camera -- set this to make it Orthographic instead, in which case the view includes the volume specified by the Near - Far distance (i.e., you probably want to decrease Far)."}, {Name: "FOV", Doc: "field of view in degrees"}, {Name: "Aspect", Doc: "aspect ratio (width/height)"}, {Name: "Near", Doc: "near plane z coordinate"}, {Name: "Far", Doc: "far plane z coordinate"}, {Name: "ViewMatrix", Doc: "view matrix (inverse of the Pose.Matrix)"}, {Name: "ProjectionMatrix", Doc: "projection matrix, defining the camera perspective / ortho transform"}, {Name: "VkProjectionMatrix", Doc: "vulkan projection matrix -- required for vgpu -- produces same effect as ProjectionMatrix, which should be used for all other math"}, {Name: "InvProjectionMatrix", Doc: "inverse of the projection matrix"}, {Name: "Frustum", Doc: "frustum of projection -- viewable space defined by 6 planes of a pyrammidal shape"}}})

// GroupType is the [types.Type] for [Group]
var GroupType = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Group", IDName: "group", Doc: "Group collects individual elements in a scene but does not have a Mesh or Material of\nits own.  It does have a transform that applies to all nodes under it.", Embeds: []types.Field{{Name: "NodeBase"}}, Instance: &Group{}})

// NewGroup returns a new [Group] with the given optional parent:
// Group collects individual elements in a scene but does not have a Mesh or Material of
// its own.  It does have a transform that applies to all nodes under it.
func NewGroup(parent ...tree.Node) *Group { return tree.New[*Group](parent...) }

// NodeType returns the [*types.Type] of [Group]
func (t *Group) NodeType() *types.Type { return GroupType }

// New returns a new [*Group] value
func (t *Group) New() tree.Node { return &Group{} }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.SolidPoint", IDName: "solid-point", Doc: "SolidPoint contains a Solid and a Point on that solid", Fields: []types.Field{{Name: "Solid"}, {Name: "Point"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Decoder", IDName: "decoder", Doc: "Decoder parses 3D object / scene file(s) and imports into a Group or Scene.\nThis interface is implemented by the different format-specific decoders."})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Light", IDName: "light", Doc: "Light represents a light that illuminates a scene.\nThese are stored on the [Scene] object and not within the tree."})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.LightBase", IDName: "light-base", Doc: "LightBase provides the core implementation of the [Light] interface.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"--setters"}}}, Fields: []types.Field{{Name: "Name", Doc: "Name is the name of the light, which matters since lights are accessed by name."}, {Name: "On", Doc: "On is whether the light is turned on. TODO: support this being false."}, {Name: "Lumens", Doc: "Lumens is the brightness/intensity/strength of the light in normalized 0-1 units.\nIt is just multiplied by the color, and is convenient for easily modulating overall brightness."}, {Name: "Color", Doc: "Color is the color of the light at full intensity."}}})

// SetName sets the [LightBase.Name]:
// Name is the name of the light, which matters since lights are accessed by name.
func (t *LightBase) SetName(v string) *LightBase { t.Name = v; return t }

// SetOn sets the [LightBase.On]:
// On is whether the light is turned on. TODO: support this being false.
func (t *LightBase) SetOn(v bool) *LightBase { t.On = v; return t }

// SetLumens sets the [LightBase.Lumens]:
// Lumens is the brightness/intensity/strength of the light in normalized 0-1 units.
// It is just multiplied by the color, and is convenient for easily modulating overall brightness.
func (t *LightBase) SetLumens(v float32) *LightBase { t.Lumens = v; return t }

// SetColor sets the [LightBase.Color]:
// Color is the color of the light at full intensity.
func (t *LightBase) SetColor(v color.RGBA) *LightBase { t.Color = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.AmbientLight", IDName: "ambient-light", Doc: "AmbientLight provides diffuse uniform lighting; typically only one of these in a [Scene].", Embeds: []types.Field{{Name: "LightBase"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.DirLight", IDName: "dir-light", Doc: "DirLight is directional light, which is assumed to project light toward\nthe origin based on its position, with no attenuation, like the Sun.\nFor rendering, the position is negated and normalized to get the direction\nvector (i.e., absolute distance doesn't matter)", Embeds: []types.Field{{Name: "LightBase"}}, Fields: []types.Field{{Name: "Pos", Doc: "position of direct light -- assumed to point at the origin so this determines direction"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.PointLight", IDName: "point-light", Doc: "PointLight is an omnidirectional light with a position\nand associated decay factors, which divide the light intensity as a function of\nlinear and quadratic distance.  The quadratic factor dominates at longer distances.", Embeds: []types.Field{{Name: "LightBase"}}, Fields: []types.Field{{Name: "Pos", Doc: "position of light in world coordinates"}, {Name: "LinDecay", Doc: "Distance linear decay factor -- defaults to .1"}, {Name: "QuadDecay", Doc: "Distance quadratic decay factor -- defaults to .01 -- dominates at longer distances"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.SpotLight", IDName: "spot-light", Doc: "Spotlight is a light with a position and direction and associated decay factors and angles.\nwhich divide the light intensity as a function of linear and quadratic distance.\nThe quadratic factor dominates at longer distances.", Embeds: []types.Field{{Name: "LightBase"}}, Fields: []types.Field{{Name: "Pose"}, {Name: "AngDecay", Doc: "Angular decay factor -- defaults to 15"}, {Name: "CutoffAngle", Doc: "Cut off angle (in degrees) -- defaults to 45 -- max of 90"}, {Name: "LinDecay", Doc: "Distance linear decay factor -- defaults to .01"}, {Name: "QuadDecay", Doc: "Distance quadratic decay factor -- defaults to .001 -- dominates at longer distances"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.LightColors", IDName: "light-colors", Doc: "LightColors are standard light colors for different light sources"})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Lines", IDName: "lines", Doc: "Lines are lines rendered as long thin boxes defined by points\nand width parameters.  The Mesh must be drawn in the XY plane (i.e., use Z = 0\nor a constant unless specifically relevant to have full 3D variation).\nRotate the solid to put into other planes.", Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Points", Doc: "line points (must be 2 or more)"}, {Name: "Width", Doc: "line width, Y = height perpendicular to line direction, and X = depth"}, {Name: "Colors", Doc: "optional colors for each point -- actual color interpolates between"}, {Name: "Closed", Doc: "if true, connect the first and last points to form a closed shape"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Tiling", IDName: "tiling", Doc: "Tiling are the texture tiling parameters", Fields: []types.Field{{Name: "Repeat", Doc: "how often to repeat the texture in each direction"}, {Name: "Off", Doc: "offset for when to start the texure in each direction"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Material", IDName: "material", Doc: "Material describes the material properties of a surface (colors, shininess, texture)\ni.e., phong lighting parameters.\nMain color is used for both ambient and diffuse color, and alpha component\nis used for opacity.  The Emissive color is only for glowing objects.\nThe Specular color is always white (multiplied by light color).\nTextures are stored on the Scene and accessed by name", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Fields: []types.Field{{Name: "Color", Doc: "Color is the main color of surface, used for both ambient and diffuse color in standard Phong model -- alpha component determines transparency -- note that transparent objects require more complex rendering"}, {Name: "Emissive", Doc: "Emissive is the color that surface emits independent of any lighting -- i.e., glow -- can be used for marking lights with an object"}, {Name: "Shiny", Doc: "Shiny is the specular shininess factor -- how focally vs. broad the surface shines back directional light -- this is an exponential factor, with 0 = very broad diffuse reflection, and higher values (typically max of 128 or so but can go higher) having a smaller more focal specular reflection.  Also set Reflective factor to change overall shininess effect."}, {Name: "Reflective", Doc: "Reflective is the specular reflectiveness factor -- how much it shines back directional light.  The specular reflection color is always white * the incoming light."}, {Name: "Bright", Doc: "Bright is an overall multiplier on final computed color value -- can be used to tune the overall brightness of various surfaces relative to each other for a given set of lighting parameters"}, {Name: "TextureName", Doc: "TextureName is the name of the texture to provide color for the surface."}, {Name: "Tiling", Doc: "Tiling is the texture tiling parameters: repeat and offset."}, {Name: "CullBack", Doc: "CullBack indicates to cull the back-facing surfaces."}, {Name: "CullFront", Doc: "CullFront indicates to cull the front-facing surfaces."}, {Name: "Texture", Doc: "Texture is the cached [Texture] object set based on [Material.TextureName]."}}})

// SetColor sets the [Material.Color]:
// Color is the main color of surface, used for both ambient and diffuse color in standard Phong model -- alpha component determines transparency -- note that transparent objects require more complex rendering
func (t *Material) SetColor(v color.RGBA) *Material { t.Color = v; return t }

// SetEmissive sets the [Material.Emissive]:
// Emissive is the color that surface emits independent of any lighting -- i.e., glow -- can be used for marking lights with an object
func (t *Material) SetEmissive(v color.RGBA) *Material { t.Emissive = v; return t }

// SetShiny sets the [Material.Shiny]:
// Shiny is the specular shininess factor -- how focally vs. broad the surface shines back directional light -- this is an exponential factor, with 0 = very broad diffuse reflection, and higher values (typically max of 128 or so but can go higher) having a smaller more focal specular reflection.  Also set Reflective factor to change overall shininess effect.
func (t *Material) SetShiny(v float32) *Material { t.Shiny = v; return t }

// SetReflective sets the [Material.Reflective]:
// Reflective is the specular reflectiveness factor -- how much it shines back directional light.  The specular reflection color is always white * the incoming light.
func (t *Material) SetReflective(v float32) *Material { t.Reflective = v; return t }

// SetBright sets the [Material.Bright]:
// Bright is an overall multiplier on final computed color value -- can be used to tune the overall brightness of various surfaces relative to each other for a given set of lighting parameters
func (t *Material) SetBright(v float32) *Material { t.Bright = v; return t }

// SetTiling sets the [Material.Tiling]:
// Tiling is the texture tiling parameters: repeat and offset.
func (t *Material) SetTiling(v Tiling) *Material { t.Tiling = v; return t }

// SetCullBack sets the [Material.CullBack]:
// CullBack indicates to cull the back-facing surfaces.
func (t *Material) SetCullBack(v bool) *Material { t.CullBack = v; return t }

// SetCullFront sets the [Material.CullFront]:
// CullFront indicates to cull the front-facing surfaces.
func (t *Material) SetCullFront(v bool) *Material { t.CullFront = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.MeshName", IDName: "mesh-name", Doc: "MeshName is a [Mesh] name. This type provides an automatic GUI chooser for meshes.\nIt is used on [Solid] to link to meshes by name."})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Mesh", IDName: "mesh", Doc: "Mesh parametrizes the mesh-based shape used for rendering a [Solid].\nOnly indexed triangle meshes are supported.\nAll Meshes must know in advance the number of vertex and index points\nthey require, and the SetVertices method operates on data from the\nvgpu staging buffer to set the relevant data post-allocation.\nThe vgpu vshape library is used for all basic shapes, and it follows\nthis same logic.\nPer-vertex Color is optional, as is the ability to update the data\nafter initial SetVertices call (default is to do nothing)."})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.MeshBase", IDName: "mesh-base", Doc: "MeshBase provides the core implementation of the [Mesh] interface.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Fields: []types.Field{{Name: "Name", Doc: "Name is the name of the mesh. [Mesh]es are linked to [Solid]s\nby name so this matters."}, {Name: "NumVertex", Doc: "NumVertex is the number of [math32.Vector3] vertex points. This always\nincludes [math32.Vector3] normals and [math32.Vector2] texture coordinates.\nThis is only valid after [Mesh.Sizes] has been called."}, {Name: "NumIndex", Doc: "NumIndex is the number of [math32.ArrayU32] indexes.\nThis is only valid after [Mesh.Sizes] has been called."}, {Name: "HasColor", Doc: "HasColor is whether the mesh has per-vertex colors\nas [math32.Vector4] per vertex."}, {Name: "Dynamic", Doc: "Dynamic is whether this mesh changes frequently;\notherwise considered to be static."}, {Name: "Transparent", Doc: "Transparent is whether the color has transparency;\nnot worth checking manually. This is only valid if\n[MeshBase.HasColor] is true."}, {Name: "BBox", Doc: "BBox has the computed bounding-box and other gross solid properties."}}})

// SetName sets the [MeshBase.Name]:
// Name is the name of the mesh. [Mesh]es are linked to [Solid]s
// by name so this matters.
func (t *MeshBase) SetName(v string) *MeshBase { t.Name = v; return t }

// SetHasColor sets the [MeshBase.HasColor]:
// HasColor is whether the mesh has per-vertex colors
// as [math32.Vector4] per vertex.
func (t *MeshBase) SetHasColor(v bool) *MeshBase { t.HasColor = v; return t }

// SetDynamic sets the [MeshBase.Dynamic]:
// Dynamic is whether this mesh changes frequently;
// otherwise considered to be static.
func (t *MeshBase) SetDynamic(v bool) *MeshBase { t.Dynamic = v; return t }

// SetTransparent sets the [MeshBase.Transparent]:
// Transparent is whether the color has transparency;
// not worth checking manually. This is only valid if
// [MeshBase.HasColor] is true.
func (t *MeshBase) SetTransparent(v bool) *MeshBase { t.Transparent = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.GenMesh", IDName: "gen-mesh", Doc: "GenMesh is a generic, arbitrary Mesh, storing its values", Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Vertex"}, {Name: "Norm"}, {Name: "Texture"}, {Name: "Color"}, {Name: "Index"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Node", IDName: "node", Doc: "Node is the common interface for all xyz 3D tree nodes.\n[Solid] and [Group] are the two main types of nodes,\nwhich both extend [NodeBase] for the core functionality."})

// NodeBaseType is the [types.Type] for [NodeBase]
var NodeBaseType = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.NodeBase", IDName: "node-base", Doc: "NodeBase is the basic 3D tree node, which has the full transform information\nrelative to parent, and computed bounding boxes, etc.\nIt implements the [Node] interface and contains the core functionality\ncommon to all 3D nodes.", Embeds: []types.Field{{Name: "NodeBase"}}, Fields: []types.Field{{Name: "Invisible", Doc: "Invisible is whether this node is invisible."}, {Name: "Pose", Doc: "Pose is the complete specification of position and orientation."}, {Name: "Scene", Doc: "Scene is the cached [Scene]."}, {Name: "MeshBBox", Doc: "mesh-based local bounding box (aggregated for groups)"}, {Name: "WorldBBox", Doc: "world coordinates bounding box"}, {Name: "NDCBBox", Doc: "normalized display coordinates bounding box, used for frustrum clipping"}, {Name: "BBox", Doc: "raw original bounding box for the widget within its parent Scene.\nThis is prior to intersecting with Frame bounds."}, {Name: "SceneBBox", Doc: "2D bounding box for region occupied within Scene Frame that we render onto.\nThis is BBox intersected with Frame bounds."}}, Instance: &NodeBase{}})

// NewNodeBase returns a new [NodeBase] with the given optional parent:
// NodeBase is the basic 3D tree node, which has the full transform information
// relative to parent, and computed bounding boxes, etc.
// It implements the [Node] interface and contains the core functionality
// common to all 3D nodes.
func NewNodeBase(parent ...tree.Node) *NodeBase { return tree.New[*NodeBase](parent...) }

// NodeType returns the [*types.Type] of [NodeBase]
func (t *NodeBase) NodeType() *types.Type { return NodeBaseType }

// New returns a new [*NodeBase] value
func (t *NodeBase) New() tree.Node { return &NodeBase{} }

// SetInvisible sets the [NodeBase.Invisible]:
// Invisible is whether this node is invisible.
func (t *NodeBase) SetInvisible(v bool) *NodeBase { t.Invisible = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Pose", IDName: "pose", Doc: "Pose contains the full specification of position and orientation,\nalways relevant to the parent element.", Fields: []types.Field{{Name: "Pos", Doc: "position of center of element (relative to parent)"}, {Name: "Scale", Doc: "scale (relative to parent)"}, {Name: "Quat", Doc: "Node rotation specified as a Quat (relative to parent)"}, {Name: "Matrix", Doc: "Local matrix. Contains all position/rotation/scale information (relative to parent)"}, {Name: "ParMatrix", Doc: "Parent's world matrix -- we cache this so that we can independently update our own matrix"}, {Name: "WorldMatrix", Doc: "World matrix. Contains all absolute position/rotation/scale information (i.e. relative to very top parent, generally the scene)"}, {Name: "MVMatrix", Doc: "model * view matrix -- tranforms into camera-centered coords"}, {Name: "MVPMatrix", Doc: "model * view * projection matrix -- full final render matrix"}, {Name: "NormMatrix", Doc: "normal matrix has no offsets, for normal vector rotation only, based on MVMatrix"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.RenderClasses", IDName: "render-classes", Doc: "RenderClasses define the different classes of rendering"})

// SceneType is the [types.Type] for [Scene]
var SceneType = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Scene", IDName: "scene", Doc: "Scene is the overall scenegraph containing nodes as children.\nIt renders to its own vgpu.RenderFrame.\nThe Image of this Frame is usable directly or, via xyzcore.Scene,\nwhere it is copied into an overall core.Scene image.\n\nThere is default navigation event processing (disabled by setting NoNav)\nwhere mouse drag events Orbit the camera (Shift = Pan, Alt = PanTarget)\nand arrow keys do Orbit, Pan, PanTarget with same key modifiers.\nSpacebar restores original \"default\" camera, and numbers save (1st time)\nor restore (subsequently) camera views (Control = always save)\n\nA Group at the top-level named \"TrackCamera\" will automatically track\nthe camera (i.e., its Pose is copied) -- Solids in that group can\nset their relative Pos etc to display relative to the camera, to achieve\n\"first person\" effects.", Embeds: []types.Field{{Name: "NodeBase"}}, Fields: []types.Field{{Name: "BackgroundColor", Doc: "BackgroundColor is the background color of the scene,\nwhich is used directly as an RGB color in Vulkan."}, {Name: "NeedsConfig", Doc: "NeedsConfig means that a GPU resource (Lights, Texture, Meshes,\nor more complex Nodes that require ConfigNodes) has been changed\nand a Config call is required."}, {Name: "NeedsUpdate", Doc: "NeedsUpdate means that Node Pose has changed and an update pass\nis required to update matrix and bounding boxes."}, {Name: "NeedsRender", Doc: "NeedsRender means that something has been updated (minimally the\nCamera pose) and a new Render is required."}, {Name: "Geom", Doc: "Viewport-level viewbox within any parent Viewport2D"}, {Name: "MultiSample", Doc: "number of samples in multisampling -- must be a power of 2, and must be 1 if grabbing the Depth buffer back from the RenderFrame"}, {Name: "Wireframe", Doc: "render using wireframe instead of filled polygons -- this must be set prior to configuring the Phong rendering system (i.e., just after Scene is made)"}, {Name: "Camera", Doc: "camera determines view onto scene"}, {Name: "Lights", Doc: "all lights used in the scene"}, {Name: "Meshes", Doc: "meshes -- holds all the mesh data -- must be configured prior to rendering"}, {Name: "Textures", Doc: "textures -- must be configured prior to rendering -- a maximum of 16 textures is supported for full cross-platform portability"}, {Name: "Library", Doc: "library of objects that can be used in the scene"}, {Name: "NoNav", Doc: "don't activate the standard navigation keyboard and mouse event processing to move around the camera in the scene"}, {Name: "SavedCams", Doc: "saved cameras -- can Save and Set these to view the scene from different angles"}, {Name: "Phong", Doc: "the vphong rendering system"}, {Name: "Frame", Doc: "the vgpu render frame holding the rendered scene"}, {Name: "imgCopy", Doc: "image used to hold a copy of the Frame image, for ImageCopy() call.\nThis is re-used across calls to avoid large memory allocations,\nso it will automatically update after every ImageCopy call.\nIf a persistent image is required, call [iox/imagex.CloneAsRGBA]."}}, Instance: &Scene{}})

// NewScene returns a new [Scene] with the given optional parent:
// Scene is the overall scenegraph containing nodes as children.
// It renders to its own vgpu.RenderFrame.
// The Image of this Frame is usable directly or, via xyzcore.Scene,
// where it is copied into an overall core.Scene image.
//
// There is default navigation event processing (disabled by setting NoNav)
// where mouse drag events Orbit the camera (Shift = Pan, Alt = PanTarget)
// and arrow keys do Orbit, Pan, PanTarget with same key modifiers.
// Spacebar restores original "default" camera, and numbers save (1st time)
// or restore (subsequently) camera views (Control = always save)
//
// A Group at the top-level named "TrackCamera" will automatically track
// the camera (i.e., its Pose is copied) -- Solids in that group can
// set their relative Pos etc to display relative to the camera, to achieve
// "first person" effects.
func NewScene(parent ...tree.Node) *Scene { return tree.New[*Scene](parent...) }

// NodeType returns the [*types.Type] of [Scene]
func (t *Scene) NodeType() *types.Type { return SceneType }

// New returns a new [*Scene] value
func (t *Scene) New() tree.Node { return &Scene{} }

// SetBackgroundColor sets the [Scene.BackgroundColor]:
// BackgroundColor is the background color of the scene,
// which is used directly as an RGB color in Vulkan.
func (t *Scene) SetBackgroundColor(v color.RGBA) *Scene { t.BackgroundColor = v; return t }

// SetMultiSample sets the [Scene.MultiSample]:
// number of samples in multisampling -- must be a power of 2, and must be 1 if grabbing the Depth buffer back from the RenderFrame
func (t *Scene) SetMultiSample(v int) *Scene { t.MultiSample = v; return t }

// SetWireframe sets the [Scene.Wireframe]:
// render using wireframe instead of filled polygons -- this must be set prior to configuring the Phong rendering system (i.e., just after Scene is made)
func (t *Scene) SetWireframe(v bool) *Scene { t.Wireframe = v; return t }

// SetNoNav sets the [Scene.NoNav]:
// don't activate the standard navigation keyboard and mouse event processing to move around the camera in the scene
func (t *Scene) SetNoNav(v bool) *Scene { t.NoNav = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Plane", IDName: "plane", Doc: "Plane is a flat 2D plane, which can be oriented along any\naxis facing either positive or negative", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "NormAxis", Doc: "axis along which the normal perpendicular to the plane points.  E.g., if the Y axis is specified, then it is a standard X-Z ground plane -- see also NormNeg for whether it is facing in the positive or negative of the given axis."}, {Name: "NormNeg", Doc: "if false, the plane normal facing in the positive direction along specified NormAxis, otherwise it faces in the negative if true"}, {Name: "Size", Doc: "2D size of plane"}, {Name: "Segs", Doc: "number of segments to divide plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1"}, {Name: "Offset", Doc: "offset from origin along direction of normal to the plane"}}})

// SetNormAxis sets the [Plane.NormAxis]:
// axis along which the normal perpendicular to the plane points.  E.g., if the Y axis is specified, then it is a standard X-Z ground plane -- see also NormNeg for whether it is facing in the positive or negative of the given axis.
func (t *Plane) SetNormAxis(v math32.Dims) *Plane { t.NormAxis = v; return t }

// SetNormNeg sets the [Plane.NormNeg]:
// if false, the plane normal facing in the positive direction along specified NormAxis, otherwise it faces in the negative if true
func (t *Plane) SetNormNeg(v bool) *Plane { t.NormNeg = v; return t }

// SetSize sets the [Plane.Size]:
// 2D size of plane
func (t *Plane) SetSize(v math32.Vector2) *Plane { t.Size = v; return t }

// SetSegs sets the [Plane.Segs]:
// number of segments to divide plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1
func (t *Plane) SetSegs(v math32.Vector2i) *Plane { t.Segs = v; return t }

// SetOffset sets the [Plane.Offset]:
// offset from origin along direction of normal to the plane
func (t *Plane) SetOffset(v float32) *Plane { t.Offset = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Box", IDName: "box", Doc: "Box is a rectangular-shaped solid (cuboid)", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Size", Doc: "size along each dimension"}, {Name: "Segs", Doc: "number of segments to divide each plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1"}}})

// SetSize sets the [Box.Size]:
// size along each dimension
func (t *Box) SetSize(v math32.Vector3) *Box { t.Size = v; return t }

// SetSegs sets the [Box.Segs]:
// number of segments to divide each plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1
func (t *Box) SetSegs(v math32.Vector3i) *Box { t.Segs = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Sphere", IDName: "sphere", Doc: "Sphere is a sphere mesh", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Radius", Doc: "radius of the sphere"}, {Name: "WidthSegs", Doc: "number of segments around the width of the sphere (32 is reasonable default for full circle)"}, {Name: "HeightSegs", Doc: "number of height segments (32 is reasonable default for full height)"}, {Name: "AngStart", Doc: "starting radial angle in degrees, relative to -1,0,0 left side starting point"}, {Name: "AngLen", Doc: "total radial angle to generate in degrees (max = 360)"}, {Name: "ElevStart", Doc: "starting elevation (height) angle in degrees - 0 = top of sphere, and Pi is bottom"}, {Name: "ElevLen", Doc: "total angle to generate in degrees (max = 180)"}}})

// SetRadius sets the [Sphere.Radius]:
// radius of the sphere
func (t *Sphere) SetRadius(v float32) *Sphere { t.Radius = v; return t }

// SetWidthSegs sets the [Sphere.WidthSegs]:
// number of segments around the width of the sphere (32 is reasonable default for full circle)
func (t *Sphere) SetWidthSegs(v int) *Sphere { t.WidthSegs = v; return t }

// SetHeightSegs sets the [Sphere.HeightSegs]:
// number of height segments (32 is reasonable default for full height)
func (t *Sphere) SetHeightSegs(v int) *Sphere { t.HeightSegs = v; return t }

// SetAngStart sets the [Sphere.AngStart]:
// starting radial angle in degrees, relative to -1,0,0 left side starting point
func (t *Sphere) SetAngStart(v float32) *Sphere { t.AngStart = v; return t }

// SetAngLen sets the [Sphere.AngLen]:
// total radial angle to generate in degrees (max = 360)
func (t *Sphere) SetAngLen(v float32) *Sphere { t.AngLen = v; return t }

// SetElevStart sets the [Sphere.ElevStart]:
// starting elevation (height) angle in degrees - 0 = top of sphere, and Pi is bottom
func (t *Sphere) SetElevStart(v float32) *Sphere { t.ElevStart = v; return t }

// SetElevLen sets the [Sphere.ElevLen]:
// total angle to generate in degrees (max = 180)
func (t *Sphere) SetElevLen(v float32) *Sphere { t.ElevLen = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Cylinder", IDName: "cylinder", Doc: "Cylinder is a generalized cylinder shape, including a cone\nor truncated cone by having different size circles at either end.\nHeight is up along the Y axis.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Height", Doc: "height of the cylinder"}, {Name: "TopRad", Doc: "radius of the top -- set to 0 for a cone"}, {Name: "BotRad", Doc: "radius of the bottom"}, {Name: "RadialSegs", Doc: "number of radial segments (32 is a reasonable default for full circle)"}, {Name: "HeightSegs", Doc: "number of height segments"}, {Name: "Top", Doc: "render the top disc"}, {Name: "Bottom", Doc: "render the bottom disc"}, {Name: "AngStart", Doc: "starting angle in degrees, relative to -1,0,0 left side starting point"}, {Name: "AngLen", Doc: "total angle to generate in degrees (max 360)"}}})

// SetHeight sets the [Cylinder.Height]:
// height of the cylinder
func (t *Cylinder) SetHeight(v float32) *Cylinder { t.Height = v; return t }

// SetTopRad sets the [Cylinder.TopRad]:
// radius of the top -- set to 0 for a cone
func (t *Cylinder) SetTopRad(v float32) *Cylinder { t.TopRad = v; return t }

// SetBotRad sets the [Cylinder.BotRad]:
// radius of the bottom
func (t *Cylinder) SetBotRad(v float32) *Cylinder { t.BotRad = v; return t }

// SetRadialSegs sets the [Cylinder.RadialSegs]:
// number of radial segments (32 is a reasonable default for full circle)
func (t *Cylinder) SetRadialSegs(v int) *Cylinder { t.RadialSegs = v; return t }

// SetHeightSegs sets the [Cylinder.HeightSegs]:
// number of height segments
func (t *Cylinder) SetHeightSegs(v int) *Cylinder { t.HeightSegs = v; return t }

// SetTop sets the [Cylinder.Top]:
// render the top disc
func (t *Cylinder) SetTop(v bool) *Cylinder { t.Top = v; return t }

// SetBottom sets the [Cylinder.Bottom]:
// render the bottom disc
func (t *Cylinder) SetBottom(v bool) *Cylinder { t.Bottom = v; return t }

// SetAngStart sets the [Cylinder.AngStart]:
// starting angle in degrees, relative to -1,0,0 left side starting point
func (t *Cylinder) SetAngStart(v float32) *Cylinder { t.AngStart = v; return t }

// SetAngLen sets the [Cylinder.AngLen]:
// total angle to generate in degrees (max 360)
func (t *Cylinder) SetAngLen(v float32) *Cylinder { t.AngLen = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Capsule", IDName: "capsule", Doc: "Capsule is a generalized capsule shape: a cylinder with hemisphere end caps.\nSupports different radii on each end.\nHeight is along the Y axis -- total height is Height + TopRad + BotRad.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Height", Doc: "height of the cylinder portion"}, {Name: "TopRad", Doc: "radius of the top -- set to 0 for a cone"}, {Name: "BotRad", Doc: "radius of the bottom"}, {Name: "RadialSegs", Doc: "number of radial segments (32 is a reasonable default for full circle)"}, {Name: "HeightSegs", Doc: "number of height segments"}, {Name: "CapSegs", Doc: "number of segments in the hemisphere cap ends (16 is a reasonable default)"}, {Name: "AngStart", Doc: "starting angle in degrees, relative to -1,0,0 left side starting point"}, {Name: "AngLen", Doc: "total angle to generate in degrees (max 360)"}}})

// SetHeight sets the [Capsule.Height]:
// height of the cylinder portion
func (t *Capsule) SetHeight(v float32) *Capsule { t.Height = v; return t }

// SetTopRad sets the [Capsule.TopRad]:
// radius of the top -- set to 0 for a cone
func (t *Capsule) SetTopRad(v float32) *Capsule { t.TopRad = v; return t }

// SetBotRad sets the [Capsule.BotRad]:
// radius of the bottom
func (t *Capsule) SetBotRad(v float32) *Capsule { t.BotRad = v; return t }

// SetRadialSegs sets the [Capsule.RadialSegs]:
// number of radial segments (32 is a reasonable default for full circle)
func (t *Capsule) SetRadialSegs(v int) *Capsule { t.RadialSegs = v; return t }

// SetHeightSegs sets the [Capsule.HeightSegs]:
// number of height segments
func (t *Capsule) SetHeightSegs(v int) *Capsule { t.HeightSegs = v; return t }

// SetCapSegs sets the [Capsule.CapSegs]:
// number of segments in the hemisphere cap ends (16 is a reasonable default)
func (t *Capsule) SetCapSegs(v int) *Capsule { t.CapSegs = v; return t }

// SetAngStart sets the [Capsule.AngStart]:
// starting angle in degrees, relative to -1,0,0 left side starting point
func (t *Capsule) SetAngStart(v float32) *Capsule { t.AngStart = v; return t }

// SetAngLen sets the [Capsule.AngLen]:
// total angle to generate in degrees (max 360)
func (t *Capsule) SetAngLen(v float32) *Capsule { t.AngLen = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Torus", IDName: "torus", Doc: "Torus is a torus mesh, defined by the radius of the solid tube and the\nlarger radius of the ring.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Radius", Doc: "larger radius of the torus ring"}, {Name: "TubeRadius", Doc: "radius of the solid tube"}, {Name: "RadialSegs", Doc: "number of segments around the radius of the torus (32 is reasonable default for full circle)"}, {Name: "TubeSegs", Doc: "number of segments for the tube itself (32 is reasonable default for full height)"}, {Name: "AngStart", Doc: "starting radial angle in degrees relative to 1,0,0 starting point"}, {Name: "AngLen", Doc: "total radial angle to generate in degrees (max = 360)"}}})

// SetRadius sets the [Torus.Radius]:
// larger radius of the torus ring
func (t *Torus) SetRadius(v float32) *Torus { t.Radius = v; return t }

// SetTubeRadius sets the [Torus.TubeRadius]:
// radius of the solid tube
func (t *Torus) SetTubeRadius(v float32) *Torus { t.TubeRadius = v; return t }

// SetRadialSegs sets the [Torus.RadialSegs]:
// number of segments around the radius of the torus (32 is reasonable default for full circle)
func (t *Torus) SetRadialSegs(v int) *Torus { t.RadialSegs = v; return t }

// SetTubeSegs sets the [Torus.TubeSegs]:
// number of segments for the tube itself (32 is reasonable default for full height)
func (t *Torus) SetTubeSegs(v int) *Torus { t.TubeSegs = v; return t }

// SetAngStart sets the [Torus.AngStart]:
// starting radial angle in degrees relative to 1,0,0 starting point
func (t *Torus) SetAngStart(v float32) *Torus { t.AngStart = v; return t }

// SetAngLen sets the [Torus.AngLen]:
// total radial angle to generate in degrees (max = 360)
func (t *Torus) SetAngLen(v float32) *Torus { t.AngLen = v; return t }

// SolidType is the [types.Type] for [Solid]
var SolidType = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Solid", IDName: "solid", Doc: "Solid represents an individual 3D solid element.\nIt has its own unique spatial transforms and material properties,\nand points to a mesh structure defining the shape of the solid.", Embeds: []types.Field{{Name: "NodeBase"}}, Fields: []types.Field{{Name: "MeshName", Doc: "MeshName is the name of the mesh shape information used for rendering\nthis solid; all meshes are collected on the Scene."}, {Name: "Material", Doc: "Material contains the material properties of the surface (color, shininess, texture, etc)."}, {Name: "Mesh", Doc: "Mesh is the cached [Mesh] object set from [Solid.MeshName]."}}, Instance: &Solid{}})

// NewSolid returns a new [Solid] with the given optional parent:
// Solid represents an individual 3D solid element.
// It has its own unique spatial transforms and material properties,
// and points to a mesh structure defining the shape of the solid.
func NewSolid(parent ...tree.Node) *Solid { return tree.New[*Solid](parent...) }

// NodeType returns the [*types.Type] of [Solid]
func (t *Solid) NodeType() *types.Type { return SolidType }

// New returns a new [*Solid] value
func (t *Solid) New() tree.Node { return &Solid{} }

// SetMaterial sets the [Solid.Material]:
// Material contains the material properties of the surface (color, shininess, texture, etc).
func (t *Solid) SetMaterial(v Material) *Solid { t.Material = v; return t }

// Text2DType is the [types.Type] for [Text2D]
var Text2DType = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Text2D", IDName: "text2-d", Doc: "Text2D presents 2D rendered text on a vertically oriented plane, using a texture.\nCall SetText() which calls RenderText to update fortext changes (re-renders texture).\nThe native scale is such that a unit height value is the height of the default font\nset by the font-size property, and the X axis is scaled proportionally based on the\nrendered text size to maintain the aspect ratio.  Further scaling can be applied on\ntop of that by setting the Pose.Scale values as usual.\nStandard styling properties can be set on the node to set font size, family,\nand text alignment relative to the Pose.Pos position (e.g., Left, Top puts the\nupper-left corner of text at Pos).\nNote that higher quality is achieved by using a larger font size (36 default).\nThe margin property creates blank margin of the background color around the text\n(2 px default) and the background-color defaults to transparent\nbut can be set to any color.", Embeds: []types.Field{{Name: "Solid"}}, Fields: []types.Field{{Name: "Text", Doc: "the text string to display"}, {Name: "Styles", Doc: "styling settings for the text"}, {Name: "TextPos", Doc: "position offset of start of text rendering relative to upper-left corner"}, {Name: "TextRender", Doc: "render data for text label"}, {Name: "RenderState", Doc: "render state for rendering text"}}, Instance: &Text2D{}})

// NewText2D returns a new [Text2D] with the given optional parent:
// Text2D presents 2D rendered text on a vertically oriented plane, using a texture.
// Call SetText() which calls RenderText to update fortext changes (re-renders texture).
// The native scale is such that a unit height value is the height of the default font
// set by the font-size property, and the X axis is scaled proportionally based on the
// rendered text size to maintain the aspect ratio.  Further scaling can be applied on
// top of that by setting the Pose.Scale values as usual.
// Standard styling properties can be set on the node to set font size, family,
// and text alignment relative to the Pose.Pos position (e.g., Left, Top puts the
// upper-left corner of text at Pos).
// Note that higher quality is achieved by using a larger font size (36 default).
// The margin property creates blank margin of the background color around the text
// (2 px default) and the background-color defaults to transparent
// but can be set to any color.
func NewText2D(parent ...tree.Node) *Text2D { return tree.New[*Text2D](parent...) }

// NodeType returns the [*types.Type] of [Text2D]
func (t *Text2D) NodeType() *types.Type { return Text2DType }

// New returns a new [*Text2D] value
func (t *Text2D) New() tree.Node { return &Text2D{} }

// SetText sets the [Text2D.Text]:
// the text string to display
func (t *Text2D) SetText(v string) *Text2D { t.Text = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.TextureName", IDName: "texture-name", Doc: "TextureName provides a GUI interface for choosing textures."})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Texture", IDName: "texture", Doc: "Texture is the interface for all textures."})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.TextureBase", IDName: "texture-base", Doc: "TextureBase is the base texture implementation.\nIt uses an [image.RGBA] as the underlying image storage\nto facilitate interface with GPU.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"--setters"}}}, Fields: []types.Field{{Name: "Name", Doc: "Name is the name of the texture;\ntextures are connected to [Material]s by name."}, {Name: "Transparent", Doc: "Transprent is whether the texture has transparency."}, {Name: "RGBA", Doc: "RGBA is the cached internal representation of the image."}}})

// SetName sets the [TextureBase.Name]:
// Name is the name of the texture;
// textures are connected to [Material]s by name.
func (t *TextureBase) SetName(v string) *TextureBase { t.Name = v; return t }

// SetTransparent sets the [TextureBase.Transparent]:
// Transprent is whether the texture has transparency.
func (t *TextureBase) SetTransparent(v bool) *TextureBase { t.Transparent = v; return t }

// SetRGBA sets the [TextureBase.RGBA]:
// RGBA is the cached internal representation of the image.
func (t *TextureBase) SetRGBA(v *image.RGBA) *TextureBase { t.RGBA = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.TextureFile", IDName: "texture-file", Doc: "TextureFile is a texture loaded from a file", Embeds: []types.Field{{Name: "TextureBase"}}, Fields: []types.Field{{Name: "FS", Doc: "filesystem for embedded etc"}, {Name: "File", Doc: "filename for the texture"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.TextureCore", IDName: "texture-core", Doc: "TextureCore is a dynamic texture material driven by a core.Scene.\nAnything rendered to the scene will be projected onto the surface of any\nsolid using this texture. TODO: update this along with embed2d", Embeds: []types.Field{{Name: "TextureBase"}}})
