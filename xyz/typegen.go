// Code generated by "core generate -add-types"; DO NOT EDIT.

package xyz

import (
	"image"
	"image/color"

	"cogentcore.org/core/gpu/phong"
	"cogentcore.org/core/math32"
	"cogentcore.org/core/text/shaped"
	"cogentcore.org/core/tree"
	"cogentcore.org/core/types"
)

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.BBox", IDName: "b-box", Doc: "BBox contains bounding box and other gross solid properties", Fields: []types.Field{{Name: "BBox", Doc: "bounding box in local coords"}, {Name: "BSphere", Doc: "bounding sphere in local coords"}, {Name: "Area", Doc: "area"}, {Name: "Volume", Doc: "volume"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Camera", IDName: "camera", Doc: "Camera defines the properties of the camera", Fields: []types.Field{{Name: "Pose", Doc: "overall orientation and direction of the camera, relative to pointing at negative Z axis with up (positive Y) direction"}, {Name: "Target", Doc: "target location for the camera -- where it is pointing at -- defaults to the origin, but moves with panning movements, and is reset by a call to LookAt method"}, {Name: "UpDir", Doc: "up direction for camera -- which way is up -- defaults to positive Y axis, and is reset by call to LookAt method"}, {Name: "Ortho", Doc: "default is a Perspective camera -- set this to make it Orthographic instead, in which case the view includes the volume specified by the Near - Far distance (i.e., you probably want to decrease Far)."}, {Name: "FOV", Doc: "field of view in degrees"}, {Name: "Aspect", Doc: "aspect ratio (width/height)"}, {Name: "Near", Doc: "near plane z coordinate"}, {Name: "Far", Doc: "far plane z coordinate"}, {Name: "ViewMatrix", Doc: "view matrix (inverse of the Pose.Matrix)"}, {Name: "ProjectionMatrix", Doc: "projection matrix, defining the camera perspective / ortho transform"}, {Name: "InvProjectionMatrix", Doc: "inverse of the projection matrix"}, {Name: "Frustum", Doc: "frustum of projection -- viewable space defined by 6 planes of a pyrammidal shape"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Group", IDName: "group", Doc: "Group collects individual elements in a scene but does not have a Mesh or Material of\nits own.  It does have a transform that applies to all nodes under it.", Embeds: []types.Field{{Name: "NodeBase"}}})

// NewGroup returns a new [Group] with the given optional parent:
// Group collects individual elements in a scene but does not have a Mesh or Material of
// its own.  It does have a transform that applies to all nodes under it.
func NewGroup(parent ...tree.Node) *Group { return tree.New[Group](parent...) }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.SolidPoint", IDName: "solid-point", Doc: "SolidPoint contains a Solid and a Point on that solid", Fields: []types.Field{{Name: "Solid"}, {Name: "Point"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Decoder", IDName: "decoder", Doc: "Decoder parses 3D object / scene file(s) and imports into a Group or Scene.\nThis interface is implemented by the different format-specific decoders.", Methods: []types.Method{{Name: "New", Doc: "New returns a new instance of the decoder used for a specific decoding", Returns: []string{"Decoder"}}, {Name: "Desc", Doc: "Desc returns the description of this decoder", Returns: []string{"string"}}, {Name: "SetFileFS", Doc: "SetFile sets the file name being used for decoding, or error if not found.\nReturns a list of files that should be loaded along with the main one, if needed.\nFor example, .obj decoder adds a corresponding .mtl file.  In addition,\ndecoded files may specify further files (textures, etc) that must be located\nrelative to the same fsys directory.\nAll file operations use the fsys file system for access, and this should be a\nSub FS anchored at the directory where the filename is located.", Args: []string{"fsys", "fname"}, Returns: []string{"[]string", "error"}}, {Name: "Decode", Doc: "Decode reads the given data and decodes it, returning a new instance\nof the Decoder that contains all the decoded info.\nSome formats (e.g., Wavefront .obj) have separate .obj and .mtl files\nwhich are passed as two reader args.", Args: []string{"rs"}, Returns: []string{"error"}}, {Name: "SetGroup", Doc: "SetGroup sets the group to contain the decoded objects within the\ngiven scene.", Args: []string{"sc", "gp"}}, {Name: "HasScene", Doc: "HasScene returns true if this decoder has full scene information --\notherwise it only supports objects to be used in SetGroup.", Returns: []string{"bool"}}, {Name: "SetScene", Doc: "SetScene sets the scene according to the decoded data.", Args: []string{"sc"}}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Light", IDName: "light", Doc: "Light represents a light that illuminates a scene.\nThese are stored on the [Scene] object and not within the tree.", Methods: []types.Method{{Name: "AsLightBase", Doc: "AsLightBase returns the [LightBase] for this Light,\nwhich provides the core functionality of a light.", Returns: []string{"LightBase"}}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.LightBase", IDName: "light-base", Doc: "LightBase provides the core implementation of the [Light] interface.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"--setters"}}}, Fields: []types.Field{{Name: "Name", Doc: "Name is the name of the light, which matters since lights are accessed by name."}, {Name: "On", Doc: "On is whether the light is turned on. TODO: support this being false."}, {Name: "Lumens", Doc: "Lumens is the brightness/intensity/strength of the light\nin normalized 0-1 units.\nIt is just multiplied by the color, and is convenient\nfor easily modulating overall brightness."}, {Name: "Color", Doc: "Color is the color of the light at full intensity."}}})

// SetName sets the [LightBase.Name]:
// Name is the name of the light, which matters since lights are accessed by name.
func (t *LightBase) SetName(v string) *LightBase { t.Name = v; return t }

// SetOn sets the [LightBase.On]:
// On is whether the light is turned on. TODO: support this being false.
func (t *LightBase) SetOn(v bool) *LightBase { t.On = v; return t }

// SetLumens sets the [LightBase.Lumens]:
// Lumens is the brightness/intensity/strength of the light
// in normalized 0-1 units.
// It is just multiplied by the color, and is convenient
// for easily modulating overall brightness.
func (t *LightBase) SetLumens(v float32) *LightBase { t.Lumens = v; return t }

// SetColor sets the [LightBase.Color]:
// Color is the color of the light at full intensity.
func (t *LightBase) SetColor(v color.RGBA) *LightBase { t.Color = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Ambient", IDName: "ambient", Doc: "Ambient provides diffuse uniform lighting; typically only one of these in a [Scene].", Embeds: []types.Field{{Name: "LightBase"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Directional", IDName: "directional", Doc: "Directional is directional light, which is assumed to project light toward\nthe origin based on its position, with no attenuation, like the Sun.\nFor rendering, the position is negated and normalized to get the direction\nvector (i.e., absolute distance doesn't matter)", Embeds: []types.Field{{Name: "LightBase"}}, Fields: []types.Field{{Name: "Pos", Doc: "position of direct light, assumed to point at the origin\nso this determines direction."}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Point", IDName: "point", Doc: "Point is an omnidirectional light with a position\nand associated decay factors, which divide the light\nintensity as a function of linear and quadratic distance.\nThe quadratic factor dominates at longer distances.", Embeds: []types.Field{{Name: "LightBase"}}, Fields: []types.Field{{Name: "Pos", Doc: "position of light in world coordinates."}, {Name: "LinDecay", Doc: "Distance linear decay factor, defaults to .1"}, {Name: "QuadDecay", Doc: "Distance quadratic decay factor, defaults to .01. Dominates at longer distances."}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Spot", IDName: "spot", Doc: "Spotlight is a light with a position and direction and\nassociated decay factors and angles, which divide the light\nintensity as a function of linear and quadratic distance.\nThe quadratic factor dominates at longer distances.", Embeds: []types.Field{{Name: "LightBase"}}, Fields: []types.Field{{Name: "Pose"}, {Name: "AngDecay", Doc: "Angular decay factor, defaults to 15."}, {Name: "CutoffAngle", Doc: "Cut off angle (in degrees), defaults to 45; max of 90."}, {Name: "LinDecay", Doc: "Distance linear decay factor, defaults to .01."}, {Name: "QuadDecay", Doc: "Distance quadratic decay factor, defaults to .001; dominates at longer distances."}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.LightColors", IDName: "light-colors", Doc: "LightColors are standard light colors for different light sources"})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Lines", IDName: "lines", Doc: "Lines are lines rendered as long thin boxes defined by points\nand width parameters.  The Mesh must be drawn in the XY plane (i.e., use Z = 0\nor a constant unless specifically relevant to have full 3D variation).\nRotate the solid to put into other planes.", Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Points", Doc: "line points (must be 2 or more)"}, {Name: "Width", Doc: "line width, Y = height perpendicular to line direction, and X = depth"}, {Name: "Colors", Doc: "optional colors for each point -- actual color interpolates between"}, {Name: "Closed", Doc: "if true, connect the first and last points to form a closed shape"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Material", IDName: "material", Doc: "Material describes the material properties of a surface (colors, shininess, texture)\ni.e., phong lighting parameters.\nMain color is used for both ambient and diffuse color, and alpha component\nis used for opacity.  The Emissive color is only for glowing objects.\nThe Specular color is always white (multiplied by light color).\nTextures are stored on the Scene and accessed by name", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Fields: []types.Field{{Name: "Color", Doc: "Color is the main color of surface, used for both ambient and diffuse color in standard Phong model -- alpha component determines transparency -- note that transparent objects require more complex rendering"}, {Name: "Emissive", Doc: "Emissive is the color that surface emits independent of any lighting -- i.e., glow -- can be used for marking lights with an object"}, {Name: "Shiny", Doc: "Shiny is the specular shininess factor -- how focally vs. broad the surface shines back directional light -- this is an exponential factor, with 0 = very broad diffuse reflection, and higher values (typically max of 128 or so but can go higher) having a smaller more focal specular reflection.  Also set Reflective factor to change overall shininess effect."}, {Name: "Reflective", Doc: "Reflective is the specular reflectiveness factor -- how much it shines back directional light.  The specular reflection color is always white * the incoming light."}, {Name: "Bright", Doc: "Bright is an overall multiplier on final computed color value -- can be used to tune the overall brightness of various surfaces relative to each other for a given set of lighting parameters"}, {Name: "TextureName", Doc: "TextureName is the name of the texture to provide color for the surface."}, {Name: "Tiling", Doc: "Tiling is the texture tiling parameters: repeat and offset."}, {Name: "CullBack", Doc: "CullBack indicates to cull the back-facing surfaces."}, {Name: "CullFront", Doc: "CullFront indicates to cull the front-facing surfaces."}, {Name: "Texture", Doc: "Texture is the cached [Texture] object set based on [Material.TextureName]."}}})

// SetColor sets the [Material.Color]:
// Color is the main color of surface, used for both ambient and diffuse color in standard Phong model -- alpha component determines transparency -- note that transparent objects require more complex rendering
func (t *Material) SetColor(v color.RGBA) *Material { t.Color = v; return t }

// SetEmissive sets the [Material.Emissive]:
// Emissive is the color that surface emits independent of any lighting -- i.e., glow -- can be used for marking lights with an object
func (t *Material) SetEmissive(v color.RGBA) *Material { t.Emissive = v; return t }

// SetShiny sets the [Material.Shiny]:
// Shiny is the specular shininess factor -- how focally vs. broad the surface shines back directional light -- this is an exponential factor, with 0 = very broad diffuse reflection, and higher values (typically max of 128 or so but can go higher) having a smaller more focal specular reflection.  Also set Reflective factor to change overall shininess effect.
func (t *Material) SetShiny(v float32) *Material { t.Shiny = v; return t }

// SetReflective sets the [Material.Reflective]:
// Reflective is the specular reflectiveness factor -- how much it shines back directional light.  The specular reflection color is always white * the incoming light.
func (t *Material) SetReflective(v float32) *Material { t.Reflective = v; return t }

// SetBright sets the [Material.Bright]:
// Bright is an overall multiplier on final computed color value -- can be used to tune the overall brightness of various surfaces relative to each other for a given set of lighting parameters
func (t *Material) SetBright(v float32) *Material { t.Bright = v; return t }

// SetTiling sets the [Material.Tiling]:
// Tiling is the texture tiling parameters: repeat and offset.
func (t *Material) SetTiling(v phong.Tiling) *Material { t.Tiling = v; return t }

// SetCullBack sets the [Material.CullBack]:
// CullBack indicates to cull the back-facing surfaces.
func (t *Material) SetCullBack(v bool) *Material { t.CullBack = v; return t }

// SetCullFront sets the [Material.CullFront]:
// CullFront indicates to cull the front-facing surfaces.
func (t *Material) SetCullFront(v bool) *Material { t.CullFront = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.MeshName", IDName: "mesh-name", Doc: "MeshName is a [Mesh] name. This type provides an automatic GUI chooser for meshes.\nIt is used on [Solid] to link to meshes by name."})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Mesh", IDName: "mesh", Doc: "Mesh parametrizes the mesh-based shape used for rendering a [Solid],\nusing the [shape.Mesh] interface for basic shape data.\nOnly indexed triangle meshes are supported.\nAll Meshes must know in advance the number of vertex and index points\nthey require, and the Set method writes the mesh data to arrays of\nappropriate vector data.\nPer-vertex Color is optional.", Methods: []types.Method{{Name: "AsMeshBase", Doc: "AsMeshBase returns the [MeshBase] for this Mesh,\nwhich provides the core functionality of a mesh.", Returns: []string{"MeshBase"}}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.MeshBase", IDName: "mesh-base", Doc: "MeshBase provides the core implementation of the [Mesh] interface.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Fields: []types.Field{{Name: "Name", Doc: "Name is the name of the mesh. [Mesh]es are linked to [Solid]s\nby name so this matters."}, {Name: "NumVertex", Doc: "NumVertex is the number of [math32.Vector3] vertex points. This always\nincludes [math32.Vector3] normals and [math32.Vector2] texture coordinates.\nThis is only valid after [Mesh.Sizes] has been called."}, {Name: "NumIndex", Doc: "NumIndex is the number of [math32.ArrayU32] indexes.\nThis is only valid after [Mesh.Sizes] has been called."}, {Name: "HasColor", Doc: "HasColor is whether the mesh has per-vertex colors\nas [math32.Vector4] per vertex."}, {Name: "Transparent", Doc: "Transparent is whether the color has transparency;\nnot worth checking manually. This is only valid if\n[MeshBase.HasColor] is true."}, {Name: "BBox", Doc: "BBox has the computed bounding-box and other gross solid properties."}}})

// SetName sets the [MeshBase.Name]:
// Name is the name of the mesh. [Mesh]es are linked to [Solid]s
// by name so this matters.
func (t *MeshBase) SetName(v string) *MeshBase { t.Name = v; return t }

// SetHasColor sets the [MeshBase.HasColor]:
// HasColor is whether the mesh has per-vertex colors
// as [math32.Vector4] per vertex.
func (t *MeshBase) SetHasColor(v bool) *MeshBase { t.HasColor = v; return t }

// SetTransparent sets the [MeshBase.Transparent]:
// Transparent is whether the color has transparency;
// not worth checking manually. This is only valid if
// [MeshBase.HasColor] is true.
func (t *MeshBase) SetTransparent(v bool) *MeshBase { t.Transparent = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.GenMesh", IDName: "gen-mesh", Doc: "GenMesh is a generic, arbitrary Mesh, storing its values", Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Vertex"}, {Name: "Normal"}, {Name: "TexCoord"}, {Name: "Color"}, {Name: "Index"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Node", IDName: "node", Doc: "Node is the common interface for all xyz 3D tree nodes.\n[Solid] and [Group] are the two main types of nodes,\nwhich both extend [NodeBase] for the core functionality.", Methods: []types.Method{{Name: "AsNodeBase", Doc: "AsNodeBase returns the [NodeBase] for our node, which gives\naccess to all the base-level data structures and methods\nwithout requiring interface methods.", Returns: []string{"NodeBase"}}, {Name: "IsSolid", Doc: "IsSolid returns true if this is an [Solid] node (otherwise a [Group]).", Returns: []string{"bool"}}, {Name: "AsSolid", Doc: "AsSolid returns the node as a [Solid] (nil if not).", Returns: []string{"Solid"}}, {Name: "Validate", Doc: "Validate checks that scene element is valid.", Returns: []string{"error"}}, {Name: "UpdateWorldMatrix", Doc: "UpdateWorldMatrix updates this node's local and world matrix based on parent's world matrix.", Args: []string{"parWorld"}}, {Name: "UpdateMeshBBox", Doc: "UpdateMeshBBox updates the Mesh-based BBox info for all nodes.\ngroups aggregate over elements. It is called from WalkPost traversal."}, {Name: "IsVisible", Doc: "IsVisible provides the definitive answer as to whether a given node\nis currently visible.  It is only entirely valid after a render pass\nfor widgets in a visible window, but it checks the window and viewport\nfor their visibility status as well, which is available always.\nNon-visible nodes are automatically not rendered and not connected to\nwindow events.  The Invisible flag is one key element of the IsVisible\ncalculus; it is set by e.g., TabView for invisible tabs, and is also\nset if a widget is entirely out of render range.  But again, use\nIsVisible as the main end-user method.\nFor robustness, it recursively calls the parent; this is typically\na short path; propagating the Invisible flag properly can be\nvery challenging without mistakenly overwriting invisibility at various\nlevels.", Returns: []string{"bool"}}, {Name: "IsTransparent", Doc: "IsTransparent returns true if solid has transparent color.", Returns: []string{"bool"}}, {Name: "Config", Doc: "Config configures the node."}, {Name: "RenderClass", Doc: "RenderClass returns the class of rendering for this solid.\nIt is used for organizing the ordering of rendering.", Returns: []string{"RenderClasses"}}, {Name: "PreRender", Doc: "PreRender is called by Scene Render to upload\nall the object data to the Phong renderer."}, {Name: "Render", Doc: "Render is called by Scene Render to actually render.", Args: []string{"rp"}}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.NodeBase", IDName: "node-base", Doc: "NodeBase is the basic 3D tree node, which has the full transform information\nrelative to parent, and computed bounding boxes, etc.\nIt implements the [Node] interface and contains the core functionality\ncommon to all 3D nodes.", Embeds: []types.Field{{Name: "NodeBase"}}, Fields: []types.Field{{Name: "Invisible", Doc: "Invisible is whether this node is invisible."}, {Name: "Pose", Doc: "Pose is the complete specification of position and orientation."}, {Name: "Scene", Doc: "Scene is the cached [Scene]."}, {Name: "MeshBBox", Doc: "mesh-based local bounding box (aggregated for groups)"}, {Name: "WorldBBox", Doc: "world coordinates bounding box"}, {Name: "NDCBBox", Doc: "normalized display coordinates bounding box, used for frustrum clipping"}, {Name: "BBox", Doc: "raw original bounding box for the widget within its parent Scene.\nThis is prior to intersecting with Frame bounds."}, {Name: "SceneBBox", Doc: "2D bounding box for region occupied within Scene Frame that we render onto.\nThis is BBox intersected with Frame bounds."}, {Name: "isLinear", Doc: "isLinear indicates that this element contains a line-like shape,\nwhich engages a more selective event processing logic to determine\nif the node was selected based on a mouse click point."}}})

// NewNodeBase returns a new [NodeBase] with the given optional parent:
// NodeBase is the basic 3D tree node, which has the full transform information
// relative to parent, and computed bounding boxes, etc.
// It implements the [Node] interface and contains the core functionality
// common to all 3D nodes.
func NewNodeBase(parent ...tree.Node) *NodeBase { return tree.New[NodeBase](parent...) }

// SetInvisible sets the [NodeBase.Invisible]:
// Invisible is whether this node is invisible.
func (t *NodeBase) SetInvisible(v bool) *NodeBase { t.Invisible = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Pose", IDName: "pose", Doc: "Pose contains the full specification of position and orientation,\nalways relevant to the parent element.", Fields: []types.Field{{Name: "Pos", Doc: "position of center of element (relative to parent)"}, {Name: "Scale", Doc: "scale (relative to parent)"}, {Name: "Quat", Doc: "Node rotation specified as a Quat (relative to parent)"}, {Name: "Matrix", Doc: "Local matrix. Contains all position/rotation/scale information (relative to parent)"}, {Name: "ParMatrix", Doc: "Parent's world matrix -- we cache this so that we can independently update our own matrix"}, {Name: "WorldMatrix", Doc: "World matrix. Contains all absolute position/rotation/scale information (i.e. relative to very top parent, generally the scene)"}, {Name: "MVMatrix", Doc: "model * view matrix -- tranforms into camera-centered coords"}, {Name: "MVPMatrix", Doc: "model * view * projection matrix -- full final render matrix"}, {Name: "NormMatrix", Doc: "normal matrix has no offsets, for normal vector rotation only, based on MVMatrix"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.RenderClasses", IDName: "render-classes", Doc: "RenderClasses define the different classes of rendering"})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Scene", IDName: "scene", Doc: "Scene is the overall scenegraph containing nodes as children.\nIt can render offscreen to its own gpu.RenderTexture, or to an\nonscreen surface.\nThe Image of this Frame is usable directly or, via xyzcore.Scene,\nwhere it is copied into an overall core.Scene image.\n\nThere is default navigation event processing (disabled by setting NoNav)\nwhere mouse drag events Orbit the camera (Shift = Pan, Alt = PanTarget)\nand arrow keys do Orbit, Pan, PanTarget with same key modifiers.\nSpacebar restores original \"default\" camera, and numbers save (1st time)\nor restore (subsequently) camera views (Control = always save)\n\nA Group at the top-level named \"TrackCamera\" will automatically track\nthe camera (i.e., its Pose is copied) -- Solids in that group can\nset their relative Pos etc to display relative to the camera, to achieve\n\"first person\" effects.", Embeds: []types.Field{{Name: "NodeBase"}}, Fields: []types.Field{{Name: "Background", Doc: "Background is the background of the scene,\nwhich is used directly as a solid color in Vulkan."}, {Name: "NeedsUpdate", Doc: "NeedsUpdate means that Node Pose has changed and an update pass\nis required to update matrix and bounding boxes."}, {Name: "NeedsRender", Doc: "NeedsRender means that something has been updated (minimally the\nCamera pose) and a new Render is required."}, {Name: "Geom", Doc: "Viewport-level viewbox within any parent Viewport2D"}, {Name: "MultiSample", Doc: "number of samples in multisampling. Default of 4 produces smooth\nrendering."}, {Name: "Wireframe", Doc: "render using wireframe instead of filled polygons.\nThis must be set prior to configuring the Phong rendering\nsystem (i.e., just after Scene is made).\nnote: not currently working in WebGPU."}, {Name: "Camera", Doc: "camera determines view onto scene"}, {Name: "Lights", Doc: "all lights used in the scene"}, {Name: "Meshes", Doc: "meshes"}, {Name: "Textures", Doc: "textures"}, {Name: "Library", Doc: "library of objects that can be used in the scene"}, {Name: "NoNav", Doc: "don't activate the standard navigation keyboard and mouse\nevent processing to move around the camera in the scene."}, {Name: "SavedCams", Doc: "saved cameras, can Save and Set these to view the scene\nfrom different angles"}, {Name: "Phong", Doc: "the phong rendering system"}, {Name: "Frame", Doc: "the gpu render frame holding the rendered scene"}, {Name: "TextShaper", Doc: "TextShaper is the text shaping system for this scene, for doing text layout."}, {Name: "imgCopy", Doc: "image used to hold a copy of the Frame image, for ImageCopy() call.\nThis is re-used across calls to avoid large memory allocations,\nso it will automatically update after every ImageCopy call.\nIf a persistent image is required, call [iox/imagex.CloneAsRGBA]."}}})

// NewScene returns a new [Scene] with the given optional parent:
// Scene is the overall scenegraph containing nodes as children.
// It can render offscreen to its own gpu.RenderTexture, or to an
// onscreen surface.
// The Image of this Frame is usable directly or, via xyzcore.Scene,
// where it is copied into an overall core.Scene image.
//
// There is default navigation event processing (disabled by setting NoNav)
// where mouse drag events Orbit the camera (Shift = Pan, Alt = PanTarget)
// and arrow keys do Orbit, Pan, PanTarget with same key modifiers.
// Spacebar restores original "default" camera, and numbers save (1st time)
// or restore (subsequently) camera views (Control = always save)
//
// A Group at the top-level named "TrackCamera" will automatically track
// the camera (i.e., its Pose is copied) -- Solids in that group can
// set their relative Pos etc to display relative to the camera, to achieve
// "first person" effects.
func NewScene(parent ...tree.Node) *Scene { return tree.New[Scene](parent...) }

// SetBackground sets the [Scene.Background]:
// Background is the background of the scene,
// which is used directly as a solid color in Vulkan.
func (t *Scene) SetBackground(v image.Image) *Scene { t.Background = v; return t }

// SetMultiSample sets the [Scene.MultiSample]:
// number of samples in multisampling. Default of 4 produces smooth
// rendering.
func (t *Scene) SetMultiSample(v int) *Scene { t.MultiSample = v; return t }

// SetWireframe sets the [Scene.Wireframe]:
// render using wireframe instead of filled polygons.
// This must be set prior to configuring the Phong rendering
// system (i.e., just after Scene is made).
// note: not currently working in WebGPU.
func (t *Scene) SetWireframe(v bool) *Scene { t.Wireframe = v; return t }

// SetNoNav sets the [Scene.NoNav]:
// don't activate the standard navigation keyboard and mouse
// event processing to move around the camera in the scene.
func (t *Scene) SetNoNav(v bool) *Scene { t.NoNav = v; return t }

// SetTextShaper sets the [Scene.TextShaper]:
// TextShaper is the text shaping system for this scene, for doing text layout.
func (t *Scene) SetTextShaper(v shaped.Shaper) *Scene { t.TextShaper = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Plane", IDName: "plane", Doc: "Plane is a flat 2D plane, which can be oriented along any\naxis facing either positive or negative", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "NormAxis", Doc: "axis along which the normal perpendicular to the plane points.  E.g., if the Y axis is specified, then it is a standard X-Z ground plane -- see also NormalNeg for whether it is facing in the positive or negative of the given axis."}, {Name: "NormalNeg", Doc: "if false, the plane normal facing in the positive direction along specified NormAxis, otherwise it faces in the negative if true"}, {Name: "Size", Doc: "2D size of plane"}, {Name: "Segs", Doc: "number of segments to divide plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1"}, {Name: "Offset", Doc: "offset from origin along direction of normal to the plane"}}})

// SetNormAxis sets the [Plane.NormAxis]:
// axis along which the normal perpendicular to the plane points.  E.g., if the Y axis is specified, then it is a standard X-Z ground plane -- see also NormalNeg for whether it is facing in the positive or negative of the given axis.
func (t *Plane) SetNormAxis(v math32.Dims) *Plane { t.NormAxis = v; return t }

// SetNormalNeg sets the [Plane.NormalNeg]:
// if false, the plane normal facing in the positive direction along specified NormAxis, otherwise it faces in the negative if true
func (t *Plane) SetNormalNeg(v bool) *Plane { t.NormalNeg = v; return t }

// SetSize sets the [Plane.Size]:
// 2D size of plane
func (t *Plane) SetSize(v math32.Vector2) *Plane { t.Size = v; return t }

// SetSegs sets the [Plane.Segs]:
// number of segments to divide plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1
func (t *Plane) SetSegs(v math32.Vector2i) *Plane { t.Segs = v; return t }

// SetOffset sets the [Plane.Offset]:
// offset from origin along direction of normal to the plane
func (t *Plane) SetOffset(v float32) *Plane { t.Offset = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Box", IDName: "box", Doc: "Box is a rectangular-shaped solid (cuboid)", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Size", Doc: "size along each dimension"}, {Name: "Segs", Doc: "number of segments to divide each plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1"}}})

// SetSize sets the [Box.Size]:
// size along each dimension
func (t *Box) SetSize(v math32.Vector3) *Box { t.Size = v; return t }

// SetSegs sets the [Box.Segs]:
// number of segments to divide each plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1
func (t *Box) SetSegs(v math32.Vector3i) *Box { t.Segs = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Sphere", IDName: "sphere", Doc: "Sphere is a sphere mesh", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Radius", Doc: "radius of the sphere"}, {Name: "WidthSegs", Doc: "number of segments around the width of the sphere (32 is reasonable default for full circle)"}, {Name: "HeightSegs", Doc: "number of height segments (32 is reasonable default for full height)"}, {Name: "AngStart", Doc: "starting radial angle in degrees, relative to -1,0,0 left side starting point"}, {Name: "AngLen", Doc: "total radial angle to generate in degrees (max = 360)"}, {Name: "ElevStart", Doc: "starting elevation (height) angle in degrees - 0 = top of sphere, and Pi is bottom"}, {Name: "ElevLen", Doc: "total angle to generate in degrees (max = 180)"}}})

// SetRadius sets the [Sphere.Radius]:
// radius of the sphere
func (t *Sphere) SetRadius(v float32) *Sphere { t.Radius = v; return t }

// SetWidthSegs sets the [Sphere.WidthSegs]:
// number of segments around the width of the sphere (32 is reasonable default for full circle)
func (t *Sphere) SetWidthSegs(v int) *Sphere { t.WidthSegs = v; return t }

// SetHeightSegs sets the [Sphere.HeightSegs]:
// number of height segments (32 is reasonable default for full height)
func (t *Sphere) SetHeightSegs(v int) *Sphere { t.HeightSegs = v; return t }

// SetAngStart sets the [Sphere.AngStart]:
// starting radial angle in degrees, relative to -1,0,0 left side starting point
func (t *Sphere) SetAngStart(v float32) *Sphere { t.AngStart = v; return t }

// SetAngLen sets the [Sphere.AngLen]:
// total radial angle to generate in degrees (max = 360)
func (t *Sphere) SetAngLen(v float32) *Sphere { t.AngLen = v; return t }

// SetElevStart sets the [Sphere.ElevStart]:
// starting elevation (height) angle in degrees - 0 = top of sphere, and Pi is bottom
func (t *Sphere) SetElevStart(v float32) *Sphere { t.ElevStart = v; return t }

// SetElevLen sets the [Sphere.ElevLen]:
// total angle to generate in degrees (max = 180)
func (t *Sphere) SetElevLen(v float32) *Sphere { t.ElevLen = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Cylinder", IDName: "cylinder", Doc: "Cylinder is a generalized cylinder shape, including a cone\nor truncated cone by having different size circles at either end.\nHeight is up along the Y axis.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Height", Doc: "height of the cylinder"}, {Name: "TopRad", Doc: "radius of the top -- set to 0 for a cone"}, {Name: "BotRad", Doc: "radius of the bottom"}, {Name: "RadialSegs", Doc: "number of radial segments (32 is a reasonable default for full circle)"}, {Name: "HeightSegs", Doc: "number of height segments"}, {Name: "Top", Doc: "render the top disc"}, {Name: "Bottom", Doc: "render the bottom disc"}, {Name: "AngStart", Doc: "starting angle in degrees, relative to -1,0,0 left side starting point"}, {Name: "AngLen", Doc: "total angle to generate in degrees (max 360)"}}})

// SetHeight sets the [Cylinder.Height]:
// height of the cylinder
func (t *Cylinder) SetHeight(v float32) *Cylinder { t.Height = v; return t }

// SetTopRad sets the [Cylinder.TopRad]:
// radius of the top -- set to 0 for a cone
func (t *Cylinder) SetTopRad(v float32) *Cylinder { t.TopRad = v; return t }

// SetBotRad sets the [Cylinder.BotRad]:
// radius of the bottom
func (t *Cylinder) SetBotRad(v float32) *Cylinder { t.BotRad = v; return t }

// SetRadialSegs sets the [Cylinder.RadialSegs]:
// number of radial segments (32 is a reasonable default for full circle)
func (t *Cylinder) SetRadialSegs(v int) *Cylinder { t.RadialSegs = v; return t }

// SetHeightSegs sets the [Cylinder.HeightSegs]:
// number of height segments
func (t *Cylinder) SetHeightSegs(v int) *Cylinder { t.HeightSegs = v; return t }

// SetTop sets the [Cylinder.Top]:
// render the top disc
func (t *Cylinder) SetTop(v bool) *Cylinder { t.Top = v; return t }

// SetBottom sets the [Cylinder.Bottom]:
// render the bottom disc
func (t *Cylinder) SetBottom(v bool) *Cylinder { t.Bottom = v; return t }

// SetAngStart sets the [Cylinder.AngStart]:
// starting angle in degrees, relative to -1,0,0 left side starting point
func (t *Cylinder) SetAngStart(v float32) *Cylinder { t.AngStart = v; return t }

// SetAngLen sets the [Cylinder.AngLen]:
// total angle to generate in degrees (max 360)
func (t *Cylinder) SetAngLen(v float32) *Cylinder { t.AngLen = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Capsule", IDName: "capsule", Doc: "Capsule is a generalized capsule shape: a cylinder with hemisphere end caps.\nSupports different radii on each end.\nHeight is along the Y axis -- total height is Height + TopRad + BotRad.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Height", Doc: "height of the cylinder portion"}, {Name: "TopRad", Doc: "radius of the top -- set to 0 for a cone"}, {Name: "BotRad", Doc: "radius of the bottom"}, {Name: "RadialSegs", Doc: "number of radial segments (32 is a reasonable default for full circle)"}, {Name: "HeightSegs", Doc: "number of height segments"}, {Name: "CapSegs", Doc: "number of segments in the hemisphere cap ends (16 is a reasonable default)"}, {Name: "AngStart", Doc: "starting angle in degrees, relative to -1,0,0 left side starting point"}, {Name: "AngLen", Doc: "total angle to generate in degrees (max 360)"}}})

// SetHeight sets the [Capsule.Height]:
// height of the cylinder portion
func (t *Capsule) SetHeight(v float32) *Capsule { t.Height = v; return t }

// SetTopRad sets the [Capsule.TopRad]:
// radius of the top -- set to 0 for a cone
func (t *Capsule) SetTopRad(v float32) *Capsule { t.TopRad = v; return t }

// SetBotRad sets the [Capsule.BotRad]:
// radius of the bottom
func (t *Capsule) SetBotRad(v float32) *Capsule { t.BotRad = v; return t }

// SetRadialSegs sets the [Capsule.RadialSegs]:
// number of radial segments (32 is a reasonable default for full circle)
func (t *Capsule) SetRadialSegs(v int) *Capsule { t.RadialSegs = v; return t }

// SetHeightSegs sets the [Capsule.HeightSegs]:
// number of height segments
func (t *Capsule) SetHeightSegs(v int) *Capsule { t.HeightSegs = v; return t }

// SetCapSegs sets the [Capsule.CapSegs]:
// number of segments in the hemisphere cap ends (16 is a reasonable default)
func (t *Capsule) SetCapSegs(v int) *Capsule { t.CapSegs = v; return t }

// SetAngStart sets the [Capsule.AngStart]:
// starting angle in degrees, relative to -1,0,0 left side starting point
func (t *Capsule) SetAngStart(v float32) *Capsule { t.AngStart = v; return t }

// SetAngLen sets the [Capsule.AngLen]:
// total angle to generate in degrees (max 360)
func (t *Capsule) SetAngLen(v float32) *Capsule { t.AngLen = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Torus", IDName: "torus", Doc: "Torus is a torus mesh, defined by the radius of the solid tube and the\nlarger radius of the ring.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "MeshBase"}}, Fields: []types.Field{{Name: "Radius", Doc: "larger radius of the torus ring"}, {Name: "TubeRadius", Doc: "radius of the solid tube"}, {Name: "RadialSegs", Doc: "number of segments around the radius of the torus (32 is reasonable default for full circle)"}, {Name: "TubeSegs", Doc: "number of segments for the tube itself (32 is reasonable default for full height)"}, {Name: "AngStart", Doc: "starting radial angle in degrees relative to 1,0,0 starting point"}, {Name: "AngLen", Doc: "total radial angle to generate in degrees (max = 360)"}}})

// SetRadius sets the [Torus.Radius]:
// larger radius of the torus ring
func (t *Torus) SetRadius(v float32) *Torus { t.Radius = v; return t }

// SetTubeRadius sets the [Torus.TubeRadius]:
// radius of the solid tube
func (t *Torus) SetTubeRadius(v float32) *Torus { t.TubeRadius = v; return t }

// SetRadialSegs sets the [Torus.RadialSegs]:
// number of segments around the radius of the torus (32 is reasonable default for full circle)
func (t *Torus) SetRadialSegs(v int) *Torus { t.RadialSegs = v; return t }

// SetTubeSegs sets the [Torus.TubeSegs]:
// number of segments for the tube itself (32 is reasonable default for full height)
func (t *Torus) SetTubeSegs(v int) *Torus { t.TubeSegs = v; return t }

// SetAngStart sets the [Torus.AngStart]:
// starting radial angle in degrees relative to 1,0,0 starting point
func (t *Torus) SetAngStart(v float32) *Torus { t.AngStart = v; return t }

// SetAngLen sets the [Torus.AngLen]:
// total radial angle to generate in degrees (max = 360)
func (t *Torus) SetAngLen(v float32) *Torus { t.AngLen = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Solid", IDName: "solid", Doc: "Solid represents an individual 3D solid element.\nIt has its own unique spatial transforms and material properties,\nand points to a mesh structure defining the shape of the solid.", Embeds: []types.Field{{Name: "NodeBase"}}, Fields: []types.Field{{Name: "MeshName", Doc: "MeshName is the name of the mesh shape information used for rendering\nthis solid; all meshes are collected on the Scene."}, {Name: "Material", Doc: "Material contains the material properties of the surface (color, shininess, texture, etc)."}, {Name: "Mesh", Doc: "Mesh is the cached [Mesh] object set from [Solid.MeshName]."}}})

// NewSolid returns a new [Solid] with the given optional parent:
// Solid represents an individual 3D solid element.
// It has its own unique spatial transforms and material properties,
// and points to a mesh structure defining the shape of the solid.
func NewSolid(parent ...tree.Node) *Solid { return tree.New[Solid](parent...) }

// SetMaterial sets the [Solid.Material]:
// Material contains the material properties of the surface (color, shininess, texture, etc).
func (t *Solid) SetMaterial(v Material) *Solid { t.Material = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Text2D", IDName: "text2-d", Doc: "Text2D presents 2D rendered text on a vertically oriented plane, using a texture.\nCall SetText() which calls RenderText to update for text changes (re-renders texture).\nThe native scale is such that a unit height value is the height of the default font\nset by the font-size property, and the X axis is scaled proportionally based on the\nrendered text size to maintain the aspect ratio.  Further scaling can be applied on\ntop of that by setting the Pose.Scale values as usual.\nStandard styling properties can be set on the node to set font size, family,\nand text alignment relative to the Pose.Pos position (e.g., Left, Top puts the\nupper-left corner of text at Pos).\nNote that higher quality is achieved by using a larger font size (36 default).\nThe margin property creates blank margin of the background color around the text\n(2 px default) and the background-color defaults to transparent\nbut can be set to any color.", Embeds: []types.Field{{Name: "Solid"}}, Fields: []types.Field{{Name: "Text", Doc: "the text string to display"}, {Name: "Styles", Doc: "styling settings for the text"}, {Name: "TextPos", Doc: "position offset of start of text rendering relative to upper-left corner"}, {Name: "richText", Doc: "richText is the conversion of the HTML text source."}, {Name: "textRender", Doc: "render data for text label"}, {Name: "usesDefaultColor", Doc: "automatically set to true if the font render color is the default\ncolors.Scheme.OnSurface.  If so, it is automatically updated if the default\nchanges, e.g., in light mode vs dark mode switching."}}})

// NewText2D returns a new [Text2D] with the given optional parent:
// Text2D presents 2D rendered text on a vertically oriented plane, using a texture.
// Call SetText() which calls RenderText to update for text changes (re-renders texture).
// The native scale is such that a unit height value is the height of the default font
// set by the font-size property, and the X axis is scaled proportionally based on the
// rendered text size to maintain the aspect ratio.  Further scaling can be applied on
// top of that by setting the Pose.Scale values as usual.
// Standard styling properties can be set on the node to set font size, family,
// and text alignment relative to the Pose.Pos position (e.g., Left, Top puts the
// upper-left corner of text at Pos).
// Note that higher quality is achieved by using a larger font size (36 default).
// The margin property creates blank margin of the background color around the text
// (2 px default) and the background-color defaults to transparent
// but can be set to any color.
func NewText2D(parent ...tree.Node) *Text2D { return tree.New[Text2D](parent...) }

// SetText sets the [Text2D.Text]:
// the text string to display
func (t *Text2D) SetText(v string) *Text2D { t.Text = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.TextureName", IDName: "texture-name", Doc: "TextureName provides a GUI interface for choosing textures."})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.Texture", IDName: "texture", Doc: "Texture is the interface for all textures.", Methods: []types.Method{{Name: "AsTextureBase", Doc: "AsTextureBase returns the [TextureBase] for this texture,\nwhich contains the core data and functionality.", Returns: []string{"TextureBase"}}, {Name: "Image", Doc: "Image returns the image for the texture in the [image.RGBA] format used internally.", Returns: []string{"RGBA"}}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.TextureBase", IDName: "texture-base", Doc: "TextureBase is the base texture implementation.\nIt uses an [image.RGBA] as the underlying image storage\nto facilitate interface with GPU.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"--setters"}}}, Fields: []types.Field{{Name: "Name", Doc: "Name is the name of the texture;\ntextures are connected to [Material]s by name."}, {Name: "Transparent", Doc: "Transprent is whether the texture has transparency."}, {Name: "RGBA", Doc: "RGBA is the cached internal representation of the image."}}})

// SetName sets the [TextureBase.Name]:
// Name is the name of the texture;
// textures are connected to [Material]s by name.
func (t *TextureBase) SetName(v string) *TextureBase { t.Name = v; return t }

// SetTransparent sets the [TextureBase.Transparent]:
// Transprent is whether the texture has transparency.
func (t *TextureBase) SetTransparent(v bool) *TextureBase { t.Transparent = v; return t }

// SetRGBA sets the [TextureBase.RGBA]:
// RGBA is the cached internal representation of the image.
func (t *TextureBase) SetRGBA(v *image.RGBA) *TextureBase { t.RGBA = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.TextureFile", IDName: "texture-file", Doc: "TextureFile is a texture loaded from a file", Embeds: []types.Field{{Name: "TextureBase"}}, Fields: []types.Field{{Name: "FS", Doc: "filesystem for embedded etc"}, {Name: "File", Doc: "filename for the texture"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/xyz.TextureCore", IDName: "texture-core", Doc: "TextureCore is a dynamic texture material driven by a core.Scene.\nAnything rendered to the scene will be projected onto the surface of any\nsolid using this texture. TODO: update this along with embed2d", Embeds: []types.Field{{Name: "TextureBase"}}})
