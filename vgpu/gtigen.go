// Code generated by "goki generate"; DO NOT EDIT.

package vgpu

import (
	"goki.dev/gti"
	"goki.dev/ordmap"
)

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.CmdPool",
	Doc:        "CmdPool is a command pool and buffer",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Pool", &gti.Field{Name: "Pool", Type: "vk.CommandPool", Doc: "", Directives: gti.Directives{}}},
		{"Buff", &gti.Field{Name: "Buff", Type: "vk.CommandBuffer", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Topologies",
	Doc:        "Topologies are the different vertex topology",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.StackFrame",
	Doc:        "A StackFrame contains all necessary information about to generate a line\nin a callstack.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"File", &gti.Field{Name: "File", Type: "string", Doc: "", Directives: gti.Directives{}}},
		{"LineNumber", &gti.Field{Name: "LineNumber", Type: "int", Doc: "", Directives: gti.Directives{}}},
		{"Name", &gti.Field{Name: "Name", Type: "string", Doc: "", Directives: gti.Directives{}}},
		{"Package", &gti.Field{Name: "Package", Type: "string", Doc: "", Directives: gti.Directives{}}},
		{"ProgramCounter", &gti.Field{Name: "ProgramCounter", Type: "uintptr", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Device",
	Doc:        "Device holds Device and associated Queue info",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Device", &gti.Field{Name: "Device", Type: "vk.Device", Doc: "logical device", Directives: gti.Directives{}}},
		{"QueueIndex", &gti.Field{Name: "QueueIndex", Type: "uint32", Doc: "queue index for device", Directives: gti.Directives{}}},
		{"Queue", &gti.Field{Name: "Queue", Type: "vk.Queue", Doc: "queue for device", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Framebuffer",
	Doc:        "Framebuffer combines an Image and Render info (which has a depth buffer)",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Format", &gti.Field{Name: "Format", Type: "ImageFormat", Doc: "target framebuffer format -- if multisampling is active then Image has samples = 1, Render.Multi has full samples", Directives: gti.Directives{}}},
		{"Image", &gti.Field{Name: "Image", Type: "Image", Doc: "the image behind the framebuffer, includes the format -- this", Directives: gti.Directives{}}},
		{"Render", &gti.Field{Name: "Render", Type: "*Render", Doc: "pointer to the associated renderpass and depth buffer", Directives: gti.Directives{}}},
		{"Framebuffer", &gti.Field{Name: "Framebuffer", Type: "vk.Framebuffer", Doc: "vulkan framebuffer", Directives: gti.Directives{}}},
		{"HasCleared", &gti.Field{Name: "HasCleared", Type: "bool", Doc: "has this framebuffer been cleared yet?  if not, must be prior to use as a non-clearing Load case", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.GPU",
	Doc:        "GPU represents the GPU hardware",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Instance", &gti.Field{Name: "Instance", Type: "vk.Instance", Doc: "handle for the vulkan driver instance", Directives: gti.Directives{}}},
		{"GPU", &gti.Field{Name: "GPU", Type: "vk.PhysicalDevice", Doc: "handle for the vulkan physical GPU hardware", Directives: gti.Directives{}}},
		{"UserOpts", &gti.Field{Name: "UserOpts", Type: "*GPUOpts", Doc: "options passed in during config", Directives: gti.Directives{}}},
		{"EnabledOpts", &gti.Field{Name: "EnabledOpts", Type: "GPUOpts", Doc: "set of enabled options set post-Config", Directives: gti.Directives{}}},
		{"DeviceName", &gti.Field{Name: "DeviceName", Type: "string", Doc: "name of the physical GPU device", Directives: gti.Directives{}}},
		{"AppName", &gti.Field{Name: "AppName", Type: "string", Doc: "name of application -- set during Config and used in init of GPU", Directives: gti.Directives{}}},
		{"APIVersion", &gti.Field{Name: "APIVersion", Type: "vk.Version", Doc: "version of vulkan API to target", Directives: gti.Directives{}}},
		{"AppVersion", &gti.Field{Name: "AppVersion", Type: "vk.Version", Doc: "version of application -- optional", Directives: gti.Directives{}}},
		{"InstanceExts", &gti.Field{Name: "InstanceExts", Type: "[]string", Doc: "use Add method to add required instance extentions prior to calling Config", Directives: gti.Directives{}}},
		{"DeviceExts", &gti.Field{Name: "DeviceExts", Type: "[]string", Doc: "use Add method to add required device extentions prior to calling Config", Directives: gti.Directives{}}},
		{"ValidationLayers", &gti.Field{Name: "ValidationLayers", Type: "[]string", Doc: "set Add method to add required validation layers prior to calling Config", Directives: gti.Directives{}}},
		{"Compute", &gti.Field{Name: "Compute", Type: "bool", Doc: "this is used for computing, not graphics", Directives: gti.Directives{}}},
		{"DebugCallback", &gti.Field{Name: "DebugCallback", Type: "vk.DebugReportCallback", Doc: "our custom debug callback", Directives: gti.Directives{}}},
		{"GPUProps", &gti.Field{Name: "GPUProps", Type: "vk.PhysicalDeviceProperties", Doc: "properties of physical hardware -- populated after Config", Directives: gti.Directives{}}},
		{"GPUFeats", &gti.Field{Name: "GPUFeats", Type: "vk.PhysicalDeviceFeatures", Doc: "features of physical hardware -- populated after Config", Directives: gti.Directives{}}},
		{"MemoryProps", &gti.Field{Name: "MemoryProps", Type: "vk.PhysicalDeviceMemoryProperties", Doc: "properties of device memory -- populated after Config", Directives: gti.Directives{}}},
		{"MaxComputeWorkGroupCount1D", &gti.Field{Name: "MaxComputeWorkGroupCount1D", Type: "int", Doc: "maximum number of compute threads per compute shader invokation, for a 1D number of threads per Warp, which is generally greater than MaxComputeWorkGroup[0], which allows for the [1] and [2] maxima as well.  This is not defined anywhere in the formal spec, unfortunately, but has been determined empirically for Mac and NVIDIA which are two of the most relevant use-cases.  If not a known case, the MaxComputeWorkGroup[0] value is used, which can significantly slow down compute processing if more could actually be used.  Please file an issue or PR for other GPUs with known larger values.", Directives: gti.Directives{}}},
		{"PlatformDeviceNext", &gti.Field{Name: "PlatformDeviceNext", Type: "unsafe.Pointer", Doc: "[view: -] platform-specific PNext for CreateDevice call", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.ImageFormat",
	Doc:        "ImageFormat describes the size and vulkan format of an Image\nIf Layers > 1, all must be the same size.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Size", &gti.Field{Name: "Size", Type: "image.Point", Doc: "Size of image", Directives: gti.Directives{}}},
		{"Format", &gti.Field{Name: "Format", Type: "vk.Format", Doc: "Image format -- FormatR8g8b8a8Srgb is a standard default", Directives: gti.Directives{}}},
		{"Samples", &gti.Field{Name: "Samples", Type: "vk.SampleCountFlagBits", Doc: "number of samples -- set higher for Framebuffer rendering but otherwise default of SampleCount1Bit", Directives: gti.Directives{}}},
		{"Layers", &gti.Field{Name: "Layers", Type: "int", Doc: "number of layers for texture arrays", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Image",
	Doc:        "Image represents a vulkan image with an associated ImageView.\nThe vulkan Image is in device memory, in an optimized format.\nThere can also be an optional host-visible, plain pixel buffer\nwhich can be a pointer into a larger buffer or owned by the Image.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Name", &gti.Field{Name: "Name", Type: "string", Doc: "name of the image -- e.g., same as Val name if used that way -- helpful for debugging -- set to filename if loaded from a file and otherwise empty", Directives: gti.Directives{}}},
		{"Flags", &gti.Field{Name: "Flags", Type: "ImageFlags", Doc: "bit flags for image state, for indicating nature of ownership and state", Directives: gti.Directives{}}},
		{"Format", &gti.Field{Name: "Format", Type: "ImageFormat", Doc: "format & size of image", Directives: gti.Directives{}}},
		{"Image", &gti.Field{Name: "Image", Type: "vk.Image", Doc: "[view: -] vulkan image handle, in device memory", Directives: gti.Directives{}}},
		{"View", &gti.Field{Name: "View", Type: "vk.ImageView", Doc: "[view: -] vulkan image view", Directives: gti.Directives{}}},
		{"Mem", &gti.Field{Name: "Mem", Type: "vk.DeviceMemory", Doc: "[view: -] memory for image when we allocate it", Directives: gti.Directives{}}},
		{"Dev", &gti.Field{Name: "Dev", Type: "vk.Device", Doc: "[view: -] keep track of device for destroying view", Directives: gti.Directives{}}},
		{"Host", &gti.Field{Name: "Host", Type: "HostImage", Doc: "host memory buffer representation of the image", Directives: gti.Directives{}}},
		{"GPU", &gti.Field{Name: "GPU", Type: "*GPU", Doc: "pointer to our GPU", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.HostImage",
	Doc:        "HostImage is the host representation of an Image",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Size", &gti.Field{Name: "Size", Type: "int", Doc: "size in bytes allocated for host representation of image", Directives: gti.Directives{}}},
		{"Buff", &gti.Field{Name: "Buff", Type: "vk.Buffer", Doc: "[view: -] buffer for host CPU-visible memory, for staging -- can be owned by us or managed by Memory (for Val)", Directives: gti.Directives{}}},
		{"Offset", &gti.Field{Name: "Offset", Type: "int", Doc: "offset into host buffer, when Buff is Memory managed", Directives: gti.Directives{}}},
		{"Mem", &gti.Field{Name: "Mem", Type: "vk.DeviceMemory", Doc: "[view: -] host CPU-visible memory, for staging, when we manage our own memory", Directives: gti.Directives{}}},
		{"Ptr", &gti.Field{Name: "Ptr", Type: "unsafe.Pointer", Doc: "[view: -] memory mapped pointer into host memory -- remains mapped", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.ImageFlags",
	Doc:        "ImageFlags are bitflags for Image state",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.MemBuff",
	Doc:        "MemBuff is a memory buffer holding a particular type of memory\nwith staging Host-based memory and Device memory",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"GPU", &gti.Field{Name: "GPU", Type: "*GPU", Doc: "", Directives: gti.Directives{}}},
		{"Type", &gti.Field{Name: "Type", Type: "BuffTypes", Doc: "type of memory in this buffer", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "int", Doc: "allocated buffer size", Directives: gti.Directives{}}},
		{"Host", &gti.Field{Name: "Host", Type: "vk.Buffer", Doc: "[view: -] logical descriptor for host CPU-visible memory, for staging", Directives: gti.Directives{}}},
		{"HostMem", &gti.Field{Name: "HostMem", Type: "vk.DeviceMemory", Doc: "[view: -] host CPU-visible memory, for staging", Directives: gti.Directives{}}},
		{"Dev", &gti.Field{Name: "Dev", Type: "vk.Buffer", Doc: "[view: -] logical descriptor for device GPU-local memory, for computation", Directives: gti.Directives{}}},
		{"DevMem", &gti.Field{Name: "DevMem", Type: "vk.DeviceMemory", Doc: "[view: -] device GPU-local memory, for computation", Directives: gti.Directives{}}},
		{"HostPtr", &gti.Field{Name: "HostPtr", Type: "unsafe.Pointer", Doc: "[view: -] memory mapped pointer into host memory -- remains mapped", Directives: gti.Directives{}}},
		{"AlignBytes", &gti.Field{Name: "AlignBytes", Type: "int", Doc: "alignment of offsets into this buffer", Directives: gti.Directives{}}},
		{"Active", &gti.Field{Name: "Active", Type: "bool", Doc: "true if memory has been allocated, copied, transfered", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.BuffTypes",
	Doc:        "BuffTypes are memory buffer types managed by the Memory object",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.MemReg",
	Doc:        "MemReg is a region of memory for transferring to / from GPU",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Offset", &gti.Field{Name: "Offset", Type: "int", Doc: "", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "int", Doc: "", Directives: gti.Directives{}}},
		{"BuffType", &gti.Field{Name: "BuffType", Type: "BuffTypes", Doc: "", Directives: gti.Directives{}}},
		{"BuffIdx", &gti.Field{Name: "BuffIdx", Type: "int", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.VarMem",
	Doc:        "VarMem is memory allocation info per Var, for Storage types.\nUsed in initial allocation algorithm.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Var", &gti.Field{Name: "Var", Type: "*Var", Doc: "variable -- all Vals of given Var are stored in the same Buffer", Directives: gti.Directives{}}},
		{"Buff", &gti.Field{Name: "Buff", Type: "int", Doc: "index into storage buffer array holding this value", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "int", Doc: "total size needed for this value, excluding alignment padding", Directives: gti.Directives{}}},
		{"Offset", &gti.Field{Name: "Offset", Type: "int", Doc: "allocated offset within storage buffer for start of Var memory", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Memory",
	Doc:        "Memory manages memory for the GPU, using separate buffers for\ndifferent roles, defined in the BuffTypes and managed by a MemBuff.\nMemory is organized by Vars with associated Vals.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"GPU", &gti.Field{Name: "GPU", Type: "*GPU", Doc: "", Directives: gti.Directives{}}},
		{"Device", &gti.Field{Name: "Device", Type: "Device", Doc: "logical device that this memory is managed for -- set from System", Directives: gti.Directives{}}},
		{"CmdPool", &gti.Field{Name: "CmdPool", Type: "CmdPool", Doc: "command pool for memory transfers", Directives: gti.Directives{}}},
		{"Vars", &gti.Field{Name: "Vars", Type: "Vars", Doc: "Vars variables used in shaders, which manage associated Vals containing specific value instances of each var", Directives: gti.Directives{}}},
		{"Buffs", &gti.Field{Name: "Buffs", Type: "[BuffTypesN]*MemBuff", Doc: "memory buffers, organized by different Roles of vars.  Storage is managed separately in StorageBuffs", Directives: gti.Directives{}}},
		{"StorageBuffs", &gti.Field{Name: "StorageBuffs", Type: "[]*MemBuff", Doc: "memory buffers for storage -- vals are allocated to buffers during AllocHost, grouping based on what fits within GPU limits", Directives: gti.Directives{}}},
		{"StorageMems", &gti.Field{Name: "StorageMems", Type: "[]*VarMem", Doc: "memory allocation records for storage buffer allocation, per variable", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.OptionStates",
	Doc:        "OptionStates are options for the physical device features",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.CPUOptions",
	Doc:        "GPUOptions specifies supported options for the vgpu device\nupon initialization.  Several vulkan device features are\nautomatically enabled, which are required for the\nbasic functionality of vgpu supported graphics,\nbut these are optional and may be required for\nother uses (e.g., compute shaders).\nSee also InstanceExts, DeviceExts, and ValidationLayers.",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.GPUOpts",
	Doc:        "GPUOpts is the collection of CPUOption states",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Pipeline",
	Doc:        "Pipeline manages Shader program(s) that accomplish a specific\ntype of rendering or compute function, using Vars / Vals\ndefined by the overall System.\nIn the graphics context, each pipeline could handle a different\nclass of materials (textures, Phong lighting, etc).",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Name", &gti.Field{Name: "Name", Type: "string", Doc: "unique name of this pipeline", Directives: gti.Directives{}}},
		{"Sys", &gti.Field{Name: "Sys", Type: "*System", Doc: "system that we belong to and manages all shared resources (Memory, Vars, Vals, etc), etc", Directives: gti.Directives{}}},
		{"Shaders", &gti.Field{Name: "Shaders", Type: "[]*Shader", Doc: "shaders in order added -- should be execution order", Directives: gti.Directives{}}},
		{"ShaderMap", &gti.Field{Name: "ShaderMap", Type: "map[string]*Shader", Doc: "shaders loaded for this pipeline", Directives: gti.Directives{}}},
		{"VkConfig", &gti.Field{Name: "VkConfig", Type: "vk.GraphicsPipelineCreateInfo", Doc: "vulkan pipeline configuration options", Directives: gti.Directives{}}},
		{"VkPipeline", &gti.Field{Name: "VkPipeline", Type: "vk.Pipeline", Doc: "the created vulkan pipeline", Directives: gti.Directives{}}},
		{"VkCache", &gti.Field{Name: "VkCache", Type: "vk.PipelineCache", Doc: "cache", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Render",
	Doc:        "Render manages various elements needed for rendering,\nincluding a vulkan RenderPass object,\nwhich specifies parameters for rendering to a Framebuffer.\nIt holds the Depth buffer if one is used, and a multisampling image too.\nThe Render object lives on the System, and any associated Surface,\nRenderFrame, and Framebuffers point to it.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Sys", &gti.Field{Name: "Sys", Type: "*System", Doc: "system that we belong to and manages all shared resources (Memory, Vars, Vals, etc), etc", Directives: gti.Directives{}}},
		{"Dev", &gti.Field{Name: "Dev", Type: "vk.Device", Doc: "the device we're associated with -- this must be the same device that owns the Framebuffer -- e.g., the Surface", Directives: gti.Directives{}}},
		{"Format", &gti.Field{Name: "Format", Type: "ImageFormat", Doc: "image format information for the framebuffer we render to", Directives: gti.Directives{}}},
		{"Depth", &gti.Field{Name: "Depth", Type: "Image", Doc: "the associated depth buffer, if set", Directives: gti.Directives{}}},
		{"HasDepth", &gti.Field{Name: "HasDepth", Type: "bool", Doc: "is true if configured with depth buffer", Directives: gti.Directives{}}},
		{"Multi", &gti.Field{Name: "Multi", Type: "Image", Doc: "for multisampling, this is the multisampled image that is the actual render target", Directives: gti.Directives{}}},
		{"HasMulti", &gti.Field{Name: "HasMulti", Type: "bool", Doc: "is true if multsampled image configured", Directives: gti.Directives{}}},
		{"Grab", &gti.Field{Name: "Grab", Type: "Image", Doc: "host-accessible image that is used to transfer back from a render color attachment to host memory -- requires a different format than color attachment, and is ImageOnHostOnly flagged.", Directives: gti.Directives{}}},
		{"GrabDepth", &gti.Field{Name: "GrabDepth", Type: "MemBuff", Doc: "host-accessible buffer for grabbing the depth map -- must go to a buffer and not an image", Directives: gti.Directives{}}},
		{"NotSurface", &gti.Field{Name: "NotSurface", Type: "bool", Doc: "set this to true if it is not using a Surface render target (i.e., it is a RenderFrame)", Directives: gti.Directives{}}},
		{"ClearVals", &gti.Field{Name: "ClearVals", Type: "[]vk.ClearValue", Doc: "values for clearing image when starting render pass", Directives: gti.Directives{}}},
		{"VkClearPass", &gti.Field{Name: "VkClearPass", Type: "vk.RenderPass", Doc: "the vulkan renderpass config that clears target first", Directives: gti.Directives{}}},
		{"VkLoadPass", &gti.Field{Name: "VkLoadPass", Type: "vk.RenderPass", Doc: "the vulkan renderpass config that does not clear target first (loads previous)", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.RenderFrame",
	Doc:        "RenderFrame is an offscreen, non-window-backed rendering target,\nfunctioning like a Surface",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"GPU", &gti.Field{Name: "GPU", Type: "*GPU", Doc: "pointer to gpu device, for convenience", Directives: gti.Directives{}}},
		{"Device", &gti.Field{Name: "Device", Type: "Device", Doc: "device for this surface -- each window surface has its own device, configured for that surface", Directives: gti.Directives{}}},
		{"Render", &gti.Field{Name: "Render", Type: "*Render", Doc: "the Render for this RenderFrame, typically from a System", Directives: gti.Directives{}}},
		{"Format", &gti.Field{Name: "Format", Type: "ImageFormat", Doc: "has the current image format and dimensions", Directives: gti.Directives{}}},
		{"NFrames", &gti.Field{Name: "NFrames", Type: "int", Doc: "number of frames to maintain in the swapchain -- e.g., 2 = double-buffering, 3 = triple-buffering -- initially set to a requested amount, and after Init reflects actual number", Directives: gti.Directives{}}},
		{"Frames", &gti.Field{Name: "Frames", Type: "[]*Framebuffer", Doc: "Framebuffers representing the Image owned by the RenderFrame -- we iterate through these in rendering subsequent frames", Directives: gti.Directives{}}},
		{"ImageAcquired", &gti.Field{Name: "ImageAcquired", Type: "vk.Semaphore", Doc: "[view: -] semaphore used internally for waiting on acquisition of next frame", Directives: gti.Directives{}}},
		{"RenderDone", &gti.Field{Name: "RenderDone", Type: "vk.Semaphore", Doc: "[view: -] semaphore that surface user can wait on, will be activated when image has been acquired in AcquireNextFrame method", Directives: gti.Directives{}}},
		{"RenderFence", &gti.Field{Name: "RenderFence", Type: "vk.Fence", Doc: "[view: -] fence for rendering command running", Directives: gti.Directives{}}},
		{"OwnDevice", &gti.Field{Name: "OwnDevice", Type: "bool", Doc: "do we own the device?", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.VarRoles",
	Doc:        "VarRoles are the functional roles of variables, corresponding\nto Vertex input vectors and all the different \"uniform\" types\nas enumerated in vk.DescriptorType.  This does NOT map directly\nto DescriptorType because we combine vertex and uniform data\nand require a different ordering.",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Shader",
	Doc:        "Shader manages a single Shader program",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Name", &gti.Field{Name: "Name", Type: "string", Doc: "", Directives: gti.Directives{}}},
		{"Type", &gti.Field{Name: "Type", Type: "ShaderTypes", Doc: "", Directives: gti.Directives{}}},
		{"VkModule", &gti.Field{Name: "VkModule", Type: "vk.ShaderModule", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.ShaderTypes",
	Doc:        "ShaderTypes is a list of GPU shader types",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Surface",
	Doc:        "Surface manages the physical device for the visible image\nof a window surface, and the swapchain for presenting images.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"GPU", &gti.Field{Name: "GPU", Type: "*GPU", Doc: "pointer to gpu device, for convenience", Directives: gti.Directives{}}},
		{"Device", &gti.Field{Name: "Device", Type: "Device", Doc: "device for this surface -- each window surface has its own device, configured for that surface", Directives: gti.Directives{}}},
		{"Render", &gti.Field{Name: "Render", Type: "*Render", Doc: "the Render for this Surface, typically from a System", Directives: gti.Directives{}}},
		{"Format", &gti.Field{Name: "Format", Type: "ImageFormat", Doc: "has the current swapchain image format and dimensions", Directives: gti.Directives{}}},
		{"DesiredFormats", &gti.Field{Name: "DesiredFormats", Type: "[]vk.Format", Doc: "ordered list of surface formats to select", Directives: gti.Directives{}}},
		{"NFrames", &gti.Field{Name: "NFrames", Type: "int", Doc: "number of frames to maintain in the swapchain -- e.g., 2 = double-buffering, 3 = triple-buffering -- initially set to a requested amount, and after Init reflects actual number", Directives: gti.Directives{}}},
		{"Frames", &gti.Field{Name: "Frames", Type: "[]*Framebuffer", Doc: "Framebuffers representing the visible Image owned by the Surface -- we iterate through these in rendering subsequent frames", Directives: gti.Directives{}}},
		{"Surface", &gti.Field{Name: "Surface", Type: "vk.Surface", Doc: "[view: -] vulkan handle for surface", Directives: gti.Directives{}}},
		{"Swapchain", &gti.Field{Name: "Swapchain", Type: "vk.Swapchain", Doc: "[view: -] vulkan handle for swapchain", Directives: gti.Directives{}}},
		{"ImageAcquired", &gti.Field{Name: "ImageAcquired", Type: "vk.Semaphore", Doc: "[view: -] semaphore used internally for waiting on acquisition of next frame", Directives: gti.Directives{}}},
		{"RenderDone", &gti.Field{Name: "RenderDone", Type: "vk.Semaphore", Doc: "[view: -] semaphore that surface user can wait on, will be activated when image has been acquired in AcquireNextFrame method", Directives: gti.Directives{}}},
		{"RenderFence", &gti.Field{Name: "RenderFence", Type: "vk.Fence", Doc: "[view: -] fence for rendering command running", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.System",
	Doc:        "System manages a system of Pipelines that all share\na common collection of Vars, Vals, and a Memory manager.\nFor example, this could be a collection of different\npipelines for different material types, or different\ncompute operations performed on a common set of data.\nIt maintains its own logical device and associated queue.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Name", &gti.Field{Name: "Name", Type: "string", Doc: "optional name of this System", Directives: gti.Directives{}}},
		{"GPU", &gti.Field{Name: "GPU", Type: "*GPU", Doc: "gpu device", Directives: gti.Directives{}}},
		{"Device", &gti.Field{Name: "Device", Type: "Device", Doc: "logical device for this System, which is a non-owned copy of either Surface or RenderFrame device", Directives: gti.Directives{}}},
		{"CmdPool", &gti.Field{Name: "CmdPool", Type: "CmdPool", Doc: "cmd pool specific to this system", Directives: gti.Directives{}}},
		{"Compute", &gti.Field{Name: "Compute", Type: "bool", Doc: "if true, this is a compute system -- otherwise is graphics", Directives: gti.Directives{}}},
		{"StaticVars", &gti.Field{Name: "StaticVars", Type: "bool", Doc: "if true, variables are statically bound to specific offsets in memory buffers, vs. dynamically bound offsets.  Typically a compute shader operating on fixed data variables can use static binding, while graphics (e.g., vphong) requires dynamic binding to efficiently use the same shader code for multiple different values of the same variable type", Directives: gti.Directives{}}},
		{"Pipelines", &gti.Field{Name: "Pipelines", Type: "[]*Pipeline", Doc: "all pipelines", Directives: gti.Directives{}}},
		{"PipelineMap", &gti.Field{Name: "PipelineMap", Type: "map[string]*Pipeline", Doc: "map of all pipelines -- names must be unique", Directives: gti.Directives{}}},
		{"Events", &gti.Field{Name: "Events", Type: "map[string]vk.Event", Doc: "map of events for synchronizing processing within a single command stream -- this is the best method for compute shaders to coordinate within a given sequence of shader runs in a single command stream", Directives: gti.Directives{}}},
		{"Semaphores", &gti.Field{Name: "Semaphores", Type: "map[string]vk.Semaphore", Doc: "map of semaphores for GPU-side sync between different submitted commands -- names must be unique -- note: better to use Events within one command if possible.", Directives: gti.Directives{}}},
		{"Fences", &gti.Field{Name: "Fences", Type: "map[string]vk.Fence", Doc: "map of fences for CPU-GPU sync -- names must be unique.  WaitIdle implictly uses a fence so it is not essential to use this for simple wait case", Directives: gti.Directives{}}},
		{"CmdBuffs", &gti.Field{Name: "CmdBuffs", Type: "map[string]vk.CommandBuffer", Doc: "map of command buffers, for persistent recorded commands -- names must be unique", Directives: gti.Directives{}}},
		{"Mem", &gti.Field{Name: "Mem", Type: "Memory", Doc: "manages all the memory for all the Vals", Directives: gti.Directives{}}},
		{"Render", &gti.Field{Name: "Render", Type: "Render", Doc: "renderpass with depth buffer for this system", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Texture",
	Doc:        "Texture supplies an Image and a Sampler",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Image", &gti.Field{Name: "Image", Type: "Image", Doc: "", Directives: gti.Directives{}}},
		{"Sampler", &gti.Field{Name: "Sampler", Type: "Sampler", Doc: "sampler for image", Directives: gti.Directives{}}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Sampler",
	Doc:        "Sampler represents a vulkan image sampler",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Name", &gti.Field{Name: "Name", Type: "string", Doc: "", Directives: gti.Directives{}}},
		{"UMode", &gti.Field{Name: "UMode", Type: "SamplerModes", Doc: "for U (horizontal) axis -- what to do when going off the edge", Directives: gti.Directives{}}},
		{"VMode", &gti.Field{Name: "VMode", Type: "SamplerModes", Doc: "for V (vertical) axis -- what to do when going off the edge", Directives: gti.Directives{}}},
		{"WMode", &gti.Field{Name: "WMode", Type: "SamplerModes", Doc: "for W (horizontal) axis -- what to do when going off the edge", Directives: gti.Directives{}}},
		{"Border", &gti.Field{Name: "Border", Type: "BorderColors", Doc: "border color for Clamp modes", Directives: gti.Directives{}}},
		{"VkSampler", &gti.Field{Name: "VkSampler", Type: "vk.Sampler", Doc: "the vulkan sampler", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.SamplerModes",
	Doc:        "Texture image sampler modes",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.BorderColors",
	Doc:        "Texture image sampler modes",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Types",
	Doc:        "Types is a list of supported GPU data types, which can be stored\nproperly aligned in device memory, and used by the shader code.\nNote that a Vec3 or arrays of single scalar values such as Float32\nare not well supported outside of Vertex due to the std410 convention:\nhttp://www.opengl.org/registry/doc/glspec45.core.pdf#page=159\nThe Struct type is particularly challenging as each member\nmust be aligned in general on a 16 byte boundary (i.e., vec4)\n(unless all elements are exactly 4 bytes, which might work?).\nGo automatically aligns members to 8 bytes on 64 bit machines,\nbut that doesn't quite cut it.",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Val",
	Doc:        "Val represents a specific value of a Var variable.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Name", &gti.Field{Name: "Name", Type: "string", Doc: "name of this value, named by default as the variable name_idx", Directives: gti.Directives{}}},
		{"Idx", &gti.Field{Name: "Idx", Type: "int", Doc: "index of this value within the Var list of values", Directives: gti.Directives{}}},
		{"N", &gti.Field{Name: "N", Type: "int", Doc: "actual number of elements in an array -- 1 means scalar / singular value.  If 0, this is a dynamically sized item and the size must be set.", Directives: gti.Directives{}}},
		{"Offset", &gti.Field{Name: "Offset", Type: "int", Doc: "offset in bytes from start of memory buffer", Directives: gti.Directives{}}},
		{"Flags", &gti.Field{Name: "Flags", Type: "ValFlags", Doc: "val state flags", Directives: gti.Directives{}}},
		{"ElSize", &gti.Field{Name: "ElSize", Type: "int", Doc: "if N > 1 (array) then this is the effective size of each element, which must be aligned to 16 byte modulo for Uniform types.  non naturally-aligned types require slower element-by-element syncing operations, instead of memcopy.", Directives: gti.Directives{}}},
		{"AllocSize", &gti.Field{Name: "AllocSize", Type: "int", Doc: "total memory size of this value in bytes, as allocated, including array alignment but not any additional buffer-required alignment padding", Directives: gti.Directives{}}},
		{"Texture", &gti.Field{Name: "Texture", Type: "*Texture", Doc: "for Texture Var roles, this is the Texture", Directives: gti.Directives{}}},
		{"MemPtr", &gti.Field{Name: "MemPtr", Type: "unsafe.Pointer", Doc: "[view: -] pointer to the start of the staging memory for this value", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Vals",
	Doc:        "Vals is a list container of Val values, accessed by index or name",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Vals", &gti.Field{Name: "Vals", Type: "[]*Val", Doc: "values in indexed order", Directives: gti.Directives{}}},
		{"NameMap", &gti.Field{Name: "NameMap", Type: "map[string]*Val", Doc: "map of vals by name -- only for specifically named vals vs. generically allocated ones -- names must be unique", Directives: gti.Directives{}}},
		{"TexSzAlloc", &gti.Field{Name: "TexSzAlloc", Type: "szalloc.SzAlloc", Doc: "for texture values, this allocates textures to texture arrays by size -- used if On flag is set -- must call AllocTexBySize to allocate after ConfigGoImage is called on all vals.  Then call SetGoImage method on Vals to set the Go Image for each val -- this automatically redirects to the group allocated images.", Directives: gti.Directives{}}},
		{"GpTexVals", &gti.Field{Name: "GpTexVals", Type: "[]*Val", Doc: "for texture values, if AllocTexBySize is called, these are the actual allocated image arrays that hold the grouped images (size = TexSzAlloc.GpAllocs.", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.ValFlags",
	Doc:        "ValFlags are bitflags for Val state",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Var",
	Doc:        "Var specifies a variable used in a pipeline, accessed in shader programs.\nA Var represents a type of input or output into the GPU program,\nincluding things like Vertex arrays, transformation matricies (Uniforms),\nImages (Textures), and arbitrary Structs for Compute shaders.\nEach Var belongs to a Set, and its binding location is allocated within that.\nEach set is updated at the same time scale, and all vars in the set have the same\nnumber of allocated Val instances representing a specific value of the variable.\nThere must be a unique Val instance for each value of the variable used in\na single render -- a previously-used Val's contents cannot be updated within\nthe render pass, but new information can be written to an as-yet unused Val\nprior to using in a render (although this comes at a performance cost).",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Name", &gti.Field{Name: "Name", Type: "string", Doc: "variable name", Directives: gti.Directives{}}},
		{"Type", &gti.Field{Name: "Type", Type: "Types", Doc: "type of data in variable.  Note that there are strict contraints on the alignment of fields within structs -- if you can keep all fields at 4 byte increments, that works, but otherwise larger fields trigger a 16 byte alignment constraint.  Texture Images do not have such alignment constraints, and can be allocated in a big host buffer or in separate buffers depending on how frequently they are updated with different sizes.", Directives: gti.Directives{}}},
		{"ArrayN", &gti.Field{Name: "ArrayN", Type: "int", Doc: "number of elements if this is a fixed array -- use 1 if singular element, and 0 if a variable-sized array, where each Val can have its own specific size. This also works for arrays of Textures -- up to 128 max.", Directives: gti.Directives{}}},
		{"Role", &gti.Field{Name: "Role", Type: "VarRoles", Doc: "role of variable: Vertex is configured in the pipeline VkConfig structure, and everything else is configured in a DescriptorSet.  For TextureRole items, the last such Var in a set will automatically be flagged as variable sized, so the shader can specify: #extension GL_EXT_nonuniform_qualifier : require and the list of textures can be specified as a [] array.", Directives: gti.Directives{}}},
		{"Shaders", &gti.Field{Name: "Shaders", Type: "vk.ShaderStageFlagBits", Doc: "bit flags for set of shaders that this variable is used in", Directives: gti.Directives{}}},
		{"Set", &gti.Field{Name: "Set", Type: "int", Doc: "DescriptorSet associated with the timing of binding for this variable -- all vars updated at the same time should be in the same set", Directives: gti.Directives{}}},
		{"BindLoc", &gti.Field{Name: "BindLoc", Type: "int", Doc: "binding or location number for variable -- Vertexs are assigned as one group sequentially in order listed in Vars, and rest are assigned uniform binding numbers via descriptor pools", Directives: gti.Directives{}}},
		{"SizeOf", &gti.Field{Name: "SizeOf", Type: "int", Doc: "size in bytes of one element (not array size).  Note that arrays in Uniform require 16 byte alignment for each element, so if using arrays, it is best to work within that constraint.  In Storage, with HLSL compute shaders, 4 byte (e.g., float32 or int32) works fine as an array type.  For Push role, SizeOf must be set exactly -- no vals are created.", Directives: gti.Directives{}}},
		{"TextureOwns", &gti.Field{Name: "TextureOwns", Type: "bool", Doc: "texture manages its own memory allocation -- set this for texture objects that change size dynamically -- otherwise image host staging memory is allocated in a common buffer", Directives: gti.Directives{}}},
		{"DynOffIdx", &gti.Field{Name: "DynOffIdx", Type: "int", Doc: "index into the dynamic offset list, where dynamic offsets of vals need to be set -- for Uniform and Storage roles -- set during Set:DescLayout", Directives: gti.Directives{}}},
		{"Vals", &gti.Field{Name: "Vals", Type: "Vals", Doc: "the array of values allocated for this variable.  The size of this array is determined by the Set membership of this Var, and the current index is updated at the set level.  For Texture Roles, there is a separate descriptor for each value (image) -- otherwise dynamic offset binding is used.", Directives: gti.Directives{}}},
		{"BindValIdx", &gti.Field{Name: "BindValIdx", Type: "[]int", Doc: "for dynamically bound vars (Vertex, Uniform, Storage), this is the index of the currently bound value in Vals list -- index in this array is the descIdx out of Vars NDescs (see for docs) to allow for parallel update pathways -- only valid until set again -- only actually used for Vertex binding, as unforms etc have the WriteDescriptor mechanism.", Directives: gti.Directives{}}},
		{"StorageBuff", &gti.Field{Name: "StorageBuff", Type: "int", Doc: "index of the storage buffer in Memory that holds this Var -- for Storage buffer types.  Due to support for dynamic binding, all Vals of a given Var must be stored in the same buffer, and the allocation mechanism ensures this.  This constrains large vars approaching the MaxStorageBufferRange capacity to only have 1 val, which is typically reasonable given that compute shaders use large data and tend to use static binding anyway, and graphics uses tend to be smaller.", Directives: gti.Directives{}}},
		{"Offset", &gti.Field{Name: "Offset", Type: "int", Doc: "offset -- only for push constants", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.VarList",
	Doc:        "VarList is a list of variables",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Vars", &gti.Field{Name: "Vars", Type: "[]*Var", Doc: "variables in order", Directives: gti.Directives{}}},
		{"VarMap", &gti.Field{Name: "VarMap", Type: "map[string]*Var", Doc: "map of vars by name -- names must be unique", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.Vars",
	Doc:        "Vars are all the variables that are used by a pipeline,\norganized into Sets (optionally including the special VertexSet\nor PushSet).\nVars are allocated to bindings / locations sequentially in the\norder added!",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SetMap", &gti.Field{Name: "SetMap", Type: "map[int]*VarSet", Doc: "map of sets, by set number -- VertexSet is -2, PushSet is -1, rest are added incrementally", Directives: gti.Directives{}}},
		{"RoleMap", &gti.Field{Name: "RoleMap", Type: "map[VarRoles][]*Var", Doc: "map of vars by different roles across all sets -- updated in Config(), after all vars added.  This is needed for VkDescPool allocation.", Directives: gti.Directives{}}},
		{"HasVertex", &gti.Field{Name: "HasVertex", Type: "bool", Doc: "true if a VertexSet has been added", Directives: gti.Directives{}}},
		{"HasPush", &gti.Field{Name: "HasPush", Type: "bool", Doc: "true if PushSet has been added", Directives: gti.Directives{}}},
		{"NDescs", &gti.Field{Name: "NDescs", Type: "int", Doc: "number of complete descriptor sets to construct -- each descriptor set can be bound to a specific pipeline at the start of rendering, and updated with specific Val instances to provide values for each Var used during rendering.  If multiple rendering passes are performed in parallel, then each requires a separate descriptor set (e.g., typically associated with a different Frame in the swapchain), so this number should be increased.", Directives: gti.Directives{}}},
		{"Mem", &gti.Field{Name: "Mem", Type: "*Memory", Doc: "[view: -] our parent memory manager", Directives: gti.Directives{}}},
		{"StaticVars", &gti.Field{Name: "StaticVars", Type: "bool", Doc: "if true, variables are statically bound to specific offsets in memory buffers, vs. dynamically bound offsets.  Typically a compute shader operating on fixed data variables can use static binding, while graphics (e.g., vphong) requires dynamic binding to efficiently use the same shader code for multiple different values of the same variable type", Directives: gti.Directives{}}},
		{"VkDescLayout", &gti.Field{Name: "VkDescLayout", Type: "vk.PipelineLayout", Doc: "[view: -] vulkan descriptor layout based on vars", Directives: gti.Directives{}}},
		{"VkDescPool", &gti.Field{Name: "VkDescPool", Type: "vk.DescriptorPool", Doc: "[view: -] vulkan descriptor pool, allocated for NDescs and the different descriptor pools", Directives: gti.Directives{}}},
		{"VkDescSets", &gti.Field{Name: "VkDescSets", Type: "[][]vk.DescriptorSet", Doc: "allocated descriptor sets -- outer index is Vars.NDescs for different groups of descriptor sets, one of which can be bound to a pipeline at any given time.  The inner dimension is per VarSet to cover the different sets of variable updated at different times or with different numbers of items.  This variable is used for whole-pipline binding at start of rendering.", Directives: gti.Directives{}}},
		{"VkWriteVals", &gti.Field{Name: "VkWriteVals", Type: "[]vk.WriteDescriptorSet", Doc: "[view: -] currently accumulating set of vals to write to update bindings -- initiated by BindValsStart, executed by BindValsEnd", Directives: gti.Directives{}}},
		{"BindDescIdx", &gti.Field{Name: "BindDescIdx", Type: "int", Doc: "current descriptor collection index, set in BindValsStart", Directives: gti.Directives{}}},
		{"DynOffs", &gti.Field{Name: "DynOffs", Type: "[][]uint32", Doc: "dynamic offsets for Uniform and Storage variables, -- outer index is Vars.NDescs for different groups of descriptor sets, one of which can be bound to a pipeline at any given time, inner index is DynOffIdx on Var -- offsets are set when Val is bound via BindDynVal*.", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vgpu.VarSet",
	Doc:        "VarSet contains a set of Var variables that are all updated at the same time\nand have the same number of distinct Vals values per Var per render pass.\nThe first set at index -1 contains Vertex and Index data, handed separately.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Set", &gti.Field{Name: "Set", Type: "int", Doc: "set number", Directives: gti.Directives{}}},
		{"NValsPer", &gti.Field{Name: "NValsPer", Type: "int", Doc: "number of value instances to allocate per variable in this set: each value must be allocated in advance for each unique instance of a variable required across a complete scene rendering -- e.g., if this is an object position matrix, then one per object is required.  If a dynamic number are required, allocate the max possible.  For Texture vars, each of the NDesc sets can have a maximum of MaxTexturesPerSet (16) -- if NValsPer > MaxTexturesPerSet, then vals are wrapped across sets, and accessing them requires using the appropriate DescIdx, as in System.CmdBindTextureVarIdx.", Directives: gti.Directives{}}},
		{"NTextureDescs", &gti.Field{Name: "NTextureDescs", Type: "int", Doc: "for texture vars, this is the number of descriptor sets required to represent all of the different Texture image Vals that have been allocated.  Use Vars.BindAllTextureVals to bind all such vals, and System.CmdBindTextureVarIdx to automatically bind the correct set.", Directives: gti.Directives{}}},
		{"RoleMap", &gti.Field{Name: "RoleMap", Type: "map[VarRoles][]*Var", Doc: "map of vars by different roles, within this set -- updated in Config(), after all vars added", Directives: gti.Directives{}}},
		{"ParentVars", &gti.Field{Name: "ParentVars", Type: "*Vars", Doc: "the parent vars we belong to", Directives: gti.Directives{}}},
		{"VkLayout", &gti.Field{Name: "VkLayout", Type: "vk.DescriptorSetLayout", Doc: "set layout info -- static description of each var type, role, binding, stages", Directives: gti.Directives{}}},
		{"VkDescSets", &gti.Field{Name: "VkDescSets", Type: "[]vk.DescriptorSet", Doc: "allocated descriptor set -- one of these per Vars.NDescs -- can have multiple sets that can be independently updated, e.g., for parallel rendering passes.  If only rendering one at a time, only need one.", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"VarList", &gti.Field{Name: "VarList", Type: "VarList", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})
