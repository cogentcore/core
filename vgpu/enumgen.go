// Code generated by "goki generate ./..."; DO NOT EDIT.

package vgpu

import (
	"errors"
	"strconv"
	"strings"
	"sync/atomic"

	"goki.dev/enums"
)

var _ImageFlagsValues = []ImageFlags{0, 1, 2, 3, 4, 5, 6, 7}

// ImageFlagsN is the highest valid value
// for type ImageFlags, plus one.
const ImageFlagsN ImageFlags = 8

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ImageFlagsNoOp() {
	var x [1]struct{}
	_ = x[ImageActive-(0)]
	_ = x[ImageHostActive-(1)]
	_ = x[ImageOwnsImage-(2)]
	_ = x[ImageOwnsHost-(3)]
	_ = x[ImageIsVal-(4)]
	_ = x[DepthImage-(5)]
	_ = x[FramebufferImage-(6)]
	_ = x[ImageOnHostOnly-(7)]
}

var _ImageFlagsNameToValueMap = map[string]ImageFlags{
	`Active`:           0,
	`active`:           0,
	`HostActive`:       1,
	`hostactive`:       1,
	`OwnsImage`:        2,
	`ownsimage`:        2,
	`OwnsHost`:         3,
	`ownshost`:         3,
	`IsVal`:            4,
	`isval`:            4,
	`DepthImage`:       5,
	`depthimage`:       5,
	`FramebufferImage`: 6,
	`framebufferimage`: 6,
	`OnHostOnly`:       7,
	`onhostonly`:       7,
}

var _ImageFlagsDescMap = map[ImageFlags]string{
	0: `ImageActive: the Image and ImageView are configured and ready to use`,
	1: `ImageHostActive: the Host representation of the image is present and ready to be accessed`,
	2: `ImageOwnsImage: we own the Vk.Image`,
	3: `ImageOwnsHost: we own the Host buffer (and it is initialized)`,
	4: `ImageIsVal: we are a Val image and our Host buffer is shared, with offset. this is incompatible with ImageOwnsHost`,
	5: `DepthImage indicates that this is a Depth buffer image`,
	6: `FramebufferImage indicates that this is a Framebuffer image`,
	7: `ImageOnHostOnly causes the image to be created only on host visible memory, not on device memory -- no additional host buffer should be created. this is for an ImageGrab image. layout is LINEAR`,
}

var _ImageFlagsMap = map[ImageFlags]string{
	0: `Active`,
	1: `HostActive`,
	2: `OwnsImage`,
	3: `OwnsHost`,
	4: `IsVal`,
	5: `DepthImage`,
	6: `FramebufferImage`,
	7: `OnHostOnly`,
}

// String returns the string representation
// of this ImageFlags value.
func (i ImageFlags) String() string {
	str := ""
	for _, ie := range _ImageFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this ImageFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i ImageFlags) BitIndexString() string {
	if str, ok := _ImageFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the ImageFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *ImageFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the ImageFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *ImageFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _ImageFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _ImageFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type ImageFlags")
		}
	}
	return nil
}

// Int64 returns the ImageFlags value as an int64.
func (i ImageFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the ImageFlags value from an int64.
func (i *ImageFlags) SetInt64(in int64) {
	*i = ImageFlags(in)
}

// Desc returns the description of the ImageFlags value.
func (i ImageFlags) Desc() string {
	if str, ok := _ImageFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// ImageFlagsValues returns all possible values
// for the type ImageFlags.
func ImageFlagsValues() []ImageFlags {
	return _ImageFlagsValues
}

// Values returns all possible values
// for the type ImageFlags.
func (i ImageFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_ImageFlagsValues))
	for i, d := range _ImageFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type ImageFlags.
func (i ImageFlags) IsValid() bool {
	_, ok := _ImageFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i ImageFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *ImageFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ImageFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ImageFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _BuffTypesValues = []BuffTypes{0, 1, 2, 3}

// BuffTypesN is the highest valid value
// for type BuffTypes, plus one.
const BuffTypesN BuffTypes = 4

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _BuffTypesNoOp() {
	var x [1]struct{}
	_ = x[VtxIdxBuff-(0)]
	_ = x[UniformBuff-(1)]
	_ = x[StorageBuff-(2)]
	_ = x[TextureBuff-(3)]
}

var _BuffTypesNameToValueMap = map[string]BuffTypes{
	`VtxIdxBuff`:  0,
	`vtxidxbuff`:  0,
	`UniformBuff`: 1,
	`uniformbuff`: 1,
	`StorageBuff`: 2,
	`storagebuff`: 2,
	`TextureBuff`: 3,
	`texturebuff`: 3,
}

var _BuffTypesDescMap = map[BuffTypes]string{
	0: `VtxIdxBuff is a buffer holding Vertex and Index values`,
	1: `UniformBuff holds Uniform and UniformTexel objects: read-only, small footprint`,
	2: `StorageBuff holds Storage and StorageTexel: read-write, larger mostly for compute shaders`,
	3: `TextureBuff holds Images / Textures -- hardware optimizes allocation on device side, and staging-side is general`,
}

var _BuffTypesMap = map[BuffTypes]string{
	0: `VtxIdxBuff`,
	1: `UniformBuff`,
	2: `StorageBuff`,
	3: `TextureBuff`,
}

// String returns the string representation
// of this BuffTypes value.
func (i BuffTypes) String() string {
	if str, ok := _BuffTypesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the BuffTypes value from its
// string representation, and returns an
// error if the string is invalid.
func (i *BuffTypes) SetString(s string) error {
	if val, ok := _BuffTypesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _BuffTypesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type BuffTypes")
}

// Int64 returns the BuffTypes value as an int64.
func (i BuffTypes) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the BuffTypes value from an int64.
func (i *BuffTypes) SetInt64(in int64) {
	*i = BuffTypes(in)
}

// Desc returns the description of the BuffTypes value.
func (i BuffTypes) Desc() string {
	if str, ok := _BuffTypesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// BuffTypesValues returns all possible values
// for the type BuffTypes.
func BuffTypesValues() []BuffTypes {
	return _BuffTypesValues
}

// Values returns all possible values
// for the type BuffTypes.
func (i BuffTypes) Values() []enums.Enum {
	res := make([]enums.Enum, len(_BuffTypesValues))
	for i, d := range _BuffTypesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type BuffTypes.
func (i BuffTypes) IsValid() bool {
	_, ok := _BuffTypesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BuffTypes) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BuffTypes) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _OptionStatesValues = []OptionStates{0, 1, 2, 3}

// OptionStatesN is the highest valid value
// for type OptionStates, plus one.
const OptionStatesN OptionStates = 4

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _OptionStatesNoOp() {
	var x [1]struct{}
	_ = x[Disabled-(0)]
	_ = x[Optional-(1)]
	_ = x[Required-(2)]
	_ = x[Enabled-(3)]
}

var _OptionStatesNameToValueMap = map[string]OptionStates{
	`Disabled`: 0,
	`disabled`: 0,
	`Optional`: 1,
	`optional`: 1,
	`Required`: 2,
	`required`: 2,
	`Enabled`:  3,
	`enabled`:  3,
}

var _OptionStatesDescMap = map[OptionStates]string{
	0: `Disabled -- option is not enabled`,
	1: `Optional -- option is enabled if possible and code checks for actual state providing workaround if not supported`,
	2: `Required -- option is required and GPU.Config fails if not supported by the hardware`,
	3: `Enabled is the state of all options specified during Config, and supported bythe hardware`,
}

var _OptionStatesMap = map[OptionStates]string{
	0: `Disabled`,
	1: `Optional`,
	2: `Required`,
	3: `Enabled`,
}

// String returns the string representation
// of this OptionStates value.
func (i OptionStates) String() string {
	if str, ok := _OptionStatesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the OptionStates value from its
// string representation, and returns an
// error if the string is invalid.
func (i *OptionStates) SetString(s string) error {
	if val, ok := _OptionStatesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _OptionStatesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type OptionStates")
}

// Int64 returns the OptionStates value as an int64.
func (i OptionStates) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the OptionStates value from an int64.
func (i *OptionStates) SetInt64(in int64) {
	*i = OptionStates(in)
}

// Desc returns the description of the OptionStates value.
func (i OptionStates) Desc() string {
	if str, ok := _OptionStatesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// OptionStatesValues returns all possible values
// for the type OptionStates.
func OptionStatesValues() []OptionStates {
	return _OptionStatesValues
}

// Values returns all possible values
// for the type OptionStates.
func (i OptionStates) Values() []enums.Enum {
	res := make([]enums.Enum, len(_OptionStatesValues))
	for i, d := range _OptionStatesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type OptionStates.
func (i OptionStates) IsValid() bool {
	_, ok := _OptionStatesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i OptionStates) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *OptionStates) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _CPUOptionsValues = []CPUOptions{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54}

// CPUOptionsN is the highest valid value
// for type CPUOptions, plus one.
const CPUOptionsN CPUOptions = 55

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _CPUOptionsNoOp() {
	var x [1]struct{}
	_ = x[OptRobustBufferAccess-(0)]
	_ = x[OptFullDrawIndexUint32-(1)]
	_ = x[OptImageCubeArray-(2)]
	_ = x[OptIndependentBlend-(3)]
	_ = x[OptGeometryShader-(4)]
	_ = x[OptTessellationShader-(5)]
	_ = x[OptSampleRateShading-(6)]
	_ = x[OptDualSrcBlend-(7)]
	_ = x[OptLogicOp-(8)]
	_ = x[OptMultiDrawIndirect-(9)]
	_ = x[OptDrawIndirectFirstInstance-(10)]
	_ = x[OptDepthClamp-(11)]
	_ = x[OptDepthBiasClamp-(12)]
	_ = x[OptFillModeNonSolid-(13)]
	_ = x[OptDepthBounds-(14)]
	_ = x[OptWideLines-(15)]
	_ = x[OptLargePoints-(16)]
	_ = x[OptAlphaToOne-(17)]
	_ = x[OptMultiViewport-(18)]
	_ = x[OptSamplerAnisotropy-(19)]
	_ = x[OptTextureCompressionETC2-(20)]
	_ = x[OptTextureCompressionASTC_LDR-(21)]
	_ = x[OptTextureCompressionBC-(22)]
	_ = x[OptOcclusionQueryPrecise-(23)]
	_ = x[OptPipelineStatisticsQuery-(24)]
	_ = x[OptVertexPipelineStoresAndAtomics-(25)]
	_ = x[OptFragmentStoresAndAtomics-(26)]
	_ = x[OptShaderTessellationAndGeometryPointSize-(27)]
	_ = x[OptShaderImageGatherExtended-(28)]
	_ = x[OptShaderStorageImageExtendedFormats-(29)]
	_ = x[OptShaderStorageImageMultisample-(30)]
	_ = x[OptShaderStorageImageReadWithoutFormat-(31)]
	_ = x[OptShaderStorageImageWriteWithoutFormat-(32)]
	_ = x[OptShaderUniformBufferArrayDynamicIndexing-(33)]
	_ = x[OptShaderSampledImageArrayDynamicIndexing-(34)]
	_ = x[OptShaderStorageBufferArrayDynamicIndexing-(35)]
	_ = x[OptShaderStorageImageArrayDynamicIndexing-(36)]
	_ = x[OptShaderClipDistance-(37)]
	_ = x[OptShaderCullDistance-(38)]
	_ = x[OptShaderFloat64-(39)]
	_ = x[OptShaderInt64-(40)]
	_ = x[OptShaderInt16-(41)]
	_ = x[OptShaderResourceResidency-(42)]
	_ = x[OptShaderResourceMinLod-(43)]
	_ = x[OptSparseBinding-(44)]
	_ = x[OptSparseResidencyBuffer-(45)]
	_ = x[OptSparseResidencyImage2D-(46)]
	_ = x[OptSparseResidencyImage3D-(47)]
	_ = x[OptSparseResidency2Samples-(48)]
	_ = x[OptSparseResidency4Samples-(49)]
	_ = x[OptSparseResidency8Samples-(50)]
	_ = x[OptSparseResidency16Samples-(51)]
	_ = x[OptSparseResidencyAliased-(52)]
	_ = x[OptVariableMultisampleRate-(53)]
	_ = x[OptInheritedQueries-(54)]
}

var _CPUOptionsNameToValueMap = map[string]CPUOptions{
	`RobustBufferAccess`:                      0,
	`robustbufferaccess`:                      0,
	`FullDrawIndexUint32`:                     1,
	`fulldrawindexuint32`:                     1,
	`ImageCubeArray`:                          2,
	`imagecubearray`:                          2,
	`IndependentBlend`:                        3,
	`independentblend`:                        3,
	`GeometryShader`:                          4,
	`geometryshader`:                          4,
	`TessellationShader`:                      5,
	`tessellationshader`:                      5,
	`SampleRateShading`:                       6,
	`samplerateshading`:                       6,
	`DualSrcBlend`:                            7,
	`dualsrcblend`:                            7,
	`LogicOp`:                                 8,
	`logicop`:                                 8,
	`MultiDrawIndirect`:                       9,
	`multidrawindirect`:                       9,
	`DrawIndirectFirstInstance`:               10,
	`drawindirectfirstinstance`:               10,
	`DepthClamp`:                              11,
	`depthclamp`:                              11,
	`DepthBiasClamp`:                          12,
	`depthbiasclamp`:                          12,
	`FillModeNonSolid`:                        13,
	`fillmodenonsolid`:                        13,
	`DepthBounds`:                             14,
	`depthbounds`:                             14,
	`WideLines`:                               15,
	`widelines`:                               15,
	`LargePoints`:                             16,
	`largepoints`:                             16,
	`AlphaToOne`:                              17,
	`alphatoone`:                              17,
	`MultiViewport`:                           18,
	`multiviewport`:                           18,
	`SamplerAnisotropy`:                       19,
	`sampleranisotropy`:                       19,
	`TextureCompressionETC2`:                  20,
	`texturecompressionetc2`:                  20,
	`TextureCompressionASTC_LDR`:              21,
	`texturecompressionastc_ldr`:              21,
	`TextureCompressionBC`:                    22,
	`texturecompressionbc`:                    22,
	`OcclusionQueryPrecise`:                   23,
	`occlusionqueryprecise`:                   23,
	`PipelineStatisticsQuery`:                 24,
	`pipelinestatisticsquery`:                 24,
	`VertexPipelineStoresAndAtomics`:          25,
	`vertexpipelinestoresandatomics`:          25,
	`FragmentStoresAndAtomics`:                26,
	`fragmentstoresandatomics`:                26,
	`ShaderTessellationAndGeometryPointSize`:  27,
	`shadertessellationandgeometrypointsize`:  27,
	`ShaderImageGatherExtended`:               28,
	`shaderimagegatherextended`:               28,
	`ShaderStorageImageExtendedFormats`:       29,
	`shaderstorageimageextendedformats`:       29,
	`ShaderStorageImageMultisample`:           30,
	`shaderstorageimagemultisample`:           30,
	`ShaderStorageImageReadWithoutFormat`:     31,
	`shaderstorageimagereadwithoutformat`:     31,
	`ShaderStorageImageWriteWithoutFormat`:    32,
	`shaderstorageimagewritewithoutformat`:    32,
	`ShaderUniformBufferArrayDynamicIndexing`: 33,
	`shaderuniformbufferarraydynamicindexing`: 33,
	`ShaderSampledImageArrayDynamicIndexing`:  34,
	`shadersampledimagearraydynamicindexing`:  34,
	`ShaderStorageBufferArrayDynamicIndexing`: 35,
	`shaderstoragebufferarraydynamicindexing`: 35,
	`ShaderStorageImageArrayDynamicIndexing`:  36,
	`shaderstorageimagearraydynamicindexing`:  36,
	`ShaderClipDistance`:                      37,
	`shaderclipdistance`:                      37,
	`ShaderCullDistance`:                      38,
	`shaderculldistance`:                      38,
	`ShaderFloat64`:                           39,
	`shaderfloat64`:                           39,
	`ShaderInt64`:                             40,
	`shaderint64`:                             40,
	`ShaderInt16`:                             41,
	`shaderint16`:                             41,
	`ShaderResourceResidency`:                 42,
	`shaderresourceresidency`:                 42,
	`ShaderResourceMinLod`:                    43,
	`shaderresourceminlod`:                    43,
	`SparseBinding`:                           44,
	`sparsebinding`:                           44,
	`SparseResidencyBuffer`:                   45,
	`sparseresidencybuffer`:                   45,
	`SparseResidencyImage2D`:                  46,
	`sparseresidencyimage2d`:                  46,
	`SparseResidencyImage3D`:                  47,
	`sparseresidencyimage3d`:                  47,
	`SparseResidency2Samples`:                 48,
	`sparseresidency2samples`:                 48,
	`SparseResidency4Samples`:                 49,
	`sparseresidency4samples`:                 49,
	`SparseResidency8Samples`:                 50,
	`sparseresidency8samples`:                 50,
	`SparseResidency16Samples`:                51,
	`sparseresidency16samples`:                51,
	`SparseResidencyAliased`:                  52,
	`sparseresidencyaliased`:                  52,
	`VariableMultisampleRate`:                 53,
	`variablemultisamplerate`:                 53,
	`InheritedQueries`:                        54,
	`inheritedqueries`:                        54,
}

var _CPUOptionsDescMap = map[CPUOptions]string{
	0:  `OptRobustBufferAccess specifies that accesses to buffers are bounds-checked against the range of the buffer descriptor (as determined by VkDescriptorBufferInfo::range, VkBufferViewCreateInfo::range, or the size of the buffer). Out of bounds accesses must not cause application termination, and the effects of shader loads, stores, and atomics must conform to an implementation-dependent behavior as described below.`,
	1:  `OptFullDrawIndexUint32 specifies the full 32-bit range of indices is supported for indexed draw calls when using a VkIndexType of VK_INDEX_TYPE_UINT32. maxDrawIndexedIndexValue is the maximum index value that may be used (aside from the primitive restart index, which is always 232-1 when the VkIndexType is VK_INDEX_TYPE_UINT32). If this feature is supported, maxDrawIndexedIndexValue must be 232-1; otherwise it must be no smaller than 224-1. See maxDrawIndexedIndexValue.`,
	2:  `OptImageCubeArray specifies whether image views with a VkImageViewType of VK_IMAGE_VIEW_TYPE_CUBE_ARRAY can be created, and that the corresponding SampledCubeArray and ImageCubeArray SPIR-V capabilities can be used in shader code.`,
	3:  `OptIndependentBlend specifies whether the VkPipelineColorBlendAttachmentState settings are controlled independently per-attachment. If this feature is not enabled, the VkPipelineColorBlendAttachmentState settings for all color attachments must be identical. Otherwise, a different VkPipelineColorBlendAttachmentState can be provided for each bound color attachment.`,
	4:  `OptGeometryShader specifies whether geometry shaders are supported. If this feature is not enabled, the VK_SHADER_STAGE_GEOMETRY_BIT and VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT enum values must not be used. This also specifies whether shader modules can declare the Geometry capability.`,
	5:  `OptTessellationShader specifies whether tessellation control and evaluation shaders are supported. If this feature is not enabled, the VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, and VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO enum values must not be used. This also specifies whether shader modules can declare the Tessellation capability.`,
	6:  `OptSampleRateShading specifies whether Sample Shading and multisample interpolation are supported. If this feature is not enabled, the sampleShadingEnable member of the VkPipelineMultisampleStateCreateInfo structure must be set to VK_FALSE and the minSampleShading member is ignored. This also specifies whether shader modules can declare the SampleRateShading capability.`,
	7:  `OptDualSrcBlend specifies whether blend operations which take two sources are supported. If this feature is not enabled, the VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, and VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA enum values must not be used as source or destination blending factors. See https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#framebuffer-dsb.`,
	8:  `OptLogicOp specifies whether logic operations are supported. If this feature is not enabled, the logicOpEnable member of the VkPipelineColorBlendStateCreateInfo structure must be set to VK_FALSE, and the logicOp member is ignored.`,
	9:  `OptMultiDrawIndirect specifies whether multiple draw indirect is supported. If this feature is not enabled, the drawCount parameter to the vkCmdDrawIndirect and vkCmdDrawIndexedIndirect commands must be 0 or 1. The maxDrawIndirectCount member of the VkPhysicalDeviceLimits structure must also be 1 if this feature is not supported. See maxDrawIndirectCount.`,
	10: `OptDrawIndirectFirstInstance specifies whether indirect drawing calls support the firstInstance parameter. If this feature is not enabled, the firstInstance member of all VkDrawIndirectCommand and VkDrawIndexedIndirectCommand structures that are provided to the vkCmdDrawIndirect and vkCmdDrawIndexedIndirect commands must be 0.`,
	11: `OptDepthClamp specifies whether depth clamping is supported. If this feature is not enabled, the depthClampEnable member of the VkPipelineRasterizationStateCreateInfo structure must be set to VK_FALSE. Otherwise, setting depthClampEnable to VK_TRUE will enable depth clamping.`,
	12: `OptDepthBiasClamp specifies whether depth bias clamping is supported. If this feature is not enabled, the depthBiasClamp member of the VkPipelineRasterizationStateCreateInfo structure must be set to 0.0 unless the VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state is enabled, and the depthBiasClamp parameter to vkCmdSetDepthBias must be set to 0.0.`,
	13: `OptFillModeNonSolid specifies whether point and wireframe fill modes are supported. If this feature is not enabled, the VK_POLYGON_MODE_POINT and VK_POLYGON_MODE_LINE enum values must not be used.`,
	14: `OptDepthBounds specifies whether depth bounds tests are supported. If this feature is not enabled, the depthBoundsTestEnable member of the VkPipelineDepthStencilStateCreateInfo structure must be set to VK_FALSE. When depthBoundsTestEnable is set to VK_FALSE, the minDepthBounds and maxDepthBounds members of the VkPipelineDepthStencilStateCreateInfo structure are ignored.`,
	15: `OptWideLines specifies whether lines with width other than 1.0 are supported. If this feature is not enabled, the lineWidth member of the VkPipelineRasterizationStateCreateInfo structure must be set to 1.0 unless the VK_DYNAMIC_STATE_LINE_WIDTH dynamic state is enabled, and the lineWidth parameter to vkCmdSetLineWidth must be set to 1.0. When this feature is supported, the range and granularity of supported line widths are indicated by the lineWidthRange and lineWidthGranularity members of the VkPhysicalDeviceLimits structure, respectively.`,
	16: `OptLargePoints specifies whether points with size greater than 1.0 are supported. If this feature is not enabled, only a point size of 1.0 written by a shader is supported. The range and granularity of supported point sizes are indicated by the pointSizeRange and pointSizeGranularity members of the VkPhysicalDeviceLimits structure, respectively.`,
	17: `OptAlphaToOne specifies whether the implementation is able to replace the alpha value of the fragment shader color output in the Multisample Coverage fragment operation. If this feature is not enabled, then the alphaToOneEnable member of the VkPipelineMultisampleStateCreateInfo structure must be set to VK_FALSE. Otherwise setting alphaToOneEnable to VK_TRUE will enable alpha-to-one behavior.`,
	18: `OptMultiViewport specifies whether more than one viewport is supported. If this feature is not enabled: The viewportCount and scissorCount members of the VkPipelineViewportStateCreateInfo structure must be set to 1. The firstViewport and viewportCount parameters to the vkCmdSetViewport command must be set to 0 and 1, respectively. The firstScissor and scissorCount parameters to the vkCmdSetScissor command must be set to 0 and 1, respectively. The exclusiveScissorCount member of the VkPipelineViewportExclusiveScissorStateCreateInfoNV structure must be set to 0 or 1. The firstExclusiveScissor and exclusiveScissorCount parameters to the vkCmdSetExclusiveScissorNV command must be set to 0 and 1, respectively.`,
	19: `OptSamplerAnisotropy specifies whether anisotropic filtering is supported. If this feature is not enabled, the anisotropyEnable member of the VkSamplerCreateInfo structure must be VK_FALSE.`,
	20: `OptTextureCompressionETC2 specifies whether all of the ETC2 and EAC compressed texture formats are supported. If this feature is enabled, then the VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, VK_FORMAT_FEATURE_BLIT_SRC_BIT and VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must be supported in optimalTilingFeatures for various formats -- see the Vulkan Spec at https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html`,
	21: `OptTextureCompressionASTC_LDR specifies whether all of the ASTC LDR compressed texture formats are supported. If this feature is enabled, then the VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, VK_FORMAT_FEATURE_BLIT_SRC_BIT and VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must be supported in optimalTilingFeatures for various formats -- see the Vulkan Spec at https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html`,
	22: `OptTextureCompressionBC specifies whether all of the BC compressed texture formats are supported. If this feature is enabled, then the VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, VK_FORMAT_FEATURE_BLIT_SRC_BIT and VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must be supported in optimalTilingFeatures for various formats -- see the Vulkan Spec at https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html`,
	23: `OptOcclusionQueryPrecise specifies whether occlusion queries returning actual sample counts are supported. Occlusion queries are created in a VkQueryPool by specifying the queryType of VK_QUERY_TYPE_OCCLUSION in the VkQueryPoolCreateInfo structure which is passed to vkCreateQueryPool. If this feature is enabled, queries of this type can enable VK_QUERY_CONTROL_PRECISE_BIT in the flags parameter to vkCmdBeginQuery. If this feature is not supported, the implementation supports only boolean occlusion queries. When any samples are passed, boolean queries will return a non-zero result value, otherwise a result value of zero is returned. When this feature is enabled and VK_QUERY_CONTROL_PRECISE_BIT is set, occlusion queries will report the actual number of samples passed.`,
	24: `OptPipelineStatisticsQuery specifies whether the pipeline statistics queries are supported. If this feature is not enabled, queries of type VK_QUERY_TYPE_PIPELINE_STATISTICS cannot be created, and none of the VkQueryPipelineStatisticFlagBits bits can be set in the pipelineStatistics member of the VkQueryPoolCreateInfo structure.`,
	25: `OptVertexPipelineStoresAndAtomics specifies whether storage buffers and images support stores and atomic operations in the vertex, tessellation, and geometry shader stages. If this feature is not enabled, all storage image, storage texel buffer, and storage buffer variables used by these stages in shader modules must be decorated with the NonWritable decoration (or the readonly memory qualifier in GLSL).`,
	26: `OptFragmentStoresAndAtomics specifies whether storage buffers and images support stores and atomic operations in the fragment shader stage. If this feature is not enabled, all storage image, storage texel buffer, and storage buffer variables used by the fragment stage in shader modules must be decorated with the NonWritable decoration (or the readonly memory qualifier in GLSL).`,
	27: `OptShaderTessellationAndGeometryPointSize specifies whether the PointSize built-in decoration is available in the tessellation control, tessellation evaluation, and geometry shader stages. If this feature is not enabled, members decorated with the PointSize built-in decoration must not be read from or written to and all points written from a tessellation or geometry shader will have a size of 1.0. This also specifies whether shader modules can declare the TessellationPointSize capability for tessellation control and evaluation shaders, or if the shader modules can declare the GeometryPointSize capability for geometry shaders. An implementation supporting this feature must also support one or both of the tessellationShader or geometryShader features.`,
	28: `OptShaderImageGatherExtended specifies whether the extended set of image gather instructions are available in shader code. If this feature is not enabled, the OpImage*Gather instructions do not support the Offset and ConstOffsets operands. This also specifies whether shader modules can declare the ImageGatherExtended capability.`,
	29: `OptShaderStorageImageExtendedFormats specifies whether all the “storage image extended formats” below are supported; if this feature is supported, then the VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT must be supported in optimalTilingFeatures various formats -- see the Vulkan Spec at https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html`,
	30: `OptShaderStorageImageMultisample specifies whether multisampled storage images are supported. If this feature is not enabled, images that are created with a usage that includes VK_IMAGE_USAGE_STORAGE_BIT must be created with samples equal to VK_SAMPLE_COUNT_1_BIT. This also specifies whether shader modules can declare the StorageImageMultisample and ImageMSArray capabilities.`,
	31: `OptShaderStorageImageReadWithoutFormat specifies whether storage images and storage texel buffers require a format qualifier to be specified when reading. shaderStorageImageReadWithoutFormat applies only to formats listed in the storage without format list.`,
	32: `OptShaderStorageImageWriteWithoutFormat specifies whether storage images and storage texel buffers require a format qualifier to be specified when writing. shaderStorageImageWriteWithoutFormat applies only to formats listed in the storage without format list.`,
	33: `OptShaderUniformBufferArrayDynamicIndexing specifies whether arrays of uniform buffers can be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must be indexed only by constant integral expressions when aggregated into arrays in shader code. This also specifies whether shader modules can declare the UniformBufferArrayDynamicIndexing capability.`,
	34: `OptShaderSampledImageArrayDynamicIndexing specifies whether arrays of samplers or sampled images can be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must be indexed only by constant integral expressions when aggregated into arrays in shader code. This also specifies whether shader modules can declare the SampledImageArrayDynamicIndexing capability.`,
	35: `OptShaderStorageBufferArrayDynamicIndexing specifies whether arrays of storage buffers can be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must be indexed only by constant integral expressions when aggregated into arrays in shader code. This also specifies whether shader modules can declare the StorageBufferArrayDynamicIndexing capability.`,
	36: `OptShaderStorageImageArrayDynamicIndexing specifies whether arrays of storage images can be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must be indexed only by constant integral expressions when aggregated into arrays in shader code. This also specifies whether shader modules can declare the StorageImageArrayDynamicIndexing capability.`,
	37: `OptShaderClipDistance specifies whether clip distances are supported in shader code. If this feature is not enabled, any members decorated with the ClipDistance built-in decoration must not be read from or written to in shader modules. This also specifies whether shader modules can declare the ClipDistance capability.`,
	38: `OptShaderCullDistance specifies whether cull distances are supported in shader code. If this feature is not enabled, any members decorated with the CullDistance built-in decoration must not be read from or written to in shader modules. This also specifies whether shader modules can declare the CullDistance capability.`,
	39: `OptShaderFloat64 specifies whether 64-bit floats (doubles) are supported in shader code. If this feature is not enabled, 64-bit floating-point types must not be used in shader code. This also specifies whether shader modules can declare the Float64 capability. Declaring and using 64-bit floats is enabled for all storage classes that SPIR-V allows with the Float64 capability.`,
	40: `OptShaderInt64 specifies whether 64-bit integers (signed and unsigned) are supported in shader code. If this feature is not enabled, 64-bit integer types must not be used in shader code. This also specifies whether shader modules can declare the Int64 capability. Declaring and using 64-bit integers is enabled for all storage classes that SPIR-V allows with the Int64 capability.`,
	41: `OptShaderInt16 specifies whether 16-bit integers (signed and unsigned) are supported in shader code. If this feature is not enabled, 16-bit integer types must not be used in shader code. This also specifies whether shader modules can declare the Int16 capability. However, this only enables a subset of the storage classes that SPIR-V allows for the Int16 SPIR-V capability: Declaring and using 16-bit integers in the Private, Workgroup (for non-Block variables), and Function storage classes is enabled, while declaring them in the interface storage classes (e.g., UniformConstant, Uniform, StorageBuffer, Input, Output, and PushConstant) is not enabled.`,
	42: `OptShaderResourceResidency specifies whether image operations that return resource residency information are supported in shader code. If this feature is not enabled, the OpImageSparse* instructions must not be used in shader code. This also specifies whether shader modules can declare the SparseResidency capability. The feature requires at least one of the sparseResidency* features to be supported.`,
	43: `OptShaderResourceMinLod specifies whether image operations specifying the minimum resource LOD are supported in shader code. If this feature is not enabled, the MinLod image operand must not be used in shader code. This also specifies whether shader modules can declare the MinLod capability.`,
	44: `OptSparseBinding specifies whether resource memory can be managed at opaque sparse block level instead of at the object level. If this feature is not enabled, resource memory must be bound only on a per-object basis using the vkBindBufferMemory and vkBindImageMemory commands. In this case, buffers and images must not be created with VK_BUFFER_CREATE_SPARSE_BINDING_BIT and VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in the flags member of the VkBufferCreateInfo and VkImageCreateInfo structures, respectively. Otherwise resource memory can be managed as described in Sparse Resource Features.`,
	45: `OptSparseResidencyBuffer specifies whether the device can access partially resident buffers. If this feature is not enabled, buffers must not be created with VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkBufferCreateInfo structure.`,
	46: `OptSparseResidencyImage2D specifies whether the device can access partially resident 2D images with 1 sample per pixel. If this feature is not enabled, images with an imageType of VK_IMAGE_TYPE_2D and samples set to VK_SAMPLE_COUNT_1_BIT must not be created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkImageCreateInfo structure.`,
	47: `OptSparseResidencyImage3D specifies whether the device can access partially resident 3D images. If this feature is not enabled, images with an imageType of VK_IMAGE_TYPE_3D must not be created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkImageCreateInfo structure.`,
	48: `OptSparseResidency2Samples specifies whether the physical device can access partially resident 2D images with 2 samples per pixel. If this feature is not enabled, images with an imageType of VK_IMAGE_TYPE_2D and samples set to VK_SAMPLE_COUNT_2_BIT must not be created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkImageCreateInfo structure.`,
	49: `OptSparseResidency4Samples specifies whether the physical device can access partially resident 2D images with 4 samples per pixel. If this feature is not enabled, images with an imageType of VK_IMAGE_TYPE_2D and samples set to VK_SAMPLE_COUNT_4_BIT must not be created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkImageCreateInfo structure.`,
	50: `OptSparseResidency8Samples specifies whether the physical device can access partially resident 2D images with 8 samples per pixel. If this feature is not enabled, images with an imageType of VK_IMAGE_TYPE_2D and samples set to VK_SAMPLE_COUNT_8_BIT must not be created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkImageCreateInfo structure.`,
	51: `OptSparseResidency16Samples specifies whether the physical device can access partially resident 2D images with 16 samples per pixel. If this feature is not enabled, images with an imageType of VK_IMAGE_TYPE_2D and samples set to VK_SAMPLE_COUNT_16_BIT must not be created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkImageCreateInfo structure.`,
	52: `OptSparseResidencyAliased specifies whether the physical device can correctly access data aliased into multiple locations. If this feature is not enabled, the VK_BUFFER_CREATE_SPARSE_ALIASED_BIT and VK_IMAGE_CREATE_SPARSE_ALIASED_BIT enum values must not be used in flags members of the VkBufferCreateInfo and VkImageCreateInfo structures, respectively.`,
	53: `OptVariableMultisampleRate specifies whether all pipelines that will be bound to a command buffer during a subpass which uses no attachments must have the same value for VkPipelineMultisampleStateCreateInfo::rasterizationSamples. If set to VK_TRUE, the implementation supports variable multisample rates in a subpass which uses no attachments. If set to VK_FALSE, then all pipelines bound in such a subpass must have the same multisample rate. This has no effect in situations where a subpass uses any attachments.`,
	54: `OptInheritedQueries specifies whether a secondary command buffer may be executed while a query is active.`,
}

var _CPUOptionsMap = map[CPUOptions]string{
	0:  `RobustBufferAccess`,
	1:  `FullDrawIndexUint32`,
	2:  `ImageCubeArray`,
	3:  `IndependentBlend`,
	4:  `GeometryShader`,
	5:  `TessellationShader`,
	6:  `SampleRateShading`,
	7:  `DualSrcBlend`,
	8:  `LogicOp`,
	9:  `MultiDrawIndirect`,
	10: `DrawIndirectFirstInstance`,
	11: `DepthClamp`,
	12: `DepthBiasClamp`,
	13: `FillModeNonSolid`,
	14: `DepthBounds`,
	15: `WideLines`,
	16: `LargePoints`,
	17: `AlphaToOne`,
	18: `MultiViewport`,
	19: `SamplerAnisotropy`,
	20: `TextureCompressionETC2`,
	21: `TextureCompressionASTC_LDR`,
	22: `TextureCompressionBC`,
	23: `OcclusionQueryPrecise`,
	24: `PipelineStatisticsQuery`,
	25: `VertexPipelineStoresAndAtomics`,
	26: `FragmentStoresAndAtomics`,
	27: `ShaderTessellationAndGeometryPointSize`,
	28: `ShaderImageGatherExtended`,
	29: `ShaderStorageImageExtendedFormats`,
	30: `ShaderStorageImageMultisample`,
	31: `ShaderStorageImageReadWithoutFormat`,
	32: `ShaderStorageImageWriteWithoutFormat`,
	33: `ShaderUniformBufferArrayDynamicIndexing`,
	34: `ShaderSampledImageArrayDynamicIndexing`,
	35: `ShaderStorageBufferArrayDynamicIndexing`,
	36: `ShaderStorageImageArrayDynamicIndexing`,
	37: `ShaderClipDistance`,
	38: `ShaderCullDistance`,
	39: `ShaderFloat64`,
	40: `ShaderInt64`,
	41: `ShaderInt16`,
	42: `ShaderResourceResidency`,
	43: `ShaderResourceMinLod`,
	44: `SparseBinding`,
	45: `SparseResidencyBuffer`,
	46: `SparseResidencyImage2D`,
	47: `SparseResidencyImage3D`,
	48: `SparseResidency2Samples`,
	49: `SparseResidency4Samples`,
	50: `SparseResidency8Samples`,
	51: `SparseResidency16Samples`,
	52: `SparseResidencyAliased`,
	53: `VariableMultisampleRate`,
	54: `InheritedQueries`,
}

// String returns the string representation
// of this CPUOptions value.
func (i CPUOptions) String() string {
	if str, ok := _CPUOptionsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the CPUOptions value from its
// string representation, and returns an
// error if the string is invalid.
func (i *CPUOptions) SetString(s string) error {
	if val, ok := _CPUOptionsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _CPUOptionsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type CPUOptions")
}

// Int64 returns the CPUOptions value as an int64.
func (i CPUOptions) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the CPUOptions value from an int64.
func (i *CPUOptions) SetInt64(in int64) {
	*i = CPUOptions(in)
}

// Desc returns the description of the CPUOptions value.
func (i CPUOptions) Desc() string {
	if str, ok := _CPUOptionsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// CPUOptionsValues returns all possible values
// for the type CPUOptions.
func CPUOptionsValues() []CPUOptions {
	return _CPUOptionsValues
}

// Values returns all possible values
// for the type CPUOptions.
func (i CPUOptions) Values() []enums.Enum {
	res := make([]enums.Enum, len(_CPUOptionsValues))
	for i, d := range _CPUOptionsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type CPUOptions.
func (i CPUOptions) IsValid() bool {
	_, ok := _CPUOptionsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i CPUOptions) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *CPUOptions) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _VarRolesValues = []VarRoles{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

// VarRolesN is the highest valid value
// for type VarRoles, plus one.
const VarRolesN VarRoles = 10

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _VarRolesNoOp() {
	var x [1]struct{}
	_ = x[UndefVarRole-(0)]
	_ = x[Vertex-(1)]
	_ = x[Index-(2)]
	_ = x[Push-(3)]
	_ = x[Uniform-(4)]
	_ = x[Storage-(5)]
	_ = x[UniformTexel-(6)]
	_ = x[StorageTexel-(7)]
	_ = x[StorageImage-(8)]
	_ = x[TextureRole-(9)]
}

var _VarRolesNameToValueMap = map[string]VarRoles{
	`UndefVarRole`: 0,
	`undefvarrole`: 0,
	`Vertex`:       1,
	`vertex`:       1,
	`Index`:        2,
	`index`:        2,
	`Push`:         3,
	`push`:         3,
	`Uniform`:      4,
	`uniform`:      4,
	`Storage`:      5,
	`storage`:      5,
	`UniformTexel`: 6,
	`uniformtexel`: 6,
	`StorageTexel`: 7,
	`storagetexel`: 7,
	`StorageImage`: 8,
	`storageimage`: 8,
	`TextureRole`:  9,
	`texturerole`:  9,
}

var _VarRolesDescMap = map[VarRoles]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
	4: ``,
	5: ``,
	6: ``,
	7: ``,
	8: ``,
	9: ``,
}

var _VarRolesMap = map[VarRoles]string{
	0: `UndefVarRole`,
	1: `Vertex`,
	2: `Index`,
	3: `Push`,
	4: `Uniform`,
	5: `Storage`,
	6: `UniformTexel`,
	7: `StorageTexel`,
	8: `StorageImage`,
	9: `TextureRole`,
}

// String returns the string representation
// of this VarRoles value.
func (i VarRoles) String() string {
	if str, ok := _VarRolesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the VarRoles value from its
// string representation, and returns an
// error if the string is invalid.
func (i *VarRoles) SetString(s string) error {
	if val, ok := _VarRolesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _VarRolesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type VarRoles")
}

// Int64 returns the VarRoles value as an int64.
func (i VarRoles) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the VarRoles value from an int64.
func (i *VarRoles) SetInt64(in int64) {
	*i = VarRoles(in)
}

// Desc returns the description of the VarRoles value.
func (i VarRoles) Desc() string {
	if str, ok := _VarRolesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// VarRolesValues returns all possible values
// for the type VarRoles.
func VarRolesValues() []VarRoles {
	return _VarRolesValues
}

// Values returns all possible values
// for the type VarRoles.
func (i VarRoles) Values() []enums.Enum {
	res := make([]enums.Enum, len(_VarRolesValues))
	for i, d := range _VarRolesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type VarRoles.
func (i VarRoles) IsValid() bool {
	_, ok := _VarRolesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i VarRoles) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *VarRoles) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _SamplerModesValues = []SamplerModes{0, 1, 2, 3, 4}

// SamplerModesN is the highest valid value
// for type SamplerModes, plus one.
const SamplerModesN SamplerModes = 5

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _SamplerModesNoOp() {
	var x [1]struct{}
	_ = x[Repeat-(0)]
	_ = x[MirroredRepeat-(1)]
	_ = x[ClampToEdge-(2)]
	_ = x[ClampToBorder-(3)]
	_ = x[MirrorClampToEdge-(4)]
}

var _SamplerModesNameToValueMap = map[string]SamplerModes{
	`Repeat`:            0,
	`repeat`:            0,
	`MirroredRepeat`:    1,
	`mirroredrepeat`:    1,
	`ClampToEdge`:       2,
	`clamptoedge`:       2,
	`ClampToBorder`:     3,
	`clamptoborder`:     3,
	`MirrorClampToEdge`: 4,
	`mirrorclamptoedge`: 4,
}

var _SamplerModesDescMap = map[SamplerModes]string{
	0: `Repeat the texture when going beyond the image dimensions.`,
	1: `Like repeat, but inverts the coordinates to mirror the image when going beyond the dimensions.`,
	2: `Take the color of the edge closest to the coordinate beyond the image dimensions.`,
	3: `Return a solid color when sampling beyond the dimensions of the image.`,
	4: `Like clamp to edge, but instead uses the edge opposite to the closest edge.`,
}

var _SamplerModesMap = map[SamplerModes]string{
	0: `Repeat`,
	1: `MirroredRepeat`,
	2: `ClampToEdge`,
	3: `ClampToBorder`,
	4: `MirrorClampToEdge`,
}

// String returns the string representation
// of this SamplerModes value.
func (i SamplerModes) String() string {
	if str, ok := _SamplerModesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the SamplerModes value from its
// string representation, and returns an
// error if the string is invalid.
func (i *SamplerModes) SetString(s string) error {
	if val, ok := _SamplerModesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _SamplerModesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type SamplerModes")
}

// Int64 returns the SamplerModes value as an int64.
func (i SamplerModes) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the SamplerModes value from an int64.
func (i *SamplerModes) SetInt64(in int64) {
	*i = SamplerModes(in)
}

// Desc returns the description of the SamplerModes value.
func (i SamplerModes) Desc() string {
	if str, ok := _SamplerModesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// SamplerModesValues returns all possible values
// for the type SamplerModes.
func SamplerModesValues() []SamplerModes {
	return _SamplerModesValues
}

// Values returns all possible values
// for the type SamplerModes.
func (i SamplerModes) Values() []enums.Enum {
	res := make([]enums.Enum, len(_SamplerModesValues))
	for i, d := range _SamplerModesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type SamplerModes.
func (i SamplerModes) IsValid() bool {
	_, ok := _SamplerModesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i SamplerModes) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *SamplerModes) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _BorderColorsValues = []BorderColors{0, 1, 2}

// BorderColorsN is the highest valid value
// for type BorderColors, plus one.
const BorderColorsN BorderColors = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _BorderColorsNoOp() {
	var x [1]struct{}
	_ = x[BorderTrans-(0)]
	_ = x[BorderBlack-(1)]
	_ = x[BorderWhite-(2)]
}

var _BorderColorsNameToValueMap = map[string]BorderColors{
	`Trans`: 0,
	`trans`: 0,
	`Black`: 1,
	`black`: 1,
	`White`: 2,
	`white`: 2,
}

var _BorderColorsDescMap = map[BorderColors]string{
	0: `Repeat the texture when going beyond the image dimensions.`,
	1: ``,
	2: ``,
}

var _BorderColorsMap = map[BorderColors]string{
	0: `Trans`,
	1: `Black`,
	2: `White`,
}

// String returns the string representation
// of this BorderColors value.
func (i BorderColors) String() string {
	if str, ok := _BorderColorsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the BorderColors value from its
// string representation, and returns an
// error if the string is invalid.
func (i *BorderColors) SetString(s string) error {
	if val, ok := _BorderColorsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _BorderColorsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type BorderColors")
}

// Int64 returns the BorderColors value as an int64.
func (i BorderColors) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the BorderColors value from an int64.
func (i *BorderColors) SetInt64(in int64) {
	*i = BorderColors(in)
}

// Desc returns the description of the BorderColors value.
func (i BorderColors) Desc() string {
	if str, ok := _BorderColorsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// BorderColorsValues returns all possible values
// for the type BorderColors.
func BorderColorsValues() []BorderColors {
	return _BorderColorsValues
}

// Values returns all possible values
// for the type BorderColors.
func (i BorderColors) Values() []enums.Enum {
	res := make([]enums.Enum, len(_BorderColorsValues))
	for i, d := range _BorderColorsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type BorderColors.
func (i BorderColors) IsValid() bool {
	_, ok := _BorderColorsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BorderColors) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BorderColors) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TypesValues = []Types{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23}

// TypesN is the highest valid value
// for type Types, plus one.
const TypesN Types = 24

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TypesNoOp() {
	var x [1]struct{}
	_ = x[UndefType-(0)]
	_ = x[Bool32-(1)]
	_ = x[Int16-(2)]
	_ = x[Uint16-(3)]
	_ = x[Int32-(4)]
	_ = x[Int32Vec2-(5)]
	_ = x[Int32Vec4-(6)]
	_ = x[Uint32-(7)]
	_ = x[Uint32Vec2-(8)]
	_ = x[Uint32Vec4-(9)]
	_ = x[Float32-(10)]
	_ = x[Float32Vec2-(11)]
	_ = x[Float32Vec3-(12)]
	_ = x[Float32Vec4-(13)]
	_ = x[Float64-(14)]
	_ = x[Float64Vec2-(15)]
	_ = x[Float64Vec3-(16)]
	_ = x[Float64Vec4-(17)]
	_ = x[Float32Mat4-(18)]
	_ = x[Float32Mat3-(19)]
	_ = x[ImageRGBA32-(20)]
	_ = x[Depth32-(21)]
	_ = x[Depth24Sten8-(22)]
	_ = x[Struct-(23)]
}

var _TypesNameToValueMap = map[string]Types{
	`UndefType`:    0,
	`undeftype`:    0,
	`Bool32`:       1,
	`bool32`:       1,
	`Int16`:        2,
	`int16`:        2,
	`Uint16`:       3,
	`uint16`:       3,
	`Int32`:        4,
	`int32`:        4,
	`Int32Vec2`:    5,
	`int32vec2`:    5,
	`Int32Vec4`:    6,
	`int32vec4`:    6,
	`Uint32`:       7,
	`uint32`:       7,
	`Uint32Vec2`:   8,
	`uint32vec2`:   8,
	`Uint32Vec4`:   9,
	`uint32vec4`:   9,
	`Float32`:      10,
	`float32`:      10,
	`Float32Vec2`:  11,
	`float32vec2`:  11,
	`Float32Vec3`:  12,
	`float32vec3`:  12,
	`Float32Vec4`:  13,
	`float32vec4`:  13,
	`Float64`:      14,
	`float64`:      14,
	`Float64Vec2`:  15,
	`float64vec2`:  15,
	`Float64Vec3`:  16,
	`float64vec3`:  16,
	`Float64Vec4`:  17,
	`float64vec4`:  17,
	`Float32Mat4`:  18,
	`float32mat4`:  18,
	`Float32Mat3`:  19,
	`float32mat3`:  19,
	`ImageRGBA32`:  20,
	`imagergba32`:  20,
	`Depth32`:      21,
	`depth32`:      21,
	`Depth24Sten8`: 22,
	`depth24sten8`: 22,
	`Struct`:       23,
	`struct`:       23,
}

var _TypesDescMap = map[Types]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  ``,
	4:  ``,
	5:  ``,
	6:  ``,
	7:  ``,
	8:  ``,
	9:  ``,
	10: ``,
	11: ``,
	12: ``,
	13: ``,
	14: ``,
	15: ``,
	16: ``,
	17: ``,
	18: ``,
	19: ``,
	20: ``,
	21: ``,
	22: ``,
	23: ``,
}

var _TypesMap = map[Types]string{
	0:  `UndefType`,
	1:  `Bool32`,
	2:  `Int16`,
	3:  `Uint16`,
	4:  `Int32`,
	5:  `Int32Vec2`,
	6:  `Int32Vec4`,
	7:  `Uint32`,
	8:  `Uint32Vec2`,
	9:  `Uint32Vec4`,
	10: `Float32`,
	11: `Float32Vec2`,
	12: `Float32Vec3`,
	13: `Float32Vec4`,
	14: `Float64`,
	15: `Float64Vec2`,
	16: `Float64Vec3`,
	17: `Float64Vec4`,
	18: `Float32Mat4`,
	19: `Float32Mat3`,
	20: `ImageRGBA32`,
	21: `Depth32`,
	22: `Depth24Sten8`,
	23: `Struct`,
}

// String returns the string representation
// of this Types value.
func (i Types) String() string {
	if str, ok := _TypesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Types value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Types) SetString(s string) error {
	if val, ok := _TypesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TypesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Types")
}

// Int64 returns the Types value as an int64.
func (i Types) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Types value from an int64.
func (i *Types) SetInt64(in int64) {
	*i = Types(in)
}

// Desc returns the description of the Types value.
func (i Types) Desc() string {
	if str, ok := _TypesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TypesValues returns all possible values
// for the type Types.
func TypesValues() []Types {
	return _TypesValues
}

// Values returns all possible values
// for the type Types.
func (i Types) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TypesValues))
	for i, d := range _TypesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Types.
func (i Types) IsValid() bool {
	_, ok := _TypesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Types) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Types) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _ValFlagsValues = []ValFlags{0, 1, 2}

// ValFlagsN is the highest valid value
// for type ValFlags, plus one.
const ValFlagsN ValFlags = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ValFlagsNoOp() {
	var x [1]struct{}
	_ = x[ValMod-(0)]
	_ = x[ValPaddedArray-(1)]
	_ = x[ValTextureOwns-(2)]
}

var _ValFlagsNameToValueMap = map[string]ValFlags{
	`Mod`:         0,
	`mod`:         0,
	`PaddedArray`: 1,
	`paddedarray`: 1,
	`TextureOwns`: 2,
	`textureowns`: 2,
}

var _ValFlagsDescMap = map[ValFlags]string{
	0: `ValMod the value has been modified`,
	1: `ValPaddedArray array had to be padded -- cannot access elements continuously`,
	2: `ValTextureOwns val owns and manages the host staging memory for texture. based on Var TextureOwns -- for dynamically changings images.`,
}

var _ValFlagsMap = map[ValFlags]string{
	0: `Mod`,
	1: `PaddedArray`,
	2: `TextureOwns`,
}

// String returns the string representation
// of this ValFlags value.
func (i ValFlags) String() string {
	str := ""
	for _, ie := range _ValFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this ValFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i ValFlags) BitIndexString() string {
	if str, ok := _ValFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the ValFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *ValFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the ValFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *ValFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _ValFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _ValFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type ValFlags")
		}
	}
	return nil
}

// Int64 returns the ValFlags value as an int64.
func (i ValFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the ValFlags value from an int64.
func (i *ValFlags) SetInt64(in int64) {
	*i = ValFlags(in)
}

// Desc returns the description of the ValFlags value.
func (i ValFlags) Desc() string {
	if str, ok := _ValFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// ValFlagsValues returns all possible values
// for the type ValFlags.
func ValFlagsValues() []ValFlags {
	return _ValFlagsValues
}

// Values returns all possible values
// for the type ValFlags.
func (i ValFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_ValFlagsValues))
	for i, d := range _ValFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type ValFlags.
func (i ValFlags) IsValid() bool {
	_, ok := _ValFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i ValFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *ValFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ValFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ValFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}
