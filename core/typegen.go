// Code generated by "core generate"; DO NOT EDIT.

package core

import (
	"image"
	"image/color"
	"reflect"
	"time"

	"cogentcore.org/core/events"
	"cogentcore.org/core/events/key"
	"cogentcore.org/core/icons"
	"cogentcore.org/core/keymap"
	"cogentcore.org/core/math32"
	"cogentcore.org/core/paint"
	"cogentcore.org/core/styles/units"
	"cogentcore.org/core/text/parse/complete"
	"cogentcore.org/core/tree"
	"cogentcore.org/core/types"
)

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.App", IDName: "app", Doc: "App represents a Cogent Core app. It extends [system.App] to provide both system-level\nand high-level data and functions to do with the currently running application. The\nsingle instance of it is [TheApp], which embeds [system.TheApp].", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Embeds: []types.Field{{Name: "App"}}, Fields: []types.Field{{Name: "SceneInit", Doc: "SceneInit is a function called on every newly created [Scene].\nThis can be used to set global configuration and styling for all\nwidgets in conjunction with [Scene.WidgetInit]."}}})

// SetSceneInit sets the [App.SceneInit]:
// SceneInit is a function called on every newly created [Scene].
// This can be used to set global configuration and styling for all
// widgets in conjunction with [Scene.WidgetInit].
func (t *App) SetSceneInit(v func(sc *Scene)) *App { t.SceneInit = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Body", IDName: "body", Doc: "Body holds the primary content of a [Scene].\nIt is the main container for app content.", Directives: []types.Directive{{Tool: "core", Directive: "no-new"}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Title", Doc: "Title is the title of the body, which is also\nused for the window title where relevant."}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Button", IDName: "button", Doc: "Button is an interactive button with text, an icon, an indicator, a shortcut,\nand/or a menu. The standard behavior is to register a click event handler with\n[WidgetBase.OnClick].", Directives: []types.Directive{{Tool: "core", Directive: "embedder"}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Type", Doc: "Type is the type of button."}, {Name: "Text", Doc: "Text is the text for the button.\nIf it is blank, no text is shown."}, {Name: "Icon", Doc: "Icon is the icon for the button.\nIf it is \"\" or [icons.None], no icon is shown."}, {Name: "Indicator", Doc: "Indicator is the menu indicator icon to present.\nIf it is \"\" or [icons.None],, no indicator is shown.\nIt is automatically set to [icons.KeyboardArrowDown]\nwhen there is a Menu elements present unless it is\nset to [icons.None]."}, {Name: "Shortcut", Doc: "Shortcut is an optional shortcut keyboard chord to trigger this button,\nactive in window-wide scope. Avoid conflicts with other shortcuts\n(a log message will be emitted if so). Shortcuts are processed after\nall other processing of keyboard input. Command is automatically translated\ninto Meta on macOS and Control on all other platforms. Also see [Button.SetKey]."}, {Name: "Menu", Doc: "Menu is a menu constructor function used to build and display\na menu whenever the button is clicked. There will be no menu\nif it is nil. The constructor function should add buttons\nto the Scene that it is passed."}}})

// NewButton returns a new [Button] with the given optional parent:
// Button is an interactive button with text, an icon, an indicator, a shortcut,
// and/or a menu. The standard behavior is to register a click event handler with
// [WidgetBase.OnClick].
func NewButton(parent ...tree.Node) *Button { return tree.New[Button](parent...) }

// ButtonEmbedder is an interface that all types that embed Button satisfy
type ButtonEmbedder interface {
	AsButton() *Button
}

// AsButton returns the given value as a value of type Button if the type
// of the given value embeds Button, or nil otherwise
func AsButton(n tree.Node) *Button {
	if t, ok := n.(ButtonEmbedder); ok {
		return t.AsButton()
	}
	return nil
}

// AsButton satisfies the [ButtonEmbedder] interface
func (t *Button) AsButton() *Button { return t }

// SetType sets the [Button.Type]:
// Type is the type of button.
func (t *Button) SetType(v ButtonTypes) *Button { t.Type = v; return t }

// SetText sets the [Button.Text]:
// Text is the text for the button.
// If it is blank, no text is shown.
func (t *Button) SetText(v string) *Button { t.Text = v; return t }

// SetIcon sets the [Button.Icon]:
// Icon is the icon for the button.
// If it is "" or [icons.None], no icon is shown.
func (t *Button) SetIcon(v icons.Icon) *Button { t.Icon = v; return t }

// SetIndicator sets the [Button.Indicator]:
// Indicator is the menu indicator icon to present.
// If it is "" or [icons.None],, no indicator is shown.
// It is automatically set to [icons.KeyboardArrowDown]
// when there is a Menu elements present unless it is
// set to [icons.None].
func (t *Button) SetIndicator(v icons.Icon) *Button { t.Indicator = v; return t }

// SetShortcut sets the [Button.Shortcut]:
// Shortcut is an optional shortcut keyboard chord to trigger this button,
// active in window-wide scope. Avoid conflicts with other shortcuts
// (a log message will be emitted if so). Shortcuts are processed after
// all other processing of keyboard input. Command is automatically translated
// into Meta on macOS and Control on all other platforms. Also see [Button.SetKey].
func (t *Button) SetShortcut(v key.Chord) *Button { t.Shortcut = v; return t }

// SetMenu sets the [Button.Menu]:
// Menu is a menu constructor function used to build and display
// a menu whenever the button is clicked. There will be no menu
// if it is nil. The constructor function should add buttons
// to the Scene that it is passed.
func (t *Button) SetMenu(v func(m *Scene)) *Button { t.Menu = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Canvas", IDName: "canvas", Doc: "Canvas is a widget that can be arbitrarily drawn to by setting\nits Draw function using [Canvas.SetDraw].", Embeds: []types.Field{{Name: "WidgetBase"}}, Fields: []types.Field{{Name: "Draw", Doc: "Draw is the function used to draw the content of the\ncanvas every time that it is rendered. The paint context\nis automatically normalized to the size of the canvas,\nso you should specify points on a 0-1 scale."}, {Name: "painter", Doc: "painter is the paint painter used for drawing."}}})

// NewCanvas returns a new [Canvas] with the given optional parent:
// Canvas is a widget that can be arbitrarily drawn to by setting
// its Draw function using [Canvas.SetDraw].
func NewCanvas(parent ...tree.Node) *Canvas { return tree.New[Canvas](parent...) }

// SetDraw sets the [Canvas.Draw]:
// Draw is the function used to draw the content of the
// canvas every time that it is rendered. The paint context
// is automatically normalized to the size of the canvas,
// so you should specify points on a 0-1 scale.
func (t *Canvas) SetDraw(v func(pc *paint.Painter)) *Canvas { t.Draw = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Chooser", IDName: "chooser", Doc: "Chooser is a dropdown selection widget that allows users to choose\none option among a list of items.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Type", Doc: "Type is the styling type of the chooser."}, {Name: "Items", Doc: "Items are the chooser items available for selection."}, {Name: "Icon", Doc: "Icon is an optional icon displayed on the left side of the chooser."}, {Name: "Indicator", Doc: "Indicator is the icon to use for the indicator displayed on the\nright side of the chooser."}, {Name: "Editable", Doc: "Editable is whether provide a text field for editing the value,\nor just a button for selecting items."}, {Name: "AllowNew", Doc: "AllowNew is whether to allow the user to add new items to the\nchooser through the editable textfield (if Editable is set to\ntrue) and a button at the end of the chooser menu. See also [DefaultNew]."}, {Name: "DefaultNew", Doc: "DefaultNew configures the chooser to accept new items, as in\n[AllowNew], and also turns off completion popups and always\nadds new items to the list of items, without prompting.\nUse this for cases where the typical use-case is to enter new values,\nbut the history of prior values can also be useful."}, {Name: "placeholder", Doc: "placeholder, if Editable is set to true, is the text that is\ndisplayed in the text field when it is empty. It must be set\nusing [Chooser.SetPlaceholder]."}, {Name: "ItemsFuncs", Doc: "ItemsFuncs is a slice of functions to call before showing the items\nof the chooser, which is typically used to configure them\n(eg: if they are based on dynamic data). The functions are called\nin ascending order such that the items added in the first function\nwill appear before those added in the last function. Use\n[Chooser.AddItemsFunc] to add a new items function. If at least\none ItemsFunc is specified, the items of the chooser will be\ncleared before calling the functions."}, {Name: "CurrentItem", Doc: "CurrentItem is the currently selected item."}, {Name: "CurrentIndex", Doc: "CurrentIndex is the index of the currently selected item\nin [Chooser.Items]."}, {Name: "text"}, {Name: "textField"}}})

// NewChooser returns a new [Chooser] with the given optional parent:
// Chooser is a dropdown selection widget that allows users to choose
// one option among a list of items.
func NewChooser(parent ...tree.Node) *Chooser { return tree.New[Chooser](parent...) }

// SetType sets the [Chooser.Type]:
// Type is the styling type of the chooser.
func (t *Chooser) SetType(v ChooserTypes) *Chooser { t.Type = v; return t }

// SetItems sets the [Chooser.Items]:
// Items are the chooser items available for selection.
func (t *Chooser) SetItems(v ...ChooserItem) *Chooser { t.Items = v; return t }

// SetIcon sets the [Chooser.Icon]:
// Icon is an optional icon displayed on the left side of the chooser.
func (t *Chooser) SetIcon(v icons.Icon) *Chooser { t.Icon = v; return t }

// SetIndicator sets the [Chooser.Indicator]:
// Indicator is the icon to use for the indicator displayed on the
// right side of the chooser.
func (t *Chooser) SetIndicator(v icons.Icon) *Chooser { t.Indicator = v; return t }

// SetEditable sets the [Chooser.Editable]:
// Editable is whether provide a text field for editing the value,
// or just a button for selecting items.
func (t *Chooser) SetEditable(v bool) *Chooser { t.Editable = v; return t }

// SetAllowNew sets the [Chooser.AllowNew]:
// AllowNew is whether to allow the user to add new items to the
// chooser through the editable textfield (if Editable is set to
// true) and a button at the end of the chooser menu. See also [DefaultNew].
func (t *Chooser) SetAllowNew(v bool) *Chooser { t.AllowNew = v; return t }

// SetDefaultNew sets the [Chooser.DefaultNew]:
// DefaultNew configures the chooser to accept new items, as in
// [AllowNew], and also turns off completion popups and always
// adds new items to the list of items, without prompting.
// Use this for cases where the typical use-case is to enter new values,
// but the history of prior values can also be useful.
func (t *Chooser) SetDefaultNew(v bool) *Chooser { t.DefaultNew = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Collapser", IDName: "collapser", Doc: "Collapser is a widget that can be collapsed or expanded by a user.\nThe [Collapser.Summary] is always visible, and the [Collapser.Details]\nare only visible when the [Collapser] is expanded with [Collapser.Open]\nequal to true.\n\nYou can directly add any widgets to the [Collapser.Summary] and [Collapser.Details]\nby specifying one of them as the parent in calls to New{WidgetName}.\nCollapser is similar to HTML's <details> and <summary> tags.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Open", Doc: "Open is whether the collapser is currently expanded. It defaults to false."}, {Name: "Summary", Doc: "Summary is the part of the collapser that is always visible."}, {Name: "Details", Doc: "Details is the part of the collapser that is only visible when\nthe collapser is expanded."}}})

// NewCollapser returns a new [Collapser] with the given optional parent:
// Collapser is a widget that can be collapsed or expanded by a user.
// The [Collapser.Summary] is always visible, and the [Collapser.Details]
// are only visible when the [Collapser] is expanded with [Collapser.Open]
// equal to true.
//
// You can directly add any widgets to the [Collapser.Summary] and [Collapser.Details]
// by specifying one of them as the parent in calls to New{WidgetName}.
// Collapser is similar to HTML's <details> and <summary> tags.
func NewCollapser(parent ...tree.Node) *Collapser { return tree.New[Collapser](parent...) }

// SetOpen sets the [Collapser.Open]:
// Open is whether the collapser is currently expanded. It defaults to false.
func (t *Collapser) SetOpen(v bool) *Collapser { t.Open = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.ColorMapButton", IDName: "color-map-button", Doc: "ColorMapButton displays a [colormap.Map] and can be clicked on\nto display a dialog for selecting different color map options.\nIt represents a [ColorMapName] value.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "MapName"}}})

// NewColorMapButton returns a new [ColorMapButton] with the given optional parent:
// ColorMapButton displays a [colormap.Map] and can be clicked on
// to display a dialog for selecting different color map options.
// It represents a [ColorMapName] value.
func NewColorMapButton(parent ...tree.Node) *ColorMapButton {
	return tree.New[ColorMapButton](parent...)
}

// SetMapName sets the [ColorMapButton.MapName]
func (t *ColorMapButton) SetMapName(v string) *ColorMapButton { t.MapName = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.ColorPicker", IDName: "color-picker", Doc: "ColorPicker represents a color value with an interactive color picker\ncomposed of history buttons, a hex input, three HCT sliders, and standard\nnamed color buttons.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Color", Doc: "Color is the current color."}}})

// NewColorPicker returns a new [ColorPicker] with the given optional parent:
// ColorPicker represents a color value with an interactive color picker
// composed of history buttons, a hex input, three HCT sliders, and standard
// named color buttons.
func NewColorPicker(parent ...tree.Node) *ColorPicker { return tree.New[ColorPicker](parent...) }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.ColorButton", IDName: "color-button", Doc: "ColorButton represents a color value with a button that opens a [ColorPicker].", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Color"}}})

// NewColorButton returns a new [ColorButton] with the given optional parent:
// ColorButton represents a color value with a button that opens a [ColorPicker].
func NewColorButton(parent ...tree.Node) *ColorButton { return tree.New[ColorButton](parent...) }

// SetColor sets the [ColorButton.Color]
func (t *ColorButton) SetColor(v color.RGBA) *ColorButton { t.Color = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Complete", IDName: "complete", Doc: "Complete holds the current completion data and functions to call for building\nthe list of possible completions and for editing text after a completion is selected.\nIt also holds the popup [Stage] associated with it.", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Fields: []types.Field{{Name: "MatchFunc", Doc: "function to get the list of possible completions"}, {Name: "LookupFunc", Doc: "function to get the text to show for lookup"}, {Name: "EditFunc", Doc: "function to edit text using the selected completion"}, {Name: "Context", Doc: "the context object that implements the completion functions"}, {Name: "SrcLn", Doc: "line number in source that completion is operating on, if relevant"}, {Name: "SrcCh", Doc: "character position in source that completion is operating on"}, {Name: "completions", Doc: "the list of potential completions"}, {Name: "Seed", Doc: "current completion seed"}, {Name: "Completion", Doc: "the user's completion selection"}, {Name: "listeners", Doc: "the event listeners for the completer (it sends [events.Select] events)"}, {Name: "stage", Doc: "stage is the popup [Stage] associated with the [Complete]."}, {Name: "delayTimer"}, {Name: "delayMu"}, {Name: "showMu"}}})

// SetMatchFunc sets the [Complete.MatchFunc]:
// function to get the list of possible completions
func (t *Complete) SetMatchFunc(v complete.MatchFunc) *Complete { t.MatchFunc = v; return t }

// SetLookupFunc sets the [Complete.LookupFunc]:
// function to get the text to show for lookup
func (t *Complete) SetLookupFunc(v complete.LookupFunc) *Complete { t.LookupFunc = v; return t }

// SetEditFunc sets the [Complete.EditFunc]:
// function to edit text using the selected completion
func (t *Complete) SetEditFunc(v complete.EditFunc) *Complete { t.EditFunc = v; return t }

// SetContext sets the [Complete.Context]:
// the context object that implements the completion functions
func (t *Complete) SetContext(v any) *Complete { t.Context = v; return t }

// SetSrcLn sets the [Complete.SrcLn]:
// line number in source that completion is operating on, if relevant
func (t *Complete) SetSrcLn(v int) *Complete { t.SrcLn = v; return t }

// SetSrcCh sets the [Complete.SrcCh]:
// character position in source that completion is operating on
func (t *Complete) SetSrcCh(v int) *Complete { t.SrcCh = v; return t }

// SetSeed sets the [Complete.Seed]:
// current completion seed
func (t *Complete) SetSeed(v string) *Complete { t.Seed = v; return t }

// SetCompletion sets the [Complete.Completion]:
// the user's completion selection
func (t *Complete) SetCompletion(v string) *Complete { t.Completion = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.FilePicker", IDName: "file-picker", Doc: "FilePicker is a widget for selecting files.", Methods: []types.Method{{Name: "updateFilesEvent", Doc: "updateFilesEvent updates the list of files and other views for the current path.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "addPathToFavorites", Doc: "addPathToFavorites adds the current path to favorites", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "directoryUp", Doc: "directoryUp moves up one directory in the path", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "newFolder", Doc: "newFolder creates a new folder with the given name in the current directory.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"name"}, Returns: []string{"error"}}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Filterer", Doc: "Filterer is an optional filtering function for which files to display."}, {Name: "directory", Doc: "directory is the absolute path to the directory of files to display."}, {Name: "selectedFilename", Doc: "selectedFilename is the name of the currently selected file,\nnot including the directory. See [FilePicker.SelectedFile]\nfor the full path."}, {Name: "extensions", Doc: "extensions is a list of the target file extensions.\nIf there are multiple, they must be comma separated.\nThe extensions must include the dot (\".\") at the start.\nThey must be set using [FilePicker.SetExtensions]."}, {Name: "extensionMap", Doc: "extensionMap is a map of lower-cased extensions from Extensions.\nIt used for highlighting files with one of these extensions;\nmaps onto original Extensions value."}, {Name: "files", Doc: "files for current directory"}, {Name: "selectedIndex", Doc: "index of currently selected file in Files list (-1 if none)"}, {Name: "watcher", Doc: "change notify for current dir"}, {Name: "doneWatcher", Doc: "channel to close watcher watcher"}, {Name: "prevPath", Doc: "Previous path that was processed via UpdateFiles"}, {Name: "favoritesTable"}, {Name: "filesTable"}, {Name: "selectField"}, {Name: "extensionField"}}})

// NewFilePicker returns a new [FilePicker] with the given optional parent:
// FilePicker is a widget for selecting files.
func NewFilePicker(parent ...tree.Node) *FilePicker { return tree.New[FilePicker](parent...) }

// SetFilterer sets the [FilePicker.Filterer]:
// Filterer is an optional filtering function for which files to display.
func (t *FilePicker) SetFilterer(v FilePickerFilterer) *FilePicker { t.Filterer = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.FileButton", IDName: "file-button", Doc: "FileButton represents a [Filename] value with a button\nthat opens a [FilePicker].", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Filename"}, {Name: "Extensions", Doc: "Extensions are the target file extensions for the file picker."}}})

// NewFileButton returns a new [FileButton] with the given optional parent:
// FileButton represents a [Filename] value with a button
// that opens a [FilePicker].
func NewFileButton(parent ...tree.Node) *FileButton { return tree.New[FileButton](parent...) }

// SetFilename sets the [FileButton.Filename]
func (t *FileButton) SetFilename(v string) *FileButton { t.Filename = v; return t }

// SetExtensions sets the [FileButton.Extensions]:
// Extensions are the target file extensions for the file picker.
func (t *FileButton) SetExtensions(v string) *FileButton { t.Extensions = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Form", IDName: "form", Doc: "Form represents a struct with rows of field names and editable values.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Struct", Doc: "Struct is the pointer to the struct that we are viewing."}, {Name: "Inline", Doc: "Inline is whether to display the form in one line."}, {Name: "Modified", Doc: "Modified optionally highlights and tracks fields that have been modified\nthrough an OnChange event. If present, it replaces the default value highlighting\nand resetting logic. Ignored if nil."}, {Name: "structFields", Doc: "structFields are the fields of the current struct, keys are field paths."}, {Name: "isShouldDisplayer", Doc: "isShouldDisplayer is whether the struct implements [ShouldDisplayer], which results\nin additional updating being done at certain points."}}})

// NewForm returns a new [Form] with the given optional parent:
// Form represents a struct with rows of field names and editable values.
func NewForm(parent ...tree.Node) *Form { return tree.New[Form](parent...) }

// SetStruct sets the [Form.Struct]:
// Struct is the pointer to the struct that we are viewing.
func (t *Form) SetStruct(v any) *Form { t.Struct = v; return t }

// SetInline sets the [Form.Inline]:
// Inline is whether to display the form in one line.
func (t *Form) SetInline(v bool) *Form { t.Inline = v; return t }

// SetModified sets the [Form.Modified]:
// Modified optionally highlights and tracks fields that have been modified
// through an OnChange event. If present, it replaces the default value highlighting
// and resetting logic. Ignored if nil.
func (t *Form) SetModified(v map[string]bool) *Form { t.Modified = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Frame", IDName: "frame", Doc: "Frame is the primary node type responsible for organizing the sizes\nand positions of child widgets. It also renders the standard box model.\nAll collections of widgets should generally be contained within a [Frame];\notherwise, the parent widget must take over responsibility for positioning.\nFrames automatically can add scrollbars depending on the [styles.Style.Overflow].\n\nFor a [styles.Grid] frame, the [styles.Style.Columns] property should\ngenerally be set to the desired number of columns, from which the number of rows\nis computed; otherwise, it uses the square root of number of\nelements.", Embeds: []types.Field{{Name: "WidgetBase"}}, Fields: []types.Field{{Name: "StackTop", Doc: "StackTop, for a [styles.Stacked] frame, is the index of the node to use\nas the top of the stack. Only the node at this index is rendered; if it is\nnot a valid index, nothing is rendered."}, {Name: "LayoutStackTopOnly", Doc: "LayoutStackTopOnly is whether to only layout the top widget\n(specified by [Frame.StackTop]) for a [styles.Stacked] frame.\nThis is appropriate for widgets such as [Tabs], which do a full\nredraw on stack changes, but not for widgets such as [Switch]es\nwhich don't."}, {Name: "layout", Doc: "layout contains implementation state info for doing layout"}, {Name: "HasScroll", Doc: "HasScroll is whether scrollbars exist for each dimension."}, {Name: "Scrolls", Doc: "Scrolls are the scroll bars, which are fully managed as needed."}, {Name: "handleKeyNav", Doc: "handleKeyNav indicates whether this frame should handle keyboard\nnavigation events using the default handlers. Set to false to allow\ncustom event handling."}, {Name: "focusName", Doc: "accumulated name to search for when keys are typed"}, {Name: "focusNameTime", Doc: "time of last focus name event; for timeout"}, {Name: "focusNameLast", Doc: "last element focused on; used as a starting point if name is the same"}}})

// NewFrame returns a new [Frame] with the given optional parent:
// Frame is the primary node type responsible for organizing the sizes
// and positions of child widgets. It also renders the standard box model.
// All collections of widgets should generally be contained within a [Frame];
// otherwise, the parent widget must take over responsibility for positioning.
// Frames automatically can add scrollbars depending on the [styles.Style.Overflow].
//
// For a [styles.Grid] frame, the [styles.Style.Columns] property should
// generally be set to the desired number of columns, from which the number of rows
// is computed; otherwise, it uses the square root of number of
// elements.
func NewFrame(parent ...tree.Node) *Frame { return tree.New[Frame](parent...) }

// SetStackTop sets the [Frame.StackTop]:
// StackTop, for a [styles.Stacked] frame, is the index of the node to use
// as the top of the stack. Only the node at this index is rendered; if it is
// not a valid index, nothing is rendered.
func (t *Frame) SetStackTop(v int) *Frame { t.StackTop = v; return t }

// SetLayoutStackTopOnly sets the [Frame.LayoutStackTopOnly]:
// LayoutStackTopOnly is whether to only layout the top widget
// (specified by [Frame.StackTop]) for a [styles.Stacked] frame.
// This is appropriate for widgets such as [Tabs], which do a full
// redraw on stack changes, but not for widgets such as [Switch]es
// which don't.
func (t *Frame) SetLayoutStackTopOnly(v bool) *Frame { t.LayoutStackTopOnly = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Stretch", IDName: "stretch", Doc: "Stretch adds a stretchy element that grows to fill all\navailable space. You can set [styles.Style.Grow] to change\nhow much it grows relative to other growing elements.\nIt does not render anything.", Embeds: []types.Field{{Name: "WidgetBase"}}})

// NewStretch returns a new [Stretch] with the given optional parent:
// Stretch adds a stretchy element that grows to fill all
// available space. You can set [styles.Style.Grow] to change
// how much it grows relative to other growing elements.
// It does not render anything.
func NewStretch(parent ...tree.Node) *Stretch { return tree.New[Stretch](parent...) }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Space", IDName: "space", Doc: "Space is a fixed size blank space, with\na default width of 1ch and a height of 1em.\nYou can set [styles.Style.Min] to change its size.\nIt does not render anything.", Embeds: []types.Field{{Name: "WidgetBase"}}})

// NewSpace returns a new [Space] with the given optional parent:
// Space is a fixed size blank space, with
// a default width of 1ch and a height of 1em.
// You can set [styles.Style.Min] to change its size.
// It does not render anything.
func NewSpace(parent ...tree.Node) *Space { return tree.New[Space](parent...) }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.FuncButton", IDName: "func-button", Doc: "FuncButton is a button that is set up to call a function when it\nis pressed, using a dialog to prompt the user for any arguments.\nAlso, it automatically sets various properties of the button like\nthe text and tooltip based on the properties of the function,\nusing [reflect] and [types]. The function must be registered\nwith [types] to get documentation information, but that is not\nrequired; add a `//types:add` comment directive and run `core generate`\nif you want tooltips. If the function is a method, both the method and\nits receiver type must be added to [types] to get documentation.\nThe main function to call first is [FuncButton.SetFunc].", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "typesFunc", Doc: "typesFunc is the [types.Func] associated with this button.\nThis function can also be a method, but it must be\nconverted to a [types.Func] first. It should typically\nbe set using [FuncButton.SetFunc]."}, {Name: "reflectFunc", Doc: "reflectFunc is the [reflect.Value] of the function or\nmethod associated with this button. It should typically\nbet set using [FuncButton.SetFunc]."}, {Name: "Args", Doc: "Args are the [FuncArg] objects associated with the\narguments of the function. They are automatically set in\n[FuncButton.SetFunc], but they can be customized to configure\ndefault values and other options."}, {Name: "Returns", Doc: "Returns are the [FuncArg] objects associated with the\nreturn values of the function. They are automatically\nset in [FuncButton.SetFunc], but they can be customized\nto configure options. The [FuncArg.Value]s are not set until\nthe function is called, and are thus not typically applicable\nto access."}, {Name: "Confirm", Doc: "Confirm is whether to prompt the user for confirmation\nbefore calling the function."}, {Name: "ShowReturn", Doc: "ShowReturn is whether to display the return values of\nthe function (and a success message if there are none).\nThe way that the return values are shown is determined\nby ShowReturnAsDialog. Non-nil error return values will\nalways be shown, even if ShowReturn is set to false."}, {Name: "ShowReturnAsDialog", Doc: "ShowReturnAsDialog, if and only if ShowReturn is true,\nindicates to show the return values of the function in\na dialog, instead of in a snackbar, as they are by default.\nIf there are multiple return values from the function, or if\none of them is a complex type (pointer, struct, slice,\narray, map), then ShowReturnAsDialog will\nautomatically be set to true."}, {Name: "NewWindow", Doc: "NewWindow makes the return value dialog a NewWindow dialog."}, {Name: "WarnUnadded", Doc: "WarnUnadded is whether to log warnings when a function that\nhas not been added to [types] is used. It is on by default and\nmust be set before [FuncButton.SetFunc] is called for it to\nhave any effect. Warnings are never logged for anonymous functions."}, {Name: "Context", Doc: "Context is used for opening dialogs if non-nil."}, {Name: "AfterFunc", Doc: "AfterFunc is an optional function called after the func button\nfunction is executed."}}})

// NewFuncButton returns a new [FuncButton] with the given optional parent:
// FuncButton is a button that is set up to call a function when it
// is pressed, using a dialog to prompt the user for any arguments.
// Also, it automatically sets various properties of the button like
// the text and tooltip based on the properties of the function,
// using [reflect] and [types]. The function must be registered
// with [types] to get documentation information, but that is not
// required; add a `//types:add` comment directive and run `core generate`
// if you want tooltips. If the function is a method, both the method and
// its receiver type must be added to [types] to get documentation.
// The main function to call first is [FuncButton.SetFunc].
func NewFuncButton(parent ...tree.Node) *FuncButton { return tree.New[FuncButton](parent...) }

// SetConfirm sets the [FuncButton.Confirm]:
// Confirm is whether to prompt the user for confirmation
// before calling the function.
func (t *FuncButton) SetConfirm(v bool) *FuncButton { t.Confirm = v; return t }

// SetShowReturn sets the [FuncButton.ShowReturn]:
// ShowReturn is whether to display the return values of
// the function (and a success message if there are none).
// The way that the return values are shown is determined
// by ShowReturnAsDialog. Non-nil error return values will
// always be shown, even if ShowReturn is set to false.
func (t *FuncButton) SetShowReturn(v bool) *FuncButton { t.ShowReturn = v; return t }

// SetShowReturnAsDialog sets the [FuncButton.ShowReturnAsDialog]:
// ShowReturnAsDialog, if and only if ShowReturn is true,
// indicates to show the return values of the function in
// a dialog, instead of in a snackbar, as they are by default.
// If there are multiple return values from the function, or if
// one of them is a complex type (pointer, struct, slice,
// array, map), then ShowReturnAsDialog will
// automatically be set to true.
func (t *FuncButton) SetShowReturnAsDialog(v bool) *FuncButton { t.ShowReturnAsDialog = v; return t }

// SetNewWindow sets the [FuncButton.NewWindow]:
// NewWindow makes the return value dialog a NewWindow dialog.
func (t *FuncButton) SetNewWindow(v bool) *FuncButton { t.NewWindow = v; return t }

// SetWarnUnadded sets the [FuncButton.WarnUnadded]:
// WarnUnadded is whether to log warnings when a function that
// has not been added to [types] is used. It is on by default and
// must be set before [FuncButton.SetFunc] is called for it to
// have any effect. Warnings are never logged for anonymous functions.
func (t *FuncButton) SetWarnUnadded(v bool) *FuncButton { t.WarnUnadded = v; return t }

// SetContext sets the [FuncButton.Context]:
// Context is used for opening dialogs if non-nil.
func (t *FuncButton) SetContext(v Widget) *FuncButton { t.Context = v; return t }

// SetAfterFunc sets the [FuncButton.AfterFunc]:
// AfterFunc is an optional function called after the func button
// function is executed.
func (t *FuncButton) SetAfterFunc(v func()) *FuncButton { t.AfterFunc = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.FuncArg", IDName: "func-arg", Doc: "FuncArg represents one argument or return value of a function\nin the context of a [FuncButton].", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Fields: []types.Field{{Name: "Name", Doc: "Name is the name of the argument or return value."}, {Name: "Tag", Doc: "Tag contains any tags associated with the argument or return value,\nwhich can be added programmatically to customize [Value] behavior."}, {Name: "Value", Doc: "Value is the actual value of the function argument or return value.\nIt can be modified when creating a [FuncButton] to set a default value."}}})

// SetName sets the [FuncArg.Name]:
// Name is the name of the argument or return value.
func (t *FuncArg) SetName(v string) *FuncArg { t.Name = v; return t }

// SetTag sets the [FuncArg.Tag]:
// Tag contains any tags associated with the argument or return value,
// which can be added programmatically to customize [Value] behavior.
func (t *FuncArg) SetTag(v reflect.StructTag) *FuncArg { t.Tag = v; return t }

// SetValue sets the [FuncArg.Value]:
// Value is the actual value of the function argument or return value.
// It can be modified when creating a [FuncButton] to set a default value.
func (t *FuncArg) SetValue(v any) *FuncArg { t.Value = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Handle", IDName: "handle", Doc: "Handle represents a draggable handle that can be used to\ncontrol the size of an element. The [styles.Style.Direction]\ncontrols the direction in which the handle moves.", Embeds: []types.Field{{Name: "WidgetBase"}}, Fields: []types.Field{{Name: "Min", Doc: "Min is the minimum value that the handle can go to\n(typically the lower bound of the dialog/splits)"}, {Name: "Max", Doc: "Max is the maximum value that the handle can go to\n(typically the upper bound of the dialog/splits)"}, {Name: "Pos", Doc: "Pos is the current position of the handle on the\nscale of [Handle.Min] to [Handle.Max]."}}})

// NewHandle returns a new [Handle] with the given optional parent:
// Handle represents a draggable handle that can be used to
// control the size of an element. The [styles.Style.Direction]
// controls the direction in which the handle moves.
func NewHandle(parent ...tree.Node) *Handle { return tree.New[Handle](parent...) }

// SetMin sets the [Handle.Min]:
// Min is the minimum value that the handle can go to
// (typically the lower bound of the dialog/splits)
func (t *Handle) SetMin(v float32) *Handle { t.Min = v; return t }

// SetMax sets the [Handle.Max]:
// Max is the maximum value that the handle can go to
// (typically the upper bound of the dialog/splits)
func (t *Handle) SetMax(v float32) *Handle { t.Max = v; return t }

// SetPos sets the [Handle.Pos]:
// Pos is the current position of the handle on the
// scale of [Handle.Min] to [Handle.Max].
func (t *Handle) SetPos(v float32) *Handle { t.Pos = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Icon", IDName: "icon", Doc: "Icon renders an [icons.Icon].\nThe rendered version is cached for the current size.\nIcons do not render a background or border independent of their SVG object.\nThe size of an Icon is determined by the [styles.Font.Size] property.", Embeds: []types.Field{{Name: "WidgetBase"}}, Fields: []types.Field{{Name: "Icon", Doc: "Icon is the [icons.Icon] used to render the [Icon]."}, {Name: "prevIcon", Doc: "prevIcon is the previously rendered icon."}, {Name: "prevColor", Doc: "prevColor is the previously rendered color, as uniform."}, {Name: "prevOpacity", Doc: "prevOpacity is the previously rendered opacity."}, {Name: "pixels", Doc: "image representation of the icon, cached for faster drawing."}}})

// NewIcon returns a new [Icon] with the given optional parent:
// Icon renders an [icons.Icon].
// The rendered version is cached for the current size.
// Icons do not render a background or border independent of their SVG object.
// The size of an Icon is determined by the [styles.Font.Size] property.
func NewIcon(parent ...tree.Node) *Icon { return tree.New[Icon](parent...) }

// SetIcon sets the [Icon.Icon]:
// Icon is the [icons.Icon] used to render the [Icon].
func (t *Icon) SetIcon(v icons.Icon) *Icon { t.Icon = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Image", IDName: "image", Doc: "Image is a widget that renders an [image.Image].\nSee [styles.Style.ObjectFit] to control the image rendering within\nthe allocated size. The default minimum requested size is the pixel\nsize in [units.Dp] units (1/160th of an inch).", Methods: []types.Method{{Name: "Open", Doc: "Open sets the image to the image located at the given filename.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}}, Embeds: []types.Field{{Name: "WidgetBase"}}, Fields: []types.Field{{Name: "Image", Doc: "Image is the [image.Image]."}, {Name: "prevImage", Doc: "prevImage is the cached last [Image.Image]."}, {Name: "prevRenderImage", Doc: "prevRenderImage is the cached last rendered image with any transformations applied."}, {Name: "prevObjectFit", Doc: "prevObjectFit is the cached [styles.Style.ObjectFit] of the last rendered image."}, {Name: "prevSize", Doc: "prevSize is the cached allocated size for the last rendered image."}}})

// NewImage returns a new [Image] with the given optional parent:
// Image is a widget that renders an [image.Image].
// See [styles.Style.ObjectFit] to control the image rendering within
// the allocated size. The default minimum requested size is the pixel
// size in [units.Dp] units (1/160th of an inch).
func NewImage(parent ...tree.Node) *Image { return tree.New[Image](parent...) }

// SetImage sets the [Image.Image]:
// Image is the [image.Image].
func (t *Image) SetImage(v image.Image) *Image { t.Image = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.InlineList", IDName: "inline-list", Doc: "InlineList represents a slice within a single line of value widgets.\nThis is typically used for smaller slices.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Slice", Doc: "Slice is the slice that we are viewing."}, {Name: "isArray", Doc: "isArray is whether the slice is actually an array."}}})

// NewInlineList returns a new [InlineList] with the given optional parent:
// InlineList represents a slice within a single line of value widgets.
// This is typically used for smaller slices.
func NewInlineList(parent ...tree.Node) *InlineList { return tree.New[InlineList](parent...) }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Inspector", IDName: "inspector", Doc: "Inspector represents a [tree.Node] with a [Tree] and a [Form].", Methods: []types.Method{{Name: "save", Doc: "save saves the tree to current filename, in a standard JSON-formatted file.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"error"}}, {Name: "saveAs", Doc: "saveAs saves tree to given filename, in a standard JSON-formatted file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "open", Doc: "open opens tree from given filename, in a standard JSON-formatted file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "toggleSelectionMode", Doc: "toggleSelectionMode toggles the editor between selection mode or not.\nIn selection mode, bounding boxes are rendered around each Widget,\nand clicking on a Widget pulls it up in the inspector.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "inspectApp", Doc: "inspectApp displays [TheApp].", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Root", Doc: "Root is the root of the tree being edited."}, {Name: "currentNode", Doc: "currentNode is the currently selected node in the tree."}, {Name: "filename", Doc: "filename is the current filename for saving / loading"}, {Name: "treeWidget"}}})

// NewInspector returns a new [Inspector] with the given optional parent:
// Inspector represents a [tree.Node] with a [Tree] and a [Form].
func NewInspector(parent ...tree.Node) *Inspector { return tree.New[Inspector](parent...) }

// SetRoot sets the [Inspector.Root]:
// Root is the root of the tree being edited.
func (t *Inspector) SetRoot(v tree.Node) *Inspector { t.Root = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.KeyMapButton", IDName: "key-map-button", Doc: "KeyMapButton represents a [keymap.MapName] value with a button.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "MapName"}}})

// NewKeyMapButton returns a new [KeyMapButton] with the given optional parent:
// KeyMapButton represents a [keymap.MapName] value with a button.
func NewKeyMapButton(parent ...tree.Node) *KeyMapButton { return tree.New[KeyMapButton](parent...) }

// SetMapName sets the [KeyMapButton.MapName]
func (t *KeyMapButton) SetMapName(v keymap.MapName) *KeyMapButton { t.MapName = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.KeyChordButton", IDName: "key-chord-button", Doc: "KeyChordButton represents a [key.Chord] value with a button.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Chord"}}})

// NewKeyChordButton returns a new [KeyChordButton] with the given optional parent:
// KeyChordButton represents a [key.Chord] value with a button.
func NewKeyChordButton(parent ...tree.Node) *KeyChordButton {
	return tree.New[KeyChordButton](parent...)
}

// SetChord sets the [KeyChordButton.Chord]
func (t *KeyChordButton) SetChord(v key.Chord) *KeyChordButton { t.Chord = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.KeyedList", IDName: "keyed-list", Doc: "KeyedList represents a map value using two columns of editable key and value widgets.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Map", Doc: "Map is the pointer to the map that we are viewing."}, {Name: "Inline", Doc: "Inline is whether to display the map in one line."}, {Name: "SortByValues", Doc: "SortByValues is whether to sort by values instead of keys."}, {Name: "ncols", Doc: "ncols is the number of columns to display if the keyed list is not inline."}}})

// NewKeyedList returns a new [KeyedList] with the given optional parent:
// KeyedList represents a map value using two columns of editable key and value widgets.
func NewKeyedList(parent ...tree.Node) *KeyedList { return tree.New[KeyedList](parent...) }

// SetMap sets the [KeyedList.Map]:
// Map is the pointer to the map that we are viewing.
func (t *KeyedList) SetMap(v any) *KeyedList { t.Map = v; return t }

// SetInline sets the [KeyedList.Inline]:
// Inline is whether to display the map in one line.
func (t *KeyedList) SetInline(v bool) *KeyedList { t.Inline = v; return t }

// SetSortByValues sets the [KeyedList.SortByValues]:
// SortByValues is whether to sort by values instead of keys.
func (t *KeyedList) SetSortByValues(v bool) *KeyedList { t.SortByValues = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.List", IDName: "list", Doc: "List represents a slice value with a list of value widgets and optional index widgets.\nUse [ListBase.BindSelect] to make the list designed for item selection.", Embeds: []types.Field{{Name: "ListBase"}}, Fields: []types.Field{{Name: "ListStyler", Doc: "ListStyler is an optional styler for list items."}}})

// NewList returns a new [List] with the given optional parent:
// List represents a slice value with a list of value widgets and optional index widgets.
// Use [ListBase.BindSelect] to make the list designed for item selection.
func NewList(parent ...tree.Node) *List { return tree.New[List](parent...) }

// SetListStyler sets the [List.ListStyler]:
// ListStyler is an optional styler for list items.
func (t *List) SetListStyler(v ListStyler) *List { t.ListStyler = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.ListBase", IDName: "list-base", Doc: "ListBase is the base for [List] and [Table] and any other displays\nof array-like data. It automatically computes the number of rows that fit\nwithin its allocated space, and manages the offset view window into the full\nlist of items, and supports row selection, copy / paste, Drag-n-Drop, etc.\nUse [ListBase.BindSelect] to make the list designed for item selection.", Directives: []types.Directive{{Tool: "core", Directive: "no-new"}}, Methods: []types.Method{{Name: "copyIndexes", Doc: "copyIndexes copies selected idxs to system.Clipboard, optionally resetting the selection", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"reset"}}, {Name: "cutIndexes", Doc: "cutIndexes copies selected indexes to system.Clipboard and deletes selected indexes", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "pasteIndex", Doc: "pasteIndex pastes clipboard at given idx", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"idx"}}, {Name: "duplicate", Doc: "duplicate copies selected items and inserts them after current selection --\nreturn idx of start of duplicates if successful, else -1", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"int"}}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Slice", Doc: "Slice is the pointer to the slice that we are viewing."}, {Name: "ShowIndexes", Doc: "ShowIndexes is whether to show the indexes of rows or not (default false)."}, {Name: "MinRows", Doc: "MinRows specifies the minimum number of rows to display, to ensure\nat least this amount is displayed."}, {Name: "SelectedValue", Doc: "SelectedValue is the current selection value.\nIf it is set, it is used as the initially selected value."}, {Name: "SelectedIndex", Doc: "SelectedIndex is the index of the currently selected item."}, {Name: "InitSelectedIndex", Doc: "InitSelectedIndex is the index of the row to select at the start."}, {Name: "SelectedIndexes", Doc: "SelectedIndexes is a list of currently selected slice indexes."}, {Name: "lastClick", Doc: "lastClick is the last row that has been clicked on.\nThis is used to prevent erroneous double click events\nfrom being sent when the user clicks on multiple different\nrows in quick succession."}, {Name: "normalCursor", Doc: "normalCursor is the cached cursor to display when there\nis no row being hovered."}, {Name: "currentCursor", Doc: "currentCursor is the cached cursor that should currently be\ndisplayed."}, {Name: "sliceUnderlying", Doc: "sliceUnderlying is the underlying slice value."}, {Name: "hoverRow", Doc: "currently hovered row"}, {Name: "draggedIndexes", Doc: "list of currently dragged indexes"}, {Name: "VisibleRows", Doc: "VisibleRows is the total number of rows visible in allocated display size."}, {Name: "StartIndex", Doc: "StartIndex is the starting slice index of visible rows."}, {Name: "SliceSize", Doc: "SliceSize is the size of the slice."}, {Name: "MakeIter", Doc: "MakeIter is the iteration through the configuration process,\nwhich is reset when a new slice type is set."}, {Name: "tmpIndex", Doc: "temp idx state for e.g., dnd"}, {Name: "elementValue", Doc: "elementValue is a [reflect.Value] representation of the underlying element type\nwhich is used whenever there are no slice elements available"}, {Name: "maxWidth", Doc: "maximum width of value column in chars, if string"}, {Name: "ReadOnlyKeyNav", Doc: "ReadOnlyKeyNav is whether support key navigation when ReadOnly (default true).\nIt uses a capture of up / down events to manipulate selection, not focus."}, {Name: "SelectMode", Doc: "SelectMode is whether to be in select rows mode or editing mode."}, {Name: "ReadOnlyMultiSelect", Doc: "ReadOnlyMultiSelect: if list is ReadOnly, default selection mode is to\nchoose one row only. If this is true, standard multiple selection logic\nwith modifier keys is instead supported."}, {Name: "InFocusGrab", Doc: "InFocusGrab is a guard for recursive focus grabbing."}, {Name: "isArray", Doc: "isArray is whether the slice is actually an array."}, {Name: "ListGrid", Doc: "ListGrid is the [ListGrid] widget."}}})

// SetShowIndexes sets the [ListBase.ShowIndexes]:
// ShowIndexes is whether to show the indexes of rows or not (default false).
func (t *ListBase) SetShowIndexes(v bool) *ListBase { t.ShowIndexes = v; return t }

// SetMinRows sets the [ListBase.MinRows]:
// MinRows specifies the minimum number of rows to display, to ensure
// at least this amount is displayed.
func (t *ListBase) SetMinRows(v int) *ListBase { t.MinRows = v; return t }

// SetSelectedValue sets the [ListBase.SelectedValue]:
// SelectedValue is the current selection value.
// If it is set, it is used as the initially selected value.
func (t *ListBase) SetSelectedValue(v any) *ListBase { t.SelectedValue = v; return t }

// SetSelectedIndex sets the [ListBase.SelectedIndex]:
// SelectedIndex is the index of the currently selected item.
func (t *ListBase) SetSelectedIndex(v int) *ListBase { t.SelectedIndex = v; return t }

// SetInitSelectedIndex sets the [ListBase.InitSelectedIndex]:
// InitSelectedIndex is the index of the row to select at the start.
func (t *ListBase) SetInitSelectedIndex(v int) *ListBase { t.InitSelectedIndex = v; return t }

// SetReadOnlyKeyNav sets the [ListBase.ReadOnlyKeyNav]:
// ReadOnlyKeyNav is whether support key navigation when ReadOnly (default true).
// It uses a capture of up / down events to manipulate selection, not focus.
func (t *ListBase) SetReadOnlyKeyNav(v bool) *ListBase { t.ReadOnlyKeyNav = v; return t }

// SetReadOnlyMultiSelect sets the [ListBase.ReadOnlyMultiSelect]:
// ReadOnlyMultiSelect: if list is ReadOnly, default selection mode is to
// choose one row only. If this is true, standard multiple selection logic
// with modifier keys is instead supported.
func (t *ListBase) SetReadOnlyMultiSelect(v bool) *ListBase { t.ReadOnlyMultiSelect = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.ListGrid", IDName: "list-grid", Doc: "ListGrid handles the resizing logic for all [Lister]s.", Directives: []types.Directive{{Tool: "core", Directive: "no-new"}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "minRows", Doc: "minRows is set from parent [List]"}, {Name: "rowHeight", Doc: "height of a single row, computed during layout"}, {Name: "visibleRows", Doc: "total number of rows visible in allocated display size"}, {Name: "bgStripe", Doc: "Various computed backgrounds"}, {Name: "bgSelect", Doc: "Various computed backgrounds"}, {Name: "bgSelectStripe", Doc: "Various computed backgrounds"}, {Name: "bgHover", Doc: "Various computed backgrounds"}, {Name: "bgHoverStripe", Doc: "Various computed backgrounds"}, {Name: "bgHoverSelect", Doc: "Various computed backgrounds"}, {Name: "bgHoverSelectStripe", Doc: "Various computed backgrounds"}, {Name: "lastBackground", Doc: "lastBackground is the background for which modified\nbackgrounds were computed -- don't update if same"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Meter", IDName: "meter", Doc: "Meter is a widget that renders a current value on as a filled\nbar/circle/semicircle relative to a minimum and maximum potential\nvalue.", Embeds: []types.Field{{Name: "WidgetBase"}}, Fields: []types.Field{{Name: "Type", Doc: "Type is the styling type of the meter."}, {Name: "Value", Doc: "Value is the current value of the meter.\nIt defaults to 0.5."}, {Name: "Min", Doc: "Min is the minimum possible value of the meter.\nIt defaults to 0."}, {Name: "Max", Doc: "Max is the maximum possible value of the meter.\nIt defaults to 1."}, {Name: "Text", Doc: "Text, for [MeterCircle] and [MeterSemicircle], is the\ntext to render inside of the circle/semicircle."}, {Name: "ValueColor", Doc: "ValueColor is the image color that will be used to\nrender the filled value bar. It should be set in a Styler."}, {Name: "Width", Doc: "Width, for [MeterCircle] and [MeterSemicircle], is the\nwidth of the circle/semicircle. It should be set in a Styler."}}})

// NewMeter returns a new [Meter] with the given optional parent:
// Meter is a widget that renders a current value on as a filled
// bar/circle/semicircle relative to a minimum and maximum potential
// value.
func NewMeter(parent ...tree.Node) *Meter { return tree.New[Meter](parent...) }

// SetType sets the [Meter.Type]:
// Type is the styling type of the meter.
func (t *Meter) SetType(v MeterTypes) *Meter { t.Type = v; return t }

// SetValue sets the [Meter.Value]:
// Value is the current value of the meter.
// It defaults to 0.5.
func (t *Meter) SetValue(v float32) *Meter { t.Value = v; return t }

// SetMin sets the [Meter.Min]:
// Min is the minimum possible value of the meter.
// It defaults to 0.
func (t *Meter) SetMin(v float32) *Meter { t.Min = v; return t }

// SetMax sets the [Meter.Max]:
// Max is the maximum possible value of the meter.
// It defaults to 1.
func (t *Meter) SetMax(v float32) *Meter { t.Max = v; return t }

// SetText sets the [Meter.Text]:
// Text, for [MeterCircle] and [MeterSemicircle], is the
// text to render inside of the circle/semicircle.
func (t *Meter) SetText(v string) *Meter { t.Text = v; return t }

// SetValueColor sets the [Meter.ValueColor]:
// ValueColor is the image color that will be used to
// render the filled value bar. It should be set in a Styler.
func (t *Meter) SetValueColor(v image.Image) *Meter { t.ValueColor = v; return t }

// SetWidth sets the [Meter.Width]:
// Width, for [MeterCircle] and [MeterSemicircle], is the
// width of the circle/semicircle. It should be set in a Styler.
func (t *Meter) SetWidth(v units.Value) *Meter { t.Width = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Pages", IDName: "pages", Doc: "Pages is a frame that can easily swap its content between that of\ndifferent possible pages.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Page", Doc: "Page is the currently open page."}, {Name: "Pages", Doc: "Pages is a map of page names to functions that configure a page."}, {Name: "page", Doc: "page is the currently rendered page."}}})

// NewPages returns a new [Pages] with the given optional parent:
// Pages is a frame that can easily swap its content between that of
// different possible pages.
func NewPages(parent ...tree.Node) *Pages { return tree.New[Pages](parent...) }

// SetPage sets the [Pages.Page]:
// Page is the currently open page.
func (t *Pages) SetPage(v string) *Pages { t.Page = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Scene", IDName: "scene", Doc: "Scene contains a [Widget] tree, rooted in an embedded [Frame] layout,\nwhich renders into its own [paint.Painter]. The [Scene] is set in a\n[Stage], which the [Scene] has a pointer to.\n\nEach [Scene] contains state specific to its particular usage\nwithin a given [Stage] and overall rendering context, representing the unit\nof rendering in the Cogent Core framework.", Directives: []types.Directive{{Tool: "core", Directive: "no-new"}}, Methods: []types.Method{{Name: "standardContextMenu", Doc: "standardContextMenu adds standard context menu items for the [Scene].", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"m"}}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Body", Doc: "Body provides the main contents of scenes that use control Bars\nto allow the main window contents to be specified separately\nfrom that dynamic control content.  When constructing scenes using\na [Body], you can operate directly on the [Body], which has wrappers\nfor most major Scene functions."}, {Name: "WidgetInit", Doc: "WidgetInit is a function called on every newly created [Widget].\nThis can be used to set global configuration and styling for all\nwidgets in conjunction with [App.SceneInit]."}, {Name: "Bars", Doc: "Bars are functions for creating control bars,\nattached to different sides of a [Scene]. Functions\nare called in forward order so first added are called first."}, {Name: "Data", Doc: "Data is the optional data value being represented by this scene.\nUsed e.g., for recycling views of a given item instead of creating new one."}, {Name: "SceneGeom", Doc: "Size and position relative to overall rendering context."}, {Name: "Painter", Doc: "painter for rendering all widgets in the scene."}, {Name: "Events", Doc: "event manager for this scene."}, {Name: "Stage", Doc: "current stage in which this Scene is set."}, {Name: "Animations", Doc: "Animations are the currently active [Animation]s in this scene."}, {Name: "renderBBoxes", Doc: "renderBBoxes indicates to render colored bounding boxes for all of the widgets\nin the scene. This is enabled by the [Inspector] in select element mode."}, {Name: "renderBBoxHue", Doc: "renderBBoxHue is current hue for rendering bounding box in [Scene.RenderBBoxes] mode."}, {Name: "selectedWidget", Doc: "selectedWidget is the currently selected/hovered widget through the [Inspector] selection mode\nthat should be highlighted with a background color."}, {Name: "selectedWidgetChan", Doc: "selectedWidgetChan is the channel on which the selected widget through the inspect editor\nselection mode is transmitted to the inspect editor after the user is done selecting."}, {Name: "renderer", Doc: "source renderer for rendering the scene"}, {Name: "lastRender", Doc: "lastRender captures key params from last render.\nIf different then a new ApplyStyleScene is needed."}, {Name: "showIter", Doc: "showIter counts up at start of showing a Scene\nto trigger Show event and other steps at start of first show"}, {Name: "directRenders", Doc: "directRenders are widgets that render directly to the [RenderWindow]\ninstead of rendering into the Scene Painter."}, {Name: "flags", Doc: "flags are atomic bit flags for [Scene] state."}}})

// SetWidgetInit sets the [Scene.WidgetInit]:
// WidgetInit is a function called on every newly created [Widget].
// This can be used to set global configuration and styling for all
// widgets in conjunction with [App.SceneInit].
func (t *Scene) SetWidgetInit(v func(w Widget)) *Scene { t.WidgetInit = v; return t }

// SetData sets the [Scene.Data]:
// Data is the optional data value being represented by this scene.
// Used e.g., for recycling views of a given item instead of creating new one.
func (t *Scene) SetData(v any) *Scene { t.Data = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Separator", IDName: "separator", Doc: "Separator draws a separator line. It goes in the direction\nspecified by [styles.Style.Direction].", Embeds: []types.Field{{Name: "WidgetBase"}}})

// NewSeparator returns a new [Separator] with the given optional parent:
// Separator draws a separator line. It goes in the direction
// specified by [styles.Style.Direction].
func NewSeparator(parent ...tree.Node) *Separator { return tree.New[Separator](parent...) }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.AppearanceSettingsData", IDName: "appearance-settings-data", Doc: "AppearanceSettingsData is the data type for the global Cogent Core appearance settings.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Methods: []types.Method{{Name: "Apply", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "deleteSavedWindowGeometries", Doc: "deleteSavedWindowGeometries deletes the file that saves the position and size of\neach window, by screen, and clear current in-memory cache. You shouldn't generally\nneed to do this, but sometimes it is useful for testing or windows that are\nshowing up in bad places that you can't recover from.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "SaveScreenZoom", Doc: "SaveScreenZoom saves the current zoom factor for the current screen,\nwhich will then be used for this screen instead of overall default.\nUse the Control +/- keyboard shortcut to modify the screen zoom level.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "SettingsBase"}}, Fields: []types.Field{{Name: "Theme", Doc: "the color theme."}, {Name: "Color", Doc: "the primary color used to generate the color scheme."}, {Name: "Zoom", Doc: "overall zoom factor as a percentage of the default zoom.\nUse Control +/- keyboard shortcut to change zoom level anytime.\nScreen-specific zoom factor will be used if present, see 'Screens' field."}, {Name: "Spacing", Doc: "the overall spacing factor as a percentage of the default amount of spacing\n(higher numbers lead to more space and lower numbers lead to higher density)."}, {Name: "FontSize", Doc: "the overall font size factor applied to all text as a percentage\nof the default font size (higher numbers lead to larger text)."}, {Name: "DocsFontSize", Doc: "Font size factor applied only to documentation and other\ndense text contexts, not normal interactive elements.\nIt is a percentage of the base Font size setting (higher numbers\nlead to larger text)."}, {Name: "ZebraStripes", Doc: "the amount that alternating rows are highlighted when showing\ntabular data (set to 0 to disable zebra striping)."}, {Name: "Screens", Doc: "screen-specific settings, which will override overall defaults if set,\nso different screens can use different zoom levels.\nUse 'Save screen zoom' in the toolbar to save the current zoom for the current\nscreen, and Control +/- keyboard shortcut to change this zoom level anytime."}, {Name: "Highlighting", Doc: "text highlighting style / theme."}, {Name: "Text", Doc: "Text specifies text settings including the language, and the\nfont families for different styles of fonts."}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.DeviceSettingsData", IDName: "device-settings-data", Doc: "DeviceSettingsData is the data type for the device settings.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Embeds: []types.Field{{Name: "SettingsBase"}}, Fields: []types.Field{{Name: "KeyMap", Doc: "The keyboard shortcut map to use"}, {Name: "KeyMaps", Doc: "The keyboard shortcut maps available as options for Key map.\nIf you do not want to have custom key maps, you should leave\nthis unset so that you always have the latest standard key maps."}, {Name: "DoubleClickInterval", Doc: "The maximum time interval between button press events to count as a double-click"}, {Name: "ScrollWheelSpeed", Doc: "How fast the scroll wheel moves, which is typically pixels per wheel step\nbut units can be arbitrary. It is generally impossible to standardize speed\nand variable across devices, and we don't have access to the system settings,\nso unfortunately you have to set it here."}, {Name: "ScrollFocusTime", Doc: "The duration over which the current scroll widget retains scroll focus,\nsuch that subsequent scroll events are sent to it."}, {Name: "SlideStartTime", Doc: "The amount of time to wait before initiating a slide event\n(as opposed to a basic press event)"}, {Name: "DragStartTime", Doc: "The amount of time to wait before initiating a drag (drag and drop) event\n(as opposed to a basic press or slide event)"}, {Name: "RepeatClickTime", Doc: "The amount of time to wait between each repeat click event,\nwhen the mouse is pressed down.  The first click is 8x this."}, {Name: "DragStartDistance", Doc: "The number of pixels that must be moved before initiating a slide/drag\nevent (as opposed to a basic press event)"}, {Name: "LongHoverTime", Doc: "The amount of time to wait before initiating a long hover event (e.g., for opening a tooltip)"}, {Name: "LongHoverStopDistance", Doc: "The maximum number of pixels that mouse can move and still register a long hover event"}, {Name: "LongPressTime", Doc: "The amount of time to wait before initiating a long press event (e.g., for opening a tooltip)"}, {Name: "LongPressStopDistance", Doc: "The maximum number of pixels that mouse/finger can move and still register a long press event"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.ScreenSettings", IDName: "screen-settings", Doc: "ScreenSettings are per-screen settings that override the global settings.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Fields: []types.Field{{Name: "Zoom", Doc: "overall zoom factor as a percentage of the default zoom"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.SystemSettingsData", IDName: "system-settings-data", Doc: "SystemSettingsData is the data type of the global Cogent Core settings.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Methods: []types.Method{{Name: "Apply", Doc: "Apply detailed settings to all the relevant settings.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "SettingsBase"}}, Fields: []types.Field{{Name: "Editor", Doc: "text editor settings"}, {Name: "Clock24", Doc: "whether to use a 24-hour clock (instead of AM and PM)"}, {Name: "SnackbarTimeout", Doc: "SnackbarTimeout is the default amount of time until snackbars\ndisappear (snackbars show short updates about app processes\nat the bottom of the screen)"}, {Name: "OnlyCloseActiveTab", Doc: "only support closing the currently selected active tab;\nif this is set to true, pressing the close button on other tabs\nwill take you to that tab, from which you can close it."}, {Name: "BigFileSize", Doc: "the limit of file size, above which user will be prompted before\nopening / copying, etc."}, {Name: "SavedPathsMax", Doc: "maximum number of saved paths to save in FilePicker"}, {Name: "User", Doc: "user info, which is partially filled-out automatically if empty\nwhen settings are first created."}, {Name: "FavPaths", Doc: "favorite paths, shown in FilePickerer and also editable there"}, {Name: "FilePickerSort", Doc: "column to sort by in FilePicker, and :up or :down for direction.\nUpdated automatically via FilePicker"}, {Name: "MenuMaxHeight", Doc: "the maximum height of any menu popup panel in units of font height;\nscroll bars are enforced beyond that size."}, {Name: "CompleteWaitDuration", Doc: "the amount of time to wait before offering completions"}, {Name: "CompleteMaxItems", Doc: "the maximum number of completions offered in popup"}, {Name: "CursorBlinkTime", Doc: "time interval for cursor blinking on and off -- set to 0 to disable blinking"}, {Name: "LayoutAutoScrollDelay", Doc: "The amount of time to wait before trying to autoscroll again"}, {Name: "LayoutPageSteps", Doc: "number of steps to take in PageUp / Down events in terms of number of items"}, {Name: "LayoutFocusNameTimeout", Doc: "the amount of time between keypresses to combine characters into name\nto search for within layout -- starts over after this delay."}, {Name: "LayoutFocusNameTabTime", Doc: "the amount of time since last focus name event to allow tab to focus\non next element with same name."}, {Name: "MapInlineLength", Doc: "the number of map elements at or below which an inline representation\nof the map will be presented, which is more convenient for small #'s of properties"}, {Name: "StructInlineLength", Doc: "the number of elemental struct fields at or below which an inline representation\nof the struct will be presented, which is more convenient for small structs"}, {Name: "SliceInlineLength", Doc: "the number of slice elements below which inline will be used"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.User", IDName: "user", Doc: "User basic user information that might be needed for different apps", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Embeds: []types.Field{{Name: "User"}}, Fields: []types.Field{{Name: "Email", Doc: "default email address -- e.g., for recording changes in a version control system"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.favoritePathItem", IDName: "favorite-path-item", Doc: "favoritePathItem represents one item in a favorite path list, for display of\nfavorites. Is an ordered list instead of a map because user can organize\nin order", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Fields: []types.Field{{Name: "Icon", Doc: "icon for item"}, {Name: "Name", Doc: "name of the favorite item"}, {Name: "Path", Doc: "the path of the favorite item"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.DebugSettingsData", IDName: "debug-settings-data", Doc: "DebugSettingsData is the data type for debugging settings.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Embeds: []types.Field{{Name: "SettingsBase"}}, Fields: []types.Field{{Name: "UpdateTrace", Doc: "Print a trace of updates that trigger re-rendering"}, {Name: "RenderTrace", Doc: "Print a trace of the nodes rendering"}, {Name: "LayoutTrace", Doc: "Print a trace of all layouts"}, {Name: "LayoutTraceDetail", Doc: "Print more detailed info about the underlying layout computations"}, {Name: "WindowEventTrace", Doc: "Print a trace of window events"}, {Name: "WindowRenderTrace", Doc: "Print the stack trace leading up to win publish events\nwhich are expensive"}, {Name: "WindowGeometryTrace", Doc: "Print a trace of window geometry saving / loading functions"}, {Name: "KeyEventTrace", Doc: "Print a trace of keyboard events"}, {Name: "EventTrace", Doc: "Print a trace of event handling"}, {Name: "FocusTrace", Doc: "Print a trace of focus changes"}, {Name: "DNDTrace", Doc: "Print a trace of DND event handling"}, {Name: "DisableWindowGeometrySaver", Doc: "DisableWindowGeometrySaver disables the saving and loading of window geometry\ndata to allow for easier testing of window manipulation code."}, {Name: "GoCompleteTrace", Doc: "Print a trace of Go language completion and lookup process"}, {Name: "GoTypeTrace", Doc: "Print a trace of Go language type parsing and inference process"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Slider", IDName: "slider", Doc: "Slider is a slideable widget that provides slider functionality with a draggable\nthumb and a clickable track. The [styles.Style.Direction] determines the direction\nin which the slider slides.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Type", Doc: "Type is the type of the slider, which determines its visual\nand functional properties. The default type, [SliderSlider],\nshould work for most end-user use cases."}, {Name: "Value", Doc: "Value is the current value, represented by the position of the thumb.\nIt defaults to 0.5."}, {Name: "Min", Doc: "Min is the minimum possible value.\nIt defaults to 0."}, {Name: "Max", Doc: "Max is the maximum value supported.\nIt defaults to 1."}, {Name: "Step", Doc: "Step is the amount that the arrow keys increment/decrement the value by.\nIt defaults to 0.1."}, {Name: "EnforceStep", Doc: "EnforceStep is whether to ensure that the value is always\na multiple of [Slider.Step]."}, {Name: "PageStep", Doc: "PageStep is the amount that the PageUp and PageDown keys\nincrement/decrement the value by.\nIt defaults to 0.2, and will be at least as big as [Slider.Step]."}, {Name: "Icon", Doc: "Icon is an optional icon to use for the dragging thumb."}, {Name: "visiblePercent", Doc: "For Scrollbar type only: proportion (1 max) of the full range of scrolled data\nthat is currently visible.  This determines the thumb size and range of motion:\nif 1, full slider is the thumb and no motion is possible."}, {Name: "ThumbSize", Doc: "ThumbSize is the size of the thumb as a proportion of the slider thickness,\nwhich is the content size (inside the padding)."}, {Name: "TrackSize", Doc: "TrackSize is the proportion of slider thickness for the visible track\nfor the [SliderSlider] type. It is often thinner than the thumb, achieved\nby values less than 1 (0.5 default)."}, {Name: "InputThreshold", Doc: "InputThreshold is the threshold for the amount of change in scroll\nvalue before emitting an input event."}, {Name: "Precision", Doc: "Precision specifies the precision of decimal places (total, not after the decimal\npoint) to use in representing the number. This helps to truncate small weird\nfloating point values."}, {Name: "ValueColor", Doc: "ValueColor is the background color that is used for styling the selected value\nsection of the slider. It should be set in a Styler, just like the main style\nobject is. If it is set to transparent, no value is rendered, so the value\nsection of the slider just looks like the rest of the slider."}, {Name: "ThumbColor", Doc: "ThumbColor is the background color that is used for styling the thumb (handle)\nof the slider. It should be set in a Styler, just like the main style object is.\nIf it is set to transparent, no thumb is rendered, so the thumb section of the\nslider just looks like the rest of the slider."}, {Name: "StayInView", Doc: "StayInView is whether to keep the slider (typically a [SliderScrollbar]) within\nthe parent [Scene] bounding box, if the parent is in view. This is the default\nbehavior for [Frame] scrollbars, and setting this flag replicates that behavior\nin other scrollbars."}, {Name: "pos", Doc: "logical position of the slider relative to Size"}, {Name: "lastValue", Doc: "previous Change event emitted value; don't re-emit Change if it is the same"}, {Name: "prevSlide", Doc: "previous sliding value (for computing the Input change)"}, {Name: "slideStartPos", Doc: "underlying drag position of slider; not subject to snapping"}}})

// NewSlider returns a new [Slider] with the given optional parent:
// Slider is a slideable widget that provides slider functionality with a draggable
// thumb and a clickable track. The [styles.Style.Direction] determines the direction
// in which the slider slides.
func NewSlider(parent ...tree.Node) *Slider { return tree.New[Slider](parent...) }

// SetType sets the [Slider.Type]:
// Type is the type of the slider, which determines its visual
// and functional properties. The default type, [SliderSlider],
// should work for most end-user use cases.
func (t *Slider) SetType(v SliderTypes) *Slider { t.Type = v; return t }

// SetMin sets the [Slider.Min]:
// Min is the minimum possible value.
// It defaults to 0.
func (t *Slider) SetMin(v float32) *Slider { t.Min = v; return t }

// SetMax sets the [Slider.Max]:
// Max is the maximum value supported.
// It defaults to 1.
func (t *Slider) SetMax(v float32) *Slider { t.Max = v; return t }

// SetStep sets the [Slider.Step]:
// Step is the amount that the arrow keys increment/decrement the value by.
// It defaults to 0.1.
func (t *Slider) SetStep(v float32) *Slider { t.Step = v; return t }

// SetEnforceStep sets the [Slider.EnforceStep]:
// EnforceStep is whether to ensure that the value is always
// a multiple of [Slider.Step].
func (t *Slider) SetEnforceStep(v bool) *Slider { t.EnforceStep = v; return t }

// SetPageStep sets the [Slider.PageStep]:
// PageStep is the amount that the PageUp and PageDown keys
// increment/decrement the value by.
// It defaults to 0.2, and will be at least as big as [Slider.Step].
func (t *Slider) SetPageStep(v float32) *Slider { t.PageStep = v; return t }

// SetIcon sets the [Slider.Icon]:
// Icon is an optional icon to use for the dragging thumb.
func (t *Slider) SetIcon(v icons.Icon) *Slider { t.Icon = v; return t }

// SetThumbSize sets the [Slider.ThumbSize]:
// ThumbSize is the size of the thumb as a proportion of the slider thickness,
// which is the content size (inside the padding).
func (t *Slider) SetThumbSize(v math32.Vector2) *Slider { t.ThumbSize = v; return t }

// SetTrackSize sets the [Slider.TrackSize]:
// TrackSize is the proportion of slider thickness for the visible track
// for the [SliderSlider] type. It is often thinner than the thumb, achieved
// by values less than 1 (0.5 default).
func (t *Slider) SetTrackSize(v float32) *Slider { t.TrackSize = v; return t }

// SetInputThreshold sets the [Slider.InputThreshold]:
// InputThreshold is the threshold for the amount of change in scroll
// value before emitting an input event.
func (t *Slider) SetInputThreshold(v float32) *Slider { t.InputThreshold = v; return t }

// SetPrecision sets the [Slider.Precision]:
// Precision specifies the precision of decimal places (total, not after the decimal
// point) to use in representing the number. This helps to truncate small weird
// floating point values.
func (t *Slider) SetPrecision(v int) *Slider { t.Precision = v; return t }

// SetValueColor sets the [Slider.ValueColor]:
// ValueColor is the background color that is used for styling the selected value
// section of the slider. It should be set in a Styler, just like the main style
// object is. If it is set to transparent, no value is rendered, so the value
// section of the slider just looks like the rest of the slider.
func (t *Slider) SetValueColor(v image.Image) *Slider { t.ValueColor = v; return t }

// SetThumbColor sets the [Slider.ThumbColor]:
// ThumbColor is the background color that is used for styling the thumb (handle)
// of the slider. It should be set in a Styler, just like the main style object is.
// If it is set to transparent, no thumb is rendered, so the thumb section of the
// slider just looks like the rest of the slider.
func (t *Slider) SetThumbColor(v image.Image) *Slider { t.ThumbColor = v; return t }

// SetStayInView sets the [Slider.StayInView]:
// StayInView is whether to keep the slider (typically a [SliderScrollbar]) within
// the parent [Scene] bounding box, if the parent is in view. This is the default
// behavior for [Frame] scrollbars, and setting this flag replicates that behavior
// in other scrollbars.
func (t *Slider) SetStayInView(v bool) *Slider { t.StayInView = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Spinner", IDName: "spinner", Doc: "Spinner is a [TextField] for editing numerical values. It comes with\nfields, methods, buttons, and shortcuts to enhance numerical value editing.", Embeds: []types.Field{{Name: "TextField"}}, Fields: []types.Field{{Name: "Value", Doc: "Value is the current value."}, {Name: "HasMin", Doc: "HasMin is whether there is a minimum value to enforce.\nIt should be set using [Spinner.SetMin]."}, {Name: "Min", Doc: "Min, if [Spinner.HasMin] is true, is the the minimum value in range.\nIt should be set using [Spinner.SetMin]."}, {Name: "HasMax", Doc: "HaxMax is whether there is a maximum value to enforce.\nIt should be set using [Spinner.SetMax]."}, {Name: "Max", Doc: "Max, if [Spinner.HasMax] is true, is the maximum value in range.\nIt should be set using [Spinner.SetMax]."}, {Name: "Step", Doc: "Step is the amount that the up and down buttons and arrow keys\nincrement/decrement the value by. It defaults to 0.1."}, {Name: "EnforceStep", Doc: "EnforceStep is whether to ensure that the value of the spinner\nis always a multiple of [Spinner.Step]."}, {Name: "PageStep", Doc: "PageStep is the amount that the PageUp and PageDown keys\nincrement/decrement the value by.\nIt defaults to 0.2, and will be at least as big as [Spinner.Step]."}, {Name: "Precision", Doc: "Precision specifies the precision of decimal places\n(total, not after the decimal point) to use in\nrepresenting the number. This helps to truncate\nsmall weird floating point values."}, {Name: "Format", Doc: "Format is the format string to use for printing the value.\nIf it unset, %g is used. If it is decimal based\n(ends in d, b, c, o, O, q, x, X, or U) then the value is\nconverted to decimal prior to printing."}}})

// NewSpinner returns a new [Spinner] with the given optional parent:
// Spinner is a [TextField] for editing numerical values. It comes with
// fields, methods, buttons, and shortcuts to enhance numerical value editing.
func NewSpinner(parent ...tree.Node) *Spinner { return tree.New[Spinner](parent...) }

// SetStep sets the [Spinner.Step]:
// Step is the amount that the up and down buttons and arrow keys
// increment/decrement the value by. It defaults to 0.1.
func (t *Spinner) SetStep(v float32) *Spinner { t.Step = v; return t }

// SetEnforceStep sets the [Spinner.EnforceStep]:
// EnforceStep is whether to ensure that the value of the spinner
// is always a multiple of [Spinner.Step].
func (t *Spinner) SetEnforceStep(v bool) *Spinner { t.EnforceStep = v; return t }

// SetPageStep sets the [Spinner.PageStep]:
// PageStep is the amount that the PageUp and PageDown keys
// increment/decrement the value by.
// It defaults to 0.2, and will be at least as big as [Spinner.Step].
func (t *Spinner) SetPageStep(v float32) *Spinner { t.PageStep = v; return t }

// SetPrecision sets the [Spinner.Precision]:
// Precision specifies the precision of decimal places
// (total, not after the decimal point) to use in
// representing the number. This helps to truncate
// small weird floating point values.
func (t *Spinner) SetPrecision(v int) *Spinner { t.Precision = v; return t }

// SetFormat sets the [Spinner.Format]:
// Format is the format string to use for printing the value.
// If it unset, %g is used. If it is decimal based
// (ends in d, b, c, o, O, q, x, X, or U) then the value is
// converted to decimal prior to printing.
func (t *Spinner) SetFormat(v string) *Spinner { t.Format = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Splits", IDName: "splits", Doc: "Splits allocates a certain proportion of its space to each of its children,\norganized along [styles.Style.Direction] as the main axis, and supporting\n[SplitsTiles] of 2D splits configurations along the cross axis.\nThere is always a split between each Tile segment along the main axis,\nwith the proportion of the total main axis space per Tile allocated\naccording to normalized Splits factors.\nIf all Tiles are Span then a 1D line is generated.  Children are allocated\nin order along the main axis, according to each of the Tiles,\nwhich consume 1 to 4 elements, and have 0 to 3 splits internally.\nThe internal split proportion are stored separately in SubSplits.\nA [Handle] widget is added to the Parts for each split, allowing the user\nto drag the relative size of each splits region.\nIf more complex geometries are required, use nested Splits.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Tiles", Doc: "Tiles specifies the 2D layout of elements along the [styles.Style.Direction]\nmain axis and the orthogonal cross axis.  If all Tiles are TileSpan, then\na 1D line is generated.  There is always a split between each Tile segment,\nand different tiles consume different numbers of elements in order, and\nhave different numbers of SubSplits.  Because each Tile can represent a\ndifferent number of elements, care must be taken to ensure that the full\nset of tiles corresponds to the actual number of children.  A default\n1D configuration will be imposed if there is a mismatch."}, {Name: "TileSplits", Doc: "TileSplits is the proportion (0-1 normalized, enforced) of space\nallocated to each Tile element along the main axis.\n0 indicates that an element should  be completely collapsed.\nBy default, each element gets the same amount of space."}, {Name: "SubSplits", Doc: "SubSplits contains splits proportions for each Tile element, with\na variable number depending on the Tile.  For the First and Second Long\nelements, there are 2 subsets of sub-splits, with 4 total subsplits."}, {Name: "savedSplits", Doc: "savedSplits is a saved version of the Splits that can be restored\nfor dynamic collapse/expand operations."}, {Name: "savedSubSplits", Doc: "savedSubSplits is a saved version of the SubSplits that can be restored\nfor dynamic collapse/expand operations."}, {Name: "handleDirs", Doc: "handleDirs contains the target directions for each of the handles.\nthis is set by parent split in its style function, and consumed\nby each handle in its own style function."}}})

// NewSplits returns a new [Splits] with the given optional parent:
// Splits allocates a certain proportion of its space to each of its children,
// organized along [styles.Style.Direction] as the main axis, and supporting
// [SplitsTiles] of 2D splits configurations along the cross axis.
// There is always a split between each Tile segment along the main axis,
// with the proportion of the total main axis space per Tile allocated
// according to normalized Splits factors.
// If all Tiles are Span then a 1D line is generated.  Children are allocated
// in order along the main axis, according to each of the Tiles,
// which consume 1 to 4 elements, and have 0 to 3 splits internally.
// The internal split proportion are stored separately in SubSplits.
// A [Handle] widget is added to the Parts for each split, allowing the user
// to drag the relative size of each splits region.
// If more complex geometries are required, use nested Splits.
func NewSplits(parent ...tree.Node) *Splits { return tree.New[Splits](parent...) }

// SetTiles sets the [Splits.Tiles]:
// Tiles specifies the 2D layout of elements along the [styles.Style.Direction]
// main axis and the orthogonal cross axis.  If all Tiles are TileSpan, then
// a 1D line is generated.  There is always a split between each Tile segment,
// and different tiles consume different numbers of elements in order, and
// have different numbers of SubSplits.  Because each Tile can represent a
// different number of elements, care must be taken to ensure that the full
// set of tiles corresponds to the actual number of children.  A default
// 1D configuration will be imposed if there is a mismatch.
func (t *Splits) SetTiles(v ...SplitsTiles) *Splits { t.Tiles = v; return t }

// SetTileSplits sets the [Splits.TileSplits]:
// TileSplits is the proportion (0-1 normalized, enforced) of space
// allocated to each Tile element along the main axis.
// 0 indicates that an element should  be completely collapsed.
// By default, each element gets the same amount of space.
func (t *Splits) SetTileSplits(v ...float32) *Splits { t.TileSplits = v; return t }

// SetSubSplits sets the [Splits.SubSplits]:
// SubSplits contains splits proportions for each Tile element, with
// a variable number depending on the Tile.  For the First and Second Long
// elements, there are 2 subsets of sub-splits, with 4 total subsplits.
func (t *Splits) SetSubSplits(v ...[]float32) *Splits { t.SubSplits = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Stage", IDName: "stage", Doc: "Stage is a container and manager for displaying a [Scene]\nin different functional ways, defined by [StageTypes].", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Fields: []types.Field{{Name: "Type", Doc: "Type is the type of [Stage], which determines behavior and styling."}, {Name: "Scene", Doc: "Scene contents of this [Stage] (what it displays)."}, {Name: "Context", Doc: "Context is a widget in another scene that requested this stage to be created\nand provides context."}, {Name: "Name", Doc: "Name is the name of the Stage, which is generally auto-set\nbased on the [Scene.Name]."}, {Name: "Title", Doc: "Title is the title of the Stage, which is generally auto-set\nbased on the [Body.Title]. It used for the title of [WindowStage]\nand [DialogStage] types, and for a [Text] title widget if\n[Stage.DisplayTitle] is true."}, {Name: "Screen", Doc: "Screen specifies the screen number on which a new window is opened\nby default on desktop platforms. It defaults to -1, which indicates\nthat the first window should open on screen 0 (the default primary\nscreen) and any subsequent windows should open on the same screen as\nthe currently active window. Regardless, the automatically saved last\nscreen of a window with the same [Stage.Title] takes precedence if it exists;\nsee the website documentation on window geometry saving for more information.\nUse [TheApp].ScreenByName(\"name\").ScreenNumber to get the screen by name."}, {Name: "Modal", Doc: "Modal, if true, blocks input to all other stages."}, {Name: "Scrim", Doc: "Scrim, if true, places a darkening scrim over other stages."}, {Name: "ClickOff", Doc: "ClickOff, if true, dismisses the [Stage] if the user clicks anywhere\noff of the [Stage]."}, {Name: "ignoreEvents", Doc: "ignoreEvents is whether to send no events to the stage and\njust pass them down to lower stages."}, {Name: "NewWindow", Doc: "NewWindow, if true, opens a [WindowStage] or [DialogStage] in its own\nseparate operating system window ([renderWindow]). This is true by\ndefault for [WindowStage] on non-mobile platforms, otherwise false."}, {Name: "FullWindow", Doc: "FullWindow, if [Stage.NewWindow] is false, makes [DialogStage]s and\n[WindowStage]s take up the entire window they are created in."}, {Name: "Maximized", Doc: "Maximized is whether to make a window take up the entire screen on desktop\nplatforms by default. It is different from [Stage.Fullscreen] in that\nfullscreen makes the window truly fullscreen without decorations\n(such as for a video player), whereas maximized keeps decorations and just\nmakes it fill the available space. The automatically saved user previous\nmaximized state takes precedence."}, {Name: "Fullscreen", Doc: "Fullscreen is whether to make a window fullscreen on desktop platforms.\nIt is different from [Stage.Maximized] in that fullscreen makes\nthe window truly fullscreen without decorations (such as for a video player),\nwhereas maximized keeps decorations and just makes it fill the available space.\nNot to be confused with [Stage.FullWindow], which is for stages contained within\nanother system window. See [Scene.IsFullscreen] and [Scene.SetFullscreen] to\ncheck and update fullscreen state dynamically on desktop and web platforms\n([Stage.SetFullscreen] sets the initial state, whereas [Scene.SetFullscreen]\nsets the current state after the [Stage] is already running)."}, {Name: "UseMinSize", Doc: "UseMinSize uses a minimum size as a function of the total available size\nfor sizing new windows and dialogs. Otherwise, only the content size is used.\nThe saved window position and size takes precedence on multi-window platforms."}, {Name: "Resizable", Doc: "Resizable specifies whether a window on desktop platforms can\nbe resized by the user, and whether a non-full same-window dialog can\nbe resized by the user on any platform. It defaults to true."}, {Name: "Timeout", Doc: "Timeout, if greater than 0, results in a popup stages disappearing\nafter this timeout duration."}, {Name: "BackButton", Doc: "BackButton is whether to add a back button to the top bar that calls\n[Scene.Close] when clicked. If it is unset, is will be treated as true\non non-[system.Offscreen] platforms for [Stage.FullWindow] but not\n[Stage.NewWindow] [Stage]s that are not the first in the stack."}, {Name: "DisplayTitle", Doc: "DisplayTitle is whether to display the [Stage.Title] using a\n[Text] widget in the top bar. It is on by default for [DialogStage]s\nand off for all other stages."}, {Name: "Pos", Doc: "Pos is the default target position for the [Stage] to be placed within\nthe surrounding window or screen in raw pixels. For a new window on desktop\nplatforms, the automatically saved user previous window position takes precedence.\nFor dialogs, this position is the target center position, not the upper-left corner."}, {Name: "Main", Doc: "If a popup stage, this is the main stage that owns it (via its [Stage.popups]).\nIf a main stage, it points to itself."}, {Name: "popups", Doc: "For main stages, this is the stack of the popups within it\n(created specifically for the main stage).\nFor popups, this is the pointer to the popups within the\nmain stage managing it."}, {Name: "Mains", Doc: "For all stages, this is the main [Stages] that lives in a [renderWindow]\nand manages the main stages."}, {Name: "renderContext", Doc: "rendering context which has info about the RenderWindow onto which we render.\nThis should be used instead of the RenderWindow itself for all relevant\nrendering information. This is only available once a Stage is Run,\nand must always be checked for nil."}, {Name: "Sprites", Doc: "Sprites are named images that are rendered last overlaying everything else."}, {Name: "spritePainter", Doc: "spritePainter is the painter for sprite drawing."}, {Name: "spriteRenderer", Doc: "spriteRenderer is the renderer for sprite drawing."}}})

// SetContext sets the [Stage.Context]:
// Context is a widget in another scene that requested this stage to be created
// and provides context.
func (t *Stage) SetContext(v Widget) *Stage { t.Context = v; return t }

// SetName sets the [Stage.Name]:
// Name is the name of the Stage, which is generally auto-set
// based on the [Scene.Name].
func (t *Stage) SetName(v string) *Stage { t.Name = v; return t }

// SetTitle sets the [Stage.Title]:
// Title is the title of the Stage, which is generally auto-set
// based on the [Body.Title]. It used for the title of [WindowStage]
// and [DialogStage] types, and for a [Text] title widget if
// [Stage.DisplayTitle] is true.
func (t *Stage) SetTitle(v string) *Stage { t.Title = v; return t }

// SetScreen sets the [Stage.Screen]:
// Screen specifies the screen number on which a new window is opened
// by default on desktop platforms. It defaults to -1, which indicates
// that the first window should open on screen 0 (the default primary
// screen) and any subsequent windows should open on the same screen as
// the currently active window. Regardless, the automatically saved last
// screen of a window with the same [Stage.Title] takes precedence if it exists;
// see the website documentation on window geometry saving for more information.
// Use [TheApp].ScreenByName("name").ScreenNumber to get the screen by name.
func (t *Stage) SetScreen(v int) *Stage { t.Screen = v; return t }

// SetScrim sets the [Stage.Scrim]:
// Scrim, if true, places a darkening scrim over other stages.
func (t *Stage) SetScrim(v bool) *Stage { t.Scrim = v; return t }

// SetClickOff sets the [Stage.ClickOff]:
// ClickOff, if true, dismisses the [Stage] if the user clicks anywhere
// off of the [Stage].
func (t *Stage) SetClickOff(v bool) *Stage { t.ClickOff = v; return t }

// SetNewWindow sets the [Stage.NewWindow]:
// NewWindow, if true, opens a [WindowStage] or [DialogStage] in its own
// separate operating system window ([renderWindow]). This is true by
// default for [WindowStage] on non-mobile platforms, otherwise false.
func (t *Stage) SetNewWindow(v bool) *Stage { t.NewWindow = v; return t }

// SetFullWindow sets the [Stage.FullWindow]:
// FullWindow, if [Stage.NewWindow] is false, makes [DialogStage]s and
// [WindowStage]s take up the entire window they are created in.
func (t *Stage) SetFullWindow(v bool) *Stage { t.FullWindow = v; return t }

// SetMaximized sets the [Stage.Maximized]:
// Maximized is whether to make a window take up the entire screen on desktop
// platforms by default. It is different from [Stage.Fullscreen] in that
// fullscreen makes the window truly fullscreen without decorations
// (such as for a video player), whereas maximized keeps decorations and just
// makes it fill the available space. The automatically saved user previous
// maximized state takes precedence.
func (t *Stage) SetMaximized(v bool) *Stage { t.Maximized = v; return t }

// SetFullscreen sets the [Stage.Fullscreen]:
// Fullscreen is whether to make a window fullscreen on desktop platforms.
// It is different from [Stage.Maximized] in that fullscreen makes
// the window truly fullscreen without decorations (such as for a video player),
// whereas maximized keeps decorations and just makes it fill the available space.
// Not to be confused with [Stage.FullWindow], which is for stages contained within
// another system window. See [Scene.IsFullscreen] and [Scene.SetFullscreen] to
// check and update fullscreen state dynamically on desktop and web platforms
// ([Stage.SetFullscreen] sets the initial state, whereas [Scene.SetFullscreen]
// sets the current state after the [Stage] is already running).
func (t *Stage) SetFullscreen(v bool) *Stage { t.Fullscreen = v; return t }

// SetUseMinSize sets the [Stage.UseMinSize]:
// UseMinSize uses a minimum size as a function of the total available size
// for sizing new windows and dialogs. Otherwise, only the content size is used.
// The saved window position and size takes precedence on multi-window platforms.
func (t *Stage) SetUseMinSize(v bool) *Stage { t.UseMinSize = v; return t }

// SetResizable sets the [Stage.Resizable]:
// Resizable specifies whether a window on desktop platforms can
// be resized by the user, and whether a non-full same-window dialog can
// be resized by the user on any platform. It defaults to true.
func (t *Stage) SetResizable(v bool) *Stage { t.Resizable = v; return t }

// SetTimeout sets the [Stage.Timeout]:
// Timeout, if greater than 0, results in a popup stages disappearing
// after this timeout duration.
func (t *Stage) SetTimeout(v time.Duration) *Stage { t.Timeout = v; return t }

// SetDisplayTitle sets the [Stage.DisplayTitle]:
// DisplayTitle is whether to display the [Stage.Title] using a
// [Text] widget in the top bar. It is on by default for [DialogStage]s
// and off for all other stages.
func (t *Stage) SetDisplayTitle(v bool) *Stage { t.DisplayTitle = v; return t }

// SetPos sets the [Stage.Pos]:
// Pos is the default target position for the [Stage] to be placed within
// the surrounding window or screen in raw pixels. For a new window on desktop
// platforms, the automatically saved user previous window position takes precedence.
// For dialogs, this position is the target center position, not the upper-left corner.
func (t *Stage) SetPos(v image.Point) *Stage { t.Pos = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.SVG", IDName: "svg", Doc: "SVG is a Widget that renders an [svg.SVG] object.\nIf it is not [states.ReadOnly], the user can pan and zoom the display.\nBy default, it is [states.ReadOnly].", Methods: []types.Method{{Name: "Open", Doc: "Open opens an XML-formatted SVG file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "SaveSVG", Doc: "SaveSVG saves the current SVG to an XML-encoded standard SVG file.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "SaveImage", Doc: "SaveImage saves the current rendered SVG image to an image file,\nusing the filename extension to determine the file type.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}}, Embeds: []types.Field{{Name: "WidgetBase"}}, Fields: []types.Field{{Name: "SVG", Doc: "SVG is the SVG drawing to display."}, {Name: "renderer", Doc: "image renderer"}, {Name: "image", Doc: "cached rendered image"}, {Name: "prevSize", Doc: "prevSize is the cached allocated size for the last rendered image."}}})

// NewSVG returns a new [SVG] with the given optional parent:
// SVG is a Widget that renders an [svg.SVG] object.
// If it is not [states.ReadOnly], the user can pan and zoom the display.
// By default, it is [states.ReadOnly].
func NewSVG(parent ...tree.Node) *SVG { return tree.New[SVG](parent...) }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Switch", IDName: "switch", Doc: "Switch is a widget that can toggle between an on and off state.\nIt can be displayed as a switch, chip, checkbox, radio button,\nor segmented button.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Type", Doc: "Type is the styling type of switch.\nIt must be set using [Switch.SetType]."}, {Name: "Text", Doc: "Text is the optional text of the switch."}, {Name: "IconOn", Doc: "IconOn is the icon to use for the on, checked state of the switch."}, {Name: "IconOff", Doc: "Iconoff is the icon to use for the off, unchecked state of the switch."}, {Name: "IconIndeterminate", Doc: "IconIndeterminate is the icon to use for the indeterminate (unknown) state."}}})

// NewSwitch returns a new [Switch] with the given optional parent:
// Switch is a widget that can toggle between an on and off state.
// It can be displayed as a switch, chip, checkbox, radio button,
// or segmented button.
func NewSwitch(parent ...tree.Node) *Switch { return tree.New[Switch](parent...) }

// SetText sets the [Switch.Text]:
// Text is the optional text of the switch.
func (t *Switch) SetText(v string) *Switch { t.Text = v; return t }

// SetIconOn sets the [Switch.IconOn]:
// IconOn is the icon to use for the on, checked state of the switch.
func (t *Switch) SetIconOn(v icons.Icon) *Switch { t.IconOn = v; return t }

// SetIconOff sets the [Switch.IconOff]:
// Iconoff is the icon to use for the off, unchecked state of the switch.
func (t *Switch) SetIconOff(v icons.Icon) *Switch { t.IconOff = v; return t }

// SetIconIndeterminate sets the [Switch.IconIndeterminate]:
// IconIndeterminate is the icon to use for the indeterminate (unknown) state.
func (t *Switch) SetIconIndeterminate(v icons.Icon) *Switch { t.IconIndeterminate = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Switches", IDName: "switches", Doc: "Switches is a widget for containing a set of [Switch]es.\nIt can optionally enforce mutual exclusivity (ie: radio buttons)\nthrough the [Switches.Mutex] field. It supports binding to\n[enums.Enum] and [enums.BitFlag] values with appropriate properties\nautomatically set.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Type", Doc: "Type is the type of switches that will be made."}, {Name: "Items", Doc: "Items are the items displayed to the user."}, {Name: "Mutex", Doc: "Mutex is whether to make the items mutually exclusive\n(checking one turns off all the others)."}, {Name: "AllowNone", Doc: "AllowNone is whether to allow the user to deselect all items.\nIt is on by default."}, {Name: "selectedIndexes", Doc: "selectedIndexes are the indexes in [Switches.Items] of the currently\nselected switch items."}, {Name: "bitFlagValue", Doc: "bitFlagValue is the associated bit flag value if non-nil (for [Value])."}}})

// NewSwitches returns a new [Switches] with the given optional parent:
// Switches is a widget for containing a set of [Switch]es.
// It can optionally enforce mutual exclusivity (ie: radio buttons)
// through the [Switches.Mutex] field. It supports binding to
// [enums.Enum] and [enums.BitFlag] values with appropriate properties
// automatically set.
func NewSwitches(parent ...tree.Node) *Switches { return tree.New[Switches](parent...) }

// SetType sets the [Switches.Type]:
// Type is the type of switches that will be made.
func (t *Switches) SetType(v SwitchTypes) *Switches { t.Type = v; return t }

// SetItems sets the [Switches.Items]:
// Items are the items displayed to the user.
func (t *Switches) SetItems(v ...SwitchItem) *Switches { t.Items = v; return t }

// SetMutex sets the [Switches.Mutex]:
// Mutex is whether to make the items mutually exclusive
// (checking one turns off all the others).
func (t *Switches) SetMutex(v bool) *Switches { t.Mutex = v; return t }

// SetAllowNone sets the [Switches.AllowNone]:
// AllowNone is whether to allow the user to deselect all items.
// It is on by default.
func (t *Switches) SetAllowNone(v bool) *Switches { t.AllowNone = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Table", IDName: "table", Doc: "Table represents a slice of structs as a table, where the fields are\nthe columns and the elements are the rows. It is a full-featured editor with\nmultiple-selection, cut-and-paste, and drag-and-drop.\nUse [ListBase.BindSelect] to make the table designed for item selection.", Embeds: []types.Field{{Name: "ListBase"}}, Fields: []types.Field{{Name: "TableStyler", Doc: "TableStyler is an optional styling function for table items."}, {Name: "SelectedField", Doc: "SelectedField is the current selection field; initially select value in this field."}, {Name: "sortIndex", Doc: "sortIndex is the current sort index."}, {Name: "sortDescending", Doc: "sortDescending is whether the current sort order is descending."}, {Name: "visibleFields", Doc: "visibleFields are the visible fields."}, {Name: "numVisibleFields", Doc: "numVisibleFields is the number of visible fields."}, {Name: "headerWidths", Doc: "headerWidths has the number of characters in each header, per visibleFields."}, {Name: "colMaxWidths", Doc: "colMaxWidths records maximum width in chars of string type fields."}, {Name: "header"}}})

// NewTable returns a new [Table] with the given optional parent:
// Table represents a slice of structs as a table, where the fields are
// the columns and the elements are the rows. It is a full-featured editor with
// multiple-selection, cut-and-paste, and drag-and-drop.
// Use [ListBase.BindSelect] to make the table designed for item selection.
func NewTable(parent ...tree.Node) *Table { return tree.New[Table](parent...) }

// SetTableStyler sets the [Table.TableStyler]:
// TableStyler is an optional styling function for table items.
func (t *Table) SetTableStyler(v TableStyler) *Table { t.TableStyler = v; return t }

// SetSelectedField sets the [Table.SelectedField]:
// SelectedField is the current selection field; initially select value in this field.
func (t *Table) SetSelectedField(v string) *Table { t.SelectedField = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Tabs", IDName: "tabs", Doc: "Tabs divide widgets into logical groups and give users the ability\nto freely navigate between them using tab buttons.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Type", Doc: "Type is the styling type of the tabs. If it is changed after\nthe tabs are first configured, Update needs to be called on\nthe tabs."}, {Name: "NewTabButton", Doc: "NewTabButton is whether to show a new tab button at the end of the list of tabs."}, {Name: "maxChars", Doc: "maxChars is the maximum number of characters to include in the tab text.\nIt elides text that are longer than that."}, {Name: "CloseIcon", Doc: "CloseIcon is the icon used for tab close buttons.\nIf it is \"\" or [icons.None], the tab is not closeable.\nThe default value is [icons.Close].\nOnly [FunctionalTabs] can be closed; all other types of\ntabs will not render a close button and can not be closed."}, {Name: "mu", Doc: "mu is a mutex protecting updates to tabs. Tabs can be driven\nprogrammatically and via user input so need extra protection."}, {Name: "tabs"}, {Name: "frame"}}})

// NewTabs returns a new [Tabs] with the given optional parent:
// Tabs divide widgets into logical groups and give users the ability
// to freely navigate between them using tab buttons.
func NewTabs(parent ...tree.Node) *Tabs { return tree.New[Tabs](parent...) }

// SetType sets the [Tabs.Type]:
// Type is the styling type of the tabs. If it is changed after
// the tabs are first configured, Update needs to be called on
// the tabs.
func (t *Tabs) SetType(v TabTypes) *Tabs { t.Type = v; return t }

// SetNewTabButton sets the [Tabs.NewTabButton]:
// NewTabButton is whether to show a new tab button at the end of the list of tabs.
func (t *Tabs) SetNewTabButton(v bool) *Tabs { t.NewTabButton = v; return t }

// SetCloseIcon sets the [Tabs.CloseIcon]:
// CloseIcon is the icon used for tab close buttons.
// If it is "" or [icons.None], the tab is not closeable.
// The default value is [icons.Close].
// Only [FunctionalTabs] can be closed; all other types of
// tabs will not render a close button and can not be closed.
func (t *Tabs) SetCloseIcon(v icons.Icon) *Tabs { t.CloseIcon = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Tab", IDName: "tab", Doc: "Tab is a tab button that contains one or more of a label, an icon,\nand a close icon. Tabs should be made using the [Tabs.NewTab] function.", Directives: []types.Directive{{Tool: "core", Directive: "no-new"}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Type", Doc: "Type is the styling type of the tab. This property\nmust be set on the parent [Tabs] for it to work correctly."}, {Name: "Text", Doc: "Text is the text for the tab. If it is blank, no text is shown.\nText is never shown for [NavigationRail] tabs."}, {Name: "Icon", Doc: "Icon is the icon for the tab.\nIf it is \"\" or [icons.None], no icon is shown."}, {Name: "CloseIcon", Doc: "CloseIcon is the icon used as a close button for the tab.\nIf it is \"\" or [icons.None], the tab is not closeable.\nThe default value is [icons.Close].\nOnly [FunctionalTabs] can be closed; all other types of\ntabs will not render a close button and can not be closed."}, {Name: "maxChars", Doc: "maxChars is the maximum number of characters to include in tab text.\nIt elides text that is longer than that."}}})

// SetType sets the [Tab.Type]:
// Type is the styling type of the tab. This property
// must be set on the parent [Tabs] for it to work correctly.
func (t *Tab) SetType(v TabTypes) *Tab { t.Type = v; return t }

// SetText sets the [Tab.Text]:
// Text is the text for the tab. If it is blank, no text is shown.
// Text is never shown for [NavigationRail] tabs.
func (t *Tab) SetText(v string) *Tab { t.Text = v; return t }

// SetIcon sets the [Tab.Icon]:
// Icon is the icon for the tab.
// If it is "" or [icons.None], no icon is shown.
func (t *Tab) SetIcon(v icons.Icon) *Tab { t.Icon = v; return t }

// SetCloseIcon sets the [Tab.CloseIcon]:
// CloseIcon is the icon used as a close button for the tab.
// If it is "" or [icons.None], the tab is not closeable.
// The default value is [icons.Close].
// Only [FunctionalTabs] can be closed; all other types of
// tabs will not render a close button and can not be closed.
func (t *Tab) SetCloseIcon(v icons.Icon) *Tab { t.CloseIcon = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Text", IDName: "text", Doc: "Text is a widget for rendering text. It supports full HTML styling,\nincluding links. By default, text wraps and collapses whitespace, although\nyou can change this by changing [styles.Text.WhiteSpace].", Methods: []types.Method{{Name: "copy", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "WidgetBase"}}, Fields: []types.Field{{Name: "Text", Doc: "Text is the text to display."}, {Name: "Type", Doc: "Type is the styling type of text to use.\nIt defaults to [TextBodyLarge]."}, {Name: "Links", Doc: "Links is the list of links in the text."}, {Name: "richText", Doc: "richText is the conversion of the HTML text source."}, {Name: "paintText", Doc: "paintText is the [shaped.Lines] for the text."}, {Name: "normalCursor", Doc: "normalCursor is the cached cursor to display when there\nis no link being hovered."}, {Name: "selectRange", Doc: "selectRange is the selected range, in _runes_, which must be applied"}}})

// NewText returns a new [Text] with the given optional parent:
// Text is a widget for rendering text. It supports full HTML styling,
// including links. By default, text wraps and collapses whitespace, although
// you can change this by changing [styles.Text.WhiteSpace].
func NewText(parent ...tree.Node) *Text { return tree.New[Text](parent...) }

// SetText sets the [Text.Text]:
// Text is the text to display.
func (t *Text) SetText(v string) *Text { t.Text = v; return t }

// SetType sets the [Text.Type]:
// Type is the styling type of text to use.
// It defaults to [TextBodyLarge].
func (t *Text) SetType(v TextTypes) *Text { t.Type = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.TextField", IDName: "text-field", Doc: "TextField is a widget for editing a line of text.\n\nWith the default [styles.WhiteSpaceNormal] setting,\ntext will wrap onto multiple lines as needed. You can\ncall [styles.Style.SetTextWrap](false) to force everything\nto be rendered on a single line. With multi-line wrapped text,\nthe text is still treated as a single contiguous line of wrapped text.", Directives: []types.Directive{{Tool: "core", Directive: "embedder"}}, Methods: []types.Method{{Name: "cut", Doc: "cut cuts any selected text and adds it to the clipboard.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "copy", Doc: "copy copies any selected text to the clipboard.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "paste", Doc: "paste inserts text from the clipboard at current cursor position; if\ncursor is within a current selection, that selection is replaced.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Type", Doc: "Type is the styling type of the text field."}, {Name: "Placeholder", Doc: "Placeholder is the text that is displayed\nwhen the text field is empty."}, {Name: "Validator", Doc: "Validator is a function used to validate the input\nof the text field. If it returns a non-nil error,\nthen an error color, icon, and tooltip will be displayed."}, {Name: "LeadingIcon", Doc: "LeadingIcon, if specified, indicates to add a button\nat the start of the text field with this icon.\nSee [TextField.SetLeadingIcon]."}, {Name: "LeadingIconOnClick", Doc: "LeadingIconOnClick, if specified, is the function to call when\nthe LeadingIcon is clicked. If this is nil, the leading icon\nwill not be interactive. See [TextField.SetLeadingIcon]."}, {Name: "TrailingIcon", Doc: "TrailingIcon, if specified, indicates to add a button\nat the end of the text field with this icon.\nSee [TextField.SetTrailingIcon]."}, {Name: "TrailingIconOnClick", Doc: "TrailingIconOnClick, if specified, is the function to call when\nthe TrailingIcon is clicked. If this is nil, the trailing icon\nwill not be interactive. See [TextField.SetTrailingIcon]."}, {Name: "NoEcho", Doc: "NoEcho is whether replace displayed characters with bullets\nto conceal text (for example, for a password input). Also\nsee [TextField.SetTypePassword]."}, {Name: "CursorWidth", Doc: "CursorWidth is the width of the text field cursor.\nIt should be set in a Styler like all other style properties.\nBy default, it is 1dp."}, {Name: "CursorColor", Doc: "CursorColor is the color used for the text field cursor (caret).\nIt should be set in a Styler like all other style properties.\nBy default, it is [colors.Scheme.Primary.Base]."}, {Name: "PlaceholderColor", Doc: "PlaceholderColor is the color used for the [TextField.Placeholder] text.\nIt should be set in a Styler like all other style properties.\nBy default, it is [colors.Scheme.OnSurfaceVariant]."}, {Name: "complete", Doc: "complete contains functions and data for text field completion.\nIt must be set using [TextField.SetCompleter]."}, {Name: "text", Doc: "text is the last saved value of the text string being edited."}, {Name: "edited", Doc: "edited is whether the text has been edited relative to the original."}, {Name: "editText", Doc: "editText is the live text string being edited, with the latest modifications."}, {Name: "error", Doc: "error is the current validation error of the text field."}, {Name: "effPos", Doc: "effPos is the effective position with any leading icon space added."}, {Name: "effSize", Doc: "effSize is the effective size, subtracting any leading and trailing icon space."}, {Name: "dispRange", Doc: "dispRange is the range of visible text, for scrolling text case (non-wordwrap)."}, {Name: "cursorPos", Doc: "cursorPos is the current cursor position as rune index into string."}, {Name: "cursorLine", Doc: "cursorLine is the current cursor line position, for word wrap case."}, {Name: "charWidth", Doc: "charWidth is the approximate number of chars that can be\ndisplayed at any time, which is computed from the font size."}, {Name: "selectRange", Doc: "selectRange is the selected range."}, {Name: "selectInit", Doc: "selectInit is the initial selection position (where it started)."}, {Name: "selectMode", Doc: "selectMode is whether to select text as the cursor moves."}, {Name: "selectModeShift", Doc: "selectModeShift is whether selectmode was turned on because of the shift key."}, {Name: "renderAll", Doc: "renderAll is the render version of entire text, for sizing."}, {Name: "renderVisible", Doc: "renderVisible is the render version of just the visible text in dispRange."}, {Name: "renderedRange", Doc: "renderedRange is the dispRange last rendered."}, {Name: "numLines", Doc: "number of lines from last render update, for word-wrap version"}, {Name: "lineHeight", Doc: "lineHeight is the line height cached during styling."}, {Name: "cursorMu", Doc: "cursorMu is the mutex for updating the cursor between blinker and field."}, {Name: "undos", Doc: "undos is the undo manager for the text field."}, {Name: "leadingIconButton"}, {Name: "trailingIconButton"}}})

// NewTextField returns a new [TextField] with the given optional parent:
// TextField is a widget for editing a line of text.
//
// With the default [styles.WhiteSpaceNormal] setting,
// text will wrap onto multiple lines as needed. You can
// call [styles.Style.SetTextWrap](false) to force everything
// to be rendered on a single line. With multi-line wrapped text,
// the text is still treated as a single contiguous line of wrapped text.
func NewTextField(parent ...tree.Node) *TextField { return tree.New[TextField](parent...) }

// TextFieldEmbedder is an interface that all types that embed TextField satisfy
type TextFieldEmbedder interface {
	AsTextField() *TextField
}

// AsTextField returns the given value as a value of type TextField if the type
// of the given value embeds TextField, or nil otherwise
func AsTextField(n tree.Node) *TextField {
	if t, ok := n.(TextFieldEmbedder); ok {
		return t.AsTextField()
	}
	return nil
}

// AsTextField satisfies the [TextFieldEmbedder] interface
func (t *TextField) AsTextField() *TextField { return t }

// SetType sets the [TextField.Type]:
// Type is the styling type of the text field.
func (t *TextField) SetType(v TextFieldTypes) *TextField { t.Type = v; return t }

// SetPlaceholder sets the [TextField.Placeholder]:
// Placeholder is the text that is displayed
// when the text field is empty.
func (t *TextField) SetPlaceholder(v string) *TextField { t.Placeholder = v; return t }

// SetValidator sets the [TextField.Validator]:
// Validator is a function used to validate the input
// of the text field. If it returns a non-nil error,
// then an error color, icon, and tooltip will be displayed.
func (t *TextField) SetValidator(v func() error) *TextField { t.Validator = v; return t }

// SetLeadingIconOnClick sets the [TextField.LeadingIconOnClick]:
// LeadingIconOnClick, if specified, is the function to call when
// the LeadingIcon is clicked. If this is nil, the leading icon
// will not be interactive. See [TextField.SetLeadingIcon].
func (t *TextField) SetLeadingIconOnClick(v func(e events.Event)) *TextField {
	t.LeadingIconOnClick = v
	return t
}

// SetTrailingIconOnClick sets the [TextField.TrailingIconOnClick]:
// TrailingIconOnClick, if specified, is the function to call when
// the TrailingIcon is clicked. If this is nil, the trailing icon
// will not be interactive. See [TextField.SetTrailingIcon].
func (t *TextField) SetTrailingIconOnClick(v func(e events.Event)) *TextField {
	t.TrailingIconOnClick = v
	return t
}

// SetNoEcho sets the [TextField.NoEcho]:
// NoEcho is whether replace displayed characters with bullets
// to conceal text (for example, for a password input). Also
// see [TextField.SetTypePassword].
func (t *TextField) SetNoEcho(v bool) *TextField { t.NoEcho = v; return t }

// SetCursorWidth sets the [TextField.CursorWidth]:
// CursorWidth is the width of the text field cursor.
// It should be set in a Styler like all other style properties.
// By default, it is 1dp.
func (t *TextField) SetCursorWidth(v units.Value) *TextField { t.CursorWidth = v; return t }

// SetCursorColor sets the [TextField.CursorColor]:
// CursorColor is the color used for the text field cursor (caret).
// It should be set in a Styler like all other style properties.
// By default, it is [colors.Scheme.Primary.Base].
func (t *TextField) SetCursorColor(v image.Image) *TextField { t.CursorColor = v; return t }

// SetPlaceholderColor sets the [TextField.PlaceholderColor]:
// PlaceholderColor is the color used for the [TextField.Placeholder] text.
// It should be set in a Styler like all other style properties.
// By default, it is [colors.Scheme.OnSurfaceVariant].
func (t *TextField) SetPlaceholderColor(v image.Image) *TextField { t.PlaceholderColor = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.TimePicker", IDName: "time-picker", Doc: "TimePicker is a widget for picking a time.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Time", Doc: "Time is the time that we are viewing."}, {Name: "hour", Doc: "the raw input hour"}, {Name: "pm", Doc: "whether we are in pm mode (so we have to add 12h to everything)"}}})

// NewTimePicker returns a new [TimePicker] with the given optional parent:
// TimePicker is a widget for picking a time.
func NewTimePicker(parent ...tree.Node) *TimePicker { return tree.New[TimePicker](parent...) }

// SetTime sets the [TimePicker.Time]:
// Time is the time that we are viewing.
func (t *TimePicker) SetTime(v time.Time) *TimePicker { t.Time = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.DatePicker", IDName: "date-picker", Doc: "DatePicker is a widget for picking a date.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Time", Doc: "Time is the time that we are viewing."}, {Name: "getTime", Doc: "getTime converts the given calendar grid index to its corresponding time.\nWe must store this logic in a closure so that it can always be recomputed\ncorrectly in the inner closures of the grid maker; otherwise, the local\nvariables needed would be stale."}, {Name: "som", Doc: "som is the start of the month (must be set here to avoid stale variables)."}}})

// NewDatePicker returns a new [DatePicker] with the given optional parent:
// DatePicker is a widget for picking a date.
func NewDatePicker(parent ...tree.Node) *DatePicker { return tree.New[DatePicker](parent...) }

// SetTime sets the [DatePicker.Time]:
// Time is the time that we are viewing.
func (t *DatePicker) SetTime(v time.Time) *DatePicker { t.Time = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.TimeInput", IDName: "time-input", Doc: "TimeInput presents two text fields for editing a date and time,\nboth of which can pull up corresponding picker dialogs.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Time"}, {Name: "DisplayDate", Doc: "DisplayDate is whether the date input is displayed (default true)."}, {Name: "DisplayTime", Doc: "DisplayTime is whether the time input is displayed (default true)."}}})

// NewTimeInput returns a new [TimeInput] with the given optional parent:
// TimeInput presents two text fields for editing a date and time,
// both of which can pull up corresponding picker dialogs.
func NewTimeInput(parent ...tree.Node) *TimeInput { return tree.New[TimeInput](parent...) }

// SetTime sets the [TimeInput.Time]
func (t *TimeInput) SetTime(v time.Time) *TimeInput { t.Time = v; return t }

// SetDisplayDate sets the [TimeInput.DisplayDate]:
// DisplayDate is whether the date input is displayed (default true).
func (t *TimeInput) SetDisplayDate(v bool) *TimeInput { t.DisplayDate = v; return t }

// SetDisplayTime sets the [TimeInput.DisplayTime]:
// DisplayTime is whether the time input is displayed (default true).
func (t *TimeInput) SetDisplayTime(v bool) *TimeInput { t.DisplayTime = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.DurationInput", IDName: "duration-input", Doc: "DurationInput represents a [time.Duration] value with a spinner and unit chooser.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Duration"}, {Name: "Unit", Doc: "Unit is the unit of time."}}})

// NewDurationInput returns a new [DurationInput] with the given optional parent:
// DurationInput represents a [time.Duration] value with a spinner and unit chooser.
func NewDurationInput(parent ...tree.Node) *DurationInput { return tree.New[DurationInput](parent...) }

// SetDuration sets the [DurationInput.Duration]
func (t *DurationInput) SetDuration(v time.Duration) *DurationInput { t.Duration = v; return t }

// SetUnit sets the [DurationInput.Unit]:
// Unit is the unit of time.
func (t *DurationInput) SetUnit(v string) *DurationInput { t.Unit = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Toolbar", IDName: "toolbar", Doc: "Toolbar is a [Frame] that is useful for holding [Button]s that do things.\nIt automatically moves items that do not fit into an overflow menu, and\nmanages additional items that are always placed onto this overflow menu.\nToolbars are frequently added in [Body.AddTopBar]. All toolbars use the\n[WidgetBase.Maker] system, so you cannot directly add widgets; see\nhttps://cogentcore.org/core/toolbar.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "OverflowMenus", Doc: "OverflowMenus are functions for configuring the overflow menu of the\ntoolbar. You can use [Toolbar.AddOverflowMenu] to add them.\nThese are processed in reverse order (last in, first called)\nso that the default items are added last."}, {Name: "allItemsPlan", Doc: "allItemsPlan has all the items, during layout sizing"}, {Name: "overflowItems", Doc: "overflowItems are items moved from the main toolbar that will be\nshown in the overflow menu."}, {Name: "overflowButton", Doc: "overflowButton is the widget to pull up the overflow menu."}}})

// NewToolbar returns a new [Toolbar] with the given optional parent:
// Toolbar is a [Frame] that is useful for holding [Button]s that do things.
// It automatically moves items that do not fit into an overflow menu, and
// manages additional items that are always placed onto this overflow menu.
// Toolbars are frequently added in [Body.AddTopBar]. All toolbars use the
// [WidgetBase.Maker] system, so you cannot directly add widgets; see
// https://cogentcore.org/core/toolbar.
func NewToolbar(parent ...tree.Node) *Toolbar { return tree.New[Toolbar](parent...) }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Treer", IDName: "treer", Doc: "Treer is an interface for [Tree] types\nproviding access to the base [Tree] and\noverridable method hooks for actions taken on the [Tree],\nincluding OnOpen, OnClose, etc.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Methods: []types.Method{{Name: "AsCoreTree", Doc: "AsTree returns the base [Tree] for this node.", Returns: []string{"Tree"}}, {Name: "CanOpen", Doc: "CanOpen returns true if the node is able to open.\nBy default it checks HasChildren(), but could check other properties\nto perform lazy building of the tree.", Returns: []string{"bool"}}, {Name: "OnOpen", Doc: "OnOpen is called when a node is toggled open.\nThe base version does nothing."}, {Name: "OnClose", Doc: "OnClose is called when a node is toggled closed.\nThe base version does nothing."}, {Name: "MimeData", Args: []string{"md"}}, {Name: "Cut"}, {Name: "Copy"}, {Name: "Paste"}, {Name: "DeleteSelected"}, {Name: "DragDrop", Args: []string{"e"}}, {Name: "DropDeleteSource", Args: []string{"e"}}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.Tree", IDName: "tree", Doc: "Tree provides a graphical representation of a tree structure,\nproviding full navigation and manipulation abilities.\n\nIt does not handle layout by itself, so if you want it to scroll\nseparately from the rest of the surrounding context, you must\nplace it in a [Frame].\n\nIf the [Tree.SyncNode] field is non-nil, typically via the\n[Tree.SyncTree] method, then the Tree mirrors another\ntree structure, and tree editing functions apply to\nthe source tree first, and then to the Tree by sync.\n\nOtherwise, data can be directly encoded in a Tree\nderived type, to represent any kind of tree structure\nand associated data.\n\nStandard [events.Event]s are sent to any listeners, including\n[events.Select], [events.Change], and [events.DoubleClick].\nThe selected nodes are in the root [Tree.SelectedNodes] list;\nselect events are sent to both selected nodes and the root node.\nSee [Tree.IsRootSelected] to check whether a select event on the root\nnode corresponds to the root node or another node.", Methods: []types.Method{{Name: "OpenAll", Doc: "OpenAll opens the node and all of its sub-nodes.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "CloseAll", Doc: "CloseAll closes the node and all of its sub-nodes.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "DeleteSelected", Doc: "DeleteSelected deletes selected items.\nMust be called from first node in selection.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "Copy", Doc: "Copy copies the selected items to the clipboard.\nThis must be called on the first item in the selected list.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "Cut", Doc: "Cut copies to [system.Clipboard] and deletes selected items.\nThis must be called on the first item in the selected list.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "Paste", Doc: "Paste pastes clipboard at given node.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "InsertAfter", Doc: "InsertAfter inserts a new node in the tree\nafter this node, at the same (sibling) level,\nprompting for the type of node to insert.\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "InsertBefore", Doc: "InsertBefore inserts a new node in the tree\nbefore this node, at the same (sibling) level,\nprompting for the type of node to insert\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "AddChildNode", Doc: "AddChildNode adds a new child node to this one in the tree,\nprompting the user for the type of node to add\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "DeleteNode", Doc: "DeleteNode deletes the tree node or sync node corresponding\nto this view node in the sync tree.\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "Duplicate", Doc: "Duplicate duplicates the sync node corresponding to this view node in\nthe tree, and inserts the duplicate after this node (as a new sibling).\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "EditNode", Doc: "EditNode pulls up a [Form] dialog for the node.\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "inspectNode", Doc: "inspectNode pulls up a new Inspector window on the node.\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "WidgetBase"}}, Fields: []types.Field{{Name: "SyncNode", Doc: "SyncNode, if non-nil, is the [tree.Node] that this widget is\nviewing in the tree (the source). It should be set using\n[Tree.SyncTree]."}, {Name: "Text", Doc: "Text is the text to display for the tree item label, which automatically\ndefaults to the [tree.Node.Name] of the tree node. It has no effect\nif [Tree.SyncNode] is non-nil."}, {Name: "Icon", Doc: "Icon is an optional icon displayed to the the left of the text label."}, {Name: "IconOpen", Doc: "IconOpen is the icon to use for an open (expanded) branch;\nit defaults to [icons.KeyboardArrowDown]."}, {Name: "IconClosed", Doc: "IconClosed is the icon to use for a closed (collapsed) branch;\nit defaults to [icons.KeyboardArrowRight]."}, {Name: "IconLeaf", Doc: "IconLeaf is the icon to use for a terminal node branch that has no children;\nit defaults to [icons.Blank]."}, {Name: "TreeInit", Doc: "TreeInit is a function that can be set on the root node that is called\nwith each child tree node when it is initialized. It is only\ncalled with the root node itself in [Tree.SetTreeInit], so you\nshould typically call that instead of setting this directly."}, {Name: "Indent", Doc: "Indent is the amount to indent children relative to this node.\nIt should be set in a Styler like all other style properties."}, {Name: "OpenDepth", Doc: "OpenDepth is the depth for nodes be initialized as open (default 4).\nNodes beyond this depth will be initialized as closed."}, {Name: "Closed", Doc: "Closed is whether this tree node is currently toggled closed\n(children not visible)."}, {Name: "SelectMode", Doc: "SelectMode, when set on the root node, determines whether keyboard movements should update selection."}, {Name: "viewIndex", Doc: "linear index of this node within the entire tree.\nupdated on full rebuilds and may sometimes be off,\nbut close enough for expected uses"}, {Name: "widgetSize", Doc: "size of just this node widget.\nour alloc includes all of our children, but we only draw us."}, {Name: "Root", Doc: "Root is the cached root of the tree. It is automatically set."}, {Name: "SelectedNodes", Doc: "SelectedNodes holds the currently selected nodes.\nIt is only set on the root node. See [Tree.GetSelectedNodes]\nfor a version that also works on non-root nodes."}, {Name: "actStateLayer", Doc: "actStateLayer is the actual state layer of the tree, which\nshould be used when rendering it and its parts (but not its children).\nthe reason that it exists is so that the children of the tree\n(other trees) do not inherit its stateful background color, as\nthat does not look good."}, {Name: "inOpen", Doc: "inOpen is set in the Open method to prevent recursive opening for lazy-open nodes."}, {Name: "Branch", Doc: "Branch is the branch widget that is used to open and close the tree node."}}})

// NewTree returns a new [Tree] with the given optional parent:
// Tree provides a graphical representation of a tree structure,
// providing full navigation and manipulation abilities.
//
// It does not handle layout by itself, so if you want it to scroll
// separately from the rest of the surrounding context, you must
// place it in a [Frame].
//
// If the [Tree.SyncNode] field is non-nil, typically via the
// [Tree.SyncTree] method, then the Tree mirrors another
// tree structure, and tree editing functions apply to
// the source tree first, and then to the Tree by sync.
//
// Otherwise, data can be directly encoded in a Tree
// derived type, to represent any kind of tree structure
// and associated data.
//
// Standard [events.Event]s are sent to any listeners, including
// [events.Select], [events.Change], and [events.DoubleClick].
// The selected nodes are in the root [Tree.SelectedNodes] list;
// select events are sent to both selected nodes and the root node.
// See [Tree.IsRootSelected] to check whether a select event on the root
// node corresponds to the root node or another node.
func NewTree(parent ...tree.Node) *Tree { return tree.New[Tree](parent...) }

// SetText sets the [Tree.Text]:
// Text is the text to display for the tree item label, which automatically
// defaults to the [tree.Node.Name] of the tree node. It has no effect
// if [Tree.SyncNode] is non-nil.
func (t *Tree) SetText(v string) *Tree { t.Text = v; return t }

// SetIcon sets the [Tree.Icon]:
// Icon is an optional icon displayed to the the left of the text label.
func (t *Tree) SetIcon(v icons.Icon) *Tree { t.Icon = v; return t }

// SetIconOpen sets the [Tree.IconOpen]:
// IconOpen is the icon to use for an open (expanded) branch;
// it defaults to [icons.KeyboardArrowDown].
func (t *Tree) SetIconOpen(v icons.Icon) *Tree { t.IconOpen = v; return t }

// SetIconClosed sets the [Tree.IconClosed]:
// IconClosed is the icon to use for a closed (collapsed) branch;
// it defaults to [icons.KeyboardArrowRight].
func (t *Tree) SetIconClosed(v icons.Icon) *Tree { t.IconClosed = v; return t }

// SetIconLeaf sets the [Tree.IconLeaf]:
// IconLeaf is the icon to use for a terminal node branch that has no children;
// it defaults to [icons.Blank].
func (t *Tree) SetIconLeaf(v icons.Icon) *Tree { t.IconLeaf = v; return t }

// SetIndent sets the [Tree.Indent]:
// Indent is the amount to indent children relative to this node.
// It should be set in a Styler like all other style properties.
func (t *Tree) SetIndent(v units.Value) *Tree { t.Indent = v; return t }

// SetOpenDepth sets the [Tree.OpenDepth]:
// OpenDepth is the depth for nodes be initialized as open (default 4).
// Nodes beyond this depth will be initialized as closed.
func (t *Tree) SetOpenDepth(v int) *Tree { t.OpenDepth = v; return t }

// SetClosed sets the [Tree.Closed]:
// Closed is whether this tree node is currently toggled closed
// (children not visible).
func (t *Tree) SetClosed(v bool) *Tree { t.Closed = v; return t }

// SetSelectMode sets the [Tree.SelectMode]:
// SelectMode, when set on the root node, determines whether keyboard movements should update selection.
func (t *Tree) SetSelectMode(v bool) *Tree { t.SelectMode = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.ListButton", IDName: "list-button", Doc: "ListButton represents a slice or array value with a button that opens a [List].", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Slice"}}})

// NewListButton returns a new [ListButton] with the given optional parent:
// ListButton represents a slice or array value with a button that opens a [List].
func NewListButton(parent ...tree.Node) *ListButton { return tree.New[ListButton](parent...) }

// SetSlice sets the [ListButton.Slice]
func (t *ListButton) SetSlice(v any) *ListButton { t.Slice = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.FormButton", IDName: "form-button", Doc: "FormButton represents a struct value with a button that opens a [Form].", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Struct"}}})

// NewFormButton returns a new [FormButton] with the given optional parent:
// FormButton represents a struct value with a button that opens a [Form].
func NewFormButton(parent ...tree.Node) *FormButton { return tree.New[FormButton](parent...) }

// SetStruct sets the [FormButton.Struct]
func (t *FormButton) SetStruct(v any) *FormButton { t.Struct = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.KeyedListButton", IDName: "keyed-list-button", Doc: "KeyedListButton represents a map value with a button that opens a [KeyedList].", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Map"}}})

// NewKeyedListButton returns a new [KeyedListButton] with the given optional parent:
// KeyedListButton represents a map value with a button that opens a [KeyedList].
func NewKeyedListButton(parent ...tree.Node) *KeyedListButton {
	return tree.New[KeyedListButton](parent...)
}

// SetMap sets the [KeyedListButton.Map]
func (t *KeyedListButton) SetMap(v any) *KeyedListButton { t.Map = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.TreeButton", IDName: "tree-button", Doc: "TreeButton represents a [tree.Node] value with a button.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Tree"}}})

// NewTreeButton returns a new [TreeButton] with the given optional parent:
// TreeButton represents a [tree.Node] value with a button.
func NewTreeButton(parent ...tree.Node) *TreeButton { return tree.New[TreeButton](parent...) }

// SetTree sets the [TreeButton.Tree]
func (t *TreeButton) SetTree(v tree.Node) *TreeButton { t.Tree = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.TypeChooser", IDName: "type-chooser", Doc: "TypeChooser represents a [types.Type] value with a chooser.", Embeds: []types.Field{{Name: "Chooser"}}})

// NewTypeChooser returns a new [TypeChooser] with the given optional parent:
// TypeChooser represents a [types.Type] value with a chooser.
func NewTypeChooser(parent ...tree.Node) *TypeChooser { return tree.New[TypeChooser](parent...) }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.IconButton", IDName: "icon-button", Doc: "IconButton represents an [icons.Icon] with a [Button] that opens\na dialog for selecting the icon.", Embeds: []types.Field{{Name: "Button"}}})

// NewIconButton returns a new [IconButton] with the given optional parent:
// IconButton represents an [icons.Icon] with a [Button] that opens
// a dialog for selecting the icon.
func NewIconButton(parent ...tree.Node) *IconButton { return tree.New[IconButton](parent...) }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.FontButton", IDName: "font-button", Doc: "FontButton represents a [FontName] with a [Button] that opens\na dialog for selecting the font family.", Embeds: []types.Field{{Name: "Button"}}})

// NewFontButton returns a new [FontButton] with the given optional parent:
// FontButton represents a [FontName] with a [Button] that opens
// a dialog for selecting the font family.
func NewFontButton(parent ...tree.Node) *FontButton { return tree.New[FontButton](parent...) }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.HighlightingButton", IDName: "highlighting-button", Doc: "HighlightingButton represents a [HighlightingName] with a button.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "HighlightingName"}}})

// NewHighlightingButton returns a new [HighlightingButton] with the given optional parent:
// HighlightingButton represents a [HighlightingName] with a button.
func NewHighlightingButton(parent ...tree.Node) *HighlightingButton {
	return tree.New[HighlightingButton](parent...)
}

// SetHighlightingName sets the [HighlightingButton.HighlightingName]
func (t *HighlightingButton) SetHighlightingName(v string) *HighlightingButton {
	t.HighlightingName = v
	return t
}

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/core.WidgetBase", IDName: "widget-base", Doc: "WidgetBase implements the [Widget] interface and provides the core functionality\nof a widget. You must use WidgetBase as an embedded struct in all higher-level\nwidget types. It renders the standard box model, but does not layout or render\nany children; see [Frame] for that.", Methods: []types.Method{{Name: "Update", Doc: "Update updates the widget and all of its children by running [WidgetBase.UpdateWidget]\nand [WidgetBase.Style] on each one, and triggering a new layout pass with\n[WidgetBase.NeedsLayout]. It is the main way that end users should trigger widget\nupdates, and it is guaranteed to fully update a widget to the current state.\nFor example, it should be called after making any changes to the core properties\nof a widget, such as the text of [Text], the icon of a [Button], or the slice\nof a [Table].\n\nUpdate differs from [WidgetBase.UpdateWidget] in that it updates the widget and all\nof its children down the tree, whereas [WidgetBase.UpdateWidget] only updates the widget\nitself. Also, Update also calls [WidgetBase.Style] and [WidgetBase.NeedsLayout],\nwhereas [WidgetBase.UpdateWidget] does not. End-user code should typically call Update,\nnot [WidgetBase.UpdateWidget].\n\nIf you are calling this in a separate goroutine outside of the main\nconfiguration, rendering, and event handling structure, you need to\ncall [WidgetBase.AsyncLock] and [WidgetBase.AsyncUnlock] before and\nafter this, respectively.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "NodeBase"}}, Fields: []types.Field{{Name: "Tooltip", Doc: "Tooltip is the text for the tooltip for this widget,\nwhich can use HTML formatting."}, {Name: "Parts", Doc: "Parts are a separate tree of sub-widgets that can be used to store\northogonal parts of a widget when necessary to separate them from children.\nFor example, [Tree]s use parts to separate their internal parts from\nthe other child tree nodes. Composite widgets like buttons should\nNOT use parts to store their components; parts should only be used when\nabsolutely necessary. Use [WidgetBase.newParts] to make the parts."}, {Name: "Geom", Doc: "Geom has the full layout geometry for size and position of this widget."}, {Name: "OverrideStyle", Doc: "OverrideStyle, if true, indicates override the computed styles of the widget\nand allow directly editing [WidgetBase.Styles]. It is typically only set in\nthe inspector."}, {Name: "Styles", Doc: "Styles are styling settings for this widget. They are set by\n[WidgetBase.Stylers] in [WidgetBase.Style]."}, {Name: "Stylers", Doc: "Stylers is a tiered set of functions that are called in sequential\nascending order (so the last added styler is called last and\nthus can override all other stylers) to style the element.\nThese should be set using the [WidgetBase.Styler], [WidgetBase.FirstStyler],\nand [WidgetBase.FinalStyler] functions."}, {Name: "Listeners", Doc: "Listeners is a tiered set of event listener functions for processing events on this widget.\nThey are called in sequential descending order (so the last added listener\nis called first). They should be added using the [WidgetBase.On], [WidgetBase.OnFirst],\nand [WidgetBase.OnFinal] functions, or any of the various On{EventType} helper functions."}, {Name: "ContextMenus", Doc: "ContextMenus is a slice of menu functions to call to construct\nthe widget's context menu on an [events.ContextMenu]. The\nfunctions are called in reverse order such that the elements\nadded in the last function are the first in the menu.\nContext menus should be added through [WidgetBase.AddContextMenu].\nSeparators will be added between each context menu function.\n[Scene.ContextMenus] apply to all widgets in the scene."}, {Name: "Deferred", Doc: "Deferred is a slice of functions to call after the next [Scene] update/render.\nIn each function event sending etc will work as expected. Use\n[WidgetBase.Defer] to add a function."}, {Name: "Scene", Doc: "Scene is the overall Scene to which we belong. It is automatically\nby widgets whenever they are added to another widget parent."}, {Name: "ValueUpdate", Doc: "ValueUpdate is a function set by [Bind] that is called in\n[WidgetBase.UpdateWidget] to update the widget's value from the bound value.\nIt should not be accessed by end users."}, {Name: "ValueOnChange", Doc: "ValueOnChange is a function set by [Bind] that is called when\nthe widget receives an [events.Change] event to update the bound value\nfrom the widget's value. It should not be accessed by end users."}, {Name: "ValueTitle", Doc: "ValueTitle is the title to display for a dialog for this [Value]."}, {Name: "flags", Doc: "/ flags are atomic bit flags for [WidgetBase] state."}}})

// NewWidgetBase returns a new [WidgetBase] with the given optional parent:
// WidgetBase implements the [Widget] interface and provides the core functionality
// of a widget. You must use WidgetBase as an embedded struct in all higher-level
// widget types. It renders the standard box model, but does not layout or render
// any children; see [Frame] for that.
func NewWidgetBase(parent ...tree.Node) *WidgetBase { return tree.New[WidgetBase](parent...) }

// SetTooltip sets the [WidgetBase.Tooltip]:
// Tooltip is the text for the tooltip for this widget,
// which can use HTML formatting.
func (t *WidgetBase) SetTooltip(v string) *WidgetBase { t.Tooltip = v; return t }

// SetValueTitle sets the [WidgetBase.ValueTitle]:
// ValueTitle is the title to display for a dialog for this [Value].
func (t *WidgetBase) SetValueTitle(v string) *WidgetBase { t.ValueTitle = v; return t }

var _ = types.AddFunc(&types.Func{Name: "cogentcore.org/core/core.ProfileToggle", Doc: "ProfileToggle turns profiling on or off, which does both\ntargeted profiling and global CPU and memory profiling.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}})

var _ = types.AddFunc(&types.Func{Name: "cogentcore.org/core/core.resetAllSettings", Doc: "resetAllSettings resets all of the settings to their default values.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"error"}})

var _ = types.AddFunc(&types.Func{Name: "cogentcore.org/core/core.UpdateAll", Doc: "UpdateAll updates all windows and triggers a full render rebuild.\nIt is typically called when user settings are changed.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}})

var _ = types.AddFunc(&types.Func{Name: "cogentcore.org/core/core.SettingsWindow", Doc: "SettingsWindow opens a window for editing user settings.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}})
